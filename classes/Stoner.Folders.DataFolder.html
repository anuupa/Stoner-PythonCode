
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DataFolder &#8212; Stoner Pacakge API Documentation</title>
    <link rel="stylesheet" href="../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PlotFolder" href="Stoner.Folders.PlotFolder.html" />
    <link rel="prev" title="DiskBasedFolder" href="Stoner.Folders.DiskBasedFolder.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../index.html ">
        Stoner Pacakge API Documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Stoner.Folders.DiskBasedFolder.html" title="Previous document">DiskBasedFolder</a>
        </li>
        <li>
          <a href="Stoner.Folders.PlotFolder.html" title="Next document">PlotFolder</a>
          &rarr;
        </li>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">Stoner Package</a></li>
      <li>
        <a href="../Stoner.html"><code class="docutils literal notranslate"><span class="pre">Stoner</span></code> Package</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="datafolder">
<h1>DataFolder<a class="headerlink" href="#datafolder" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="Stoner.Folders.DataFolder">
<em class="property">class </em><code class="descclassname">Stoner.Folders.</code><code class="descname">DataFolder</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Folders.html#DataFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Folders.DataFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="Stoner.Folders.DiskBasedFolder.html#Stoner.Folders.DiskBasedFolder" title="Stoner.Folders.DiskBasedFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Folders.DiskBasedFolder</span></code></a>, <a class="reference internal" href="Stoner.Folders.baseFolder.html#Stoner.Folders.baseFolder" title="Stoner.Folders.baseFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Folders.baseFolder</span></code></a></p>
<p>Provide an interface to manipulating lots of data files stored within a directory structure on disc.</p>
<p>By default, the members of the DataFolder are isntances of <a class="reference internal" href="Stoner.Data.html#Stoner.Data" title="Stoner.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Data</span></code></a>. The DataFolder emplys a lazy open strategy, so that
files are only read in from disc when actually needed.</p>
<img src="../_images/inheritance-13041374ebb3cc7cb1e53decf1d858c9bfa0bb6f.png" alt="Inheritance diagram of DataFolder" usemap="#inheritancebd3fb28729" class="inheritance"/>
<map id="inheritancebd3fb28729" name="inheritancebd3fb28729">
<area shape="rect" id="node1" href="#Stoner.Folders.DataFolder" target="_top" title="Provide an interface to manipulating lots of data files stored within a directory structure on disc." alt="" coords="665,30,765,43"/>
<area shape="rect" id="node2" href="Stoner.Folders.DiskBasedFolder.html#Stoner.Folders.DiskBasedFolder" target="_top" title="A Mixin class that implmenets reading metadataObjects from disc." alt="" coords="521,16,640,30"/>
<area shape="rect" id="node3" href="Stoner.Folders.baseFolder.html#Stoner.Folders.baseFolder" target="_top" title="A base class for objectFolders that supports both a sequence of objects and a mapping of instances of itself." alt="" coords="531,42,630,56"/>
</map><p class="rubric">Attributes Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.basenames" title="Stoner.Folders.DataFolder.basenames"><code class="xref py py-obj docutils literal notranslate"><span class="pre">basenames</span></code></a></td>
<td>Returns a list of just the filename parts of the objectFolder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.clone" title="Stoner.Folders.DataFolder.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clone</span></code></a></td>
<td>Clone just does a deepcopy as a property for compatibility with <a class="reference internal" href="Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.DataFile</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.depth" title="Stoner.Folders.DataFolder.depth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">depth</span></code></a></td>
<td>Gives the maximum number of levels of group below the current objectFolder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.each" title="Stoner.Folders.DataFolder.each"><code class="xref py py-obj docutils literal notranslate"><span class="pre">each</span></code></a></td>
<td>Return a proxy object for calling attributes of the member type of the folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.files" title="Stoner.Folders.DataFolder.files"><code class="xref py py-obj docutils literal notranslate"><span class="pre">files</span></code></a></td>
<td>Return an iterator of potentially unloaded named objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.groups" title="Stoner.Folders.DataFolder.groups"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groups</span></code></a></td>
<td>Subfolders are held in an ordered dictionary of groups.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.instance" title="Stoner.Folders.DataFolder.instance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">instance</span></code></a></td>
<td>A default instance of the type of object in the folder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.key" title="Stoner.Folders.DataFolder.key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">key</span></code></a></td>
<td>Allow overriding for getting and setting the key in mixins.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.loaded" title="Stoner.Folders.DataFolder.loaded"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loaded</span></code></a></td>
<td>An iterator that indicates wether the contents of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Folders.objectFolder</span></code> has been loaded into memory.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.ls" title="Stoner.Folders.DataFolder.ls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls</span></code></a></td>
<td>List just the names of the objects in the folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.lsgrp" title="Stoner.Folders.DataFolder.lsgrp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lsgrp</span></code></a></td>
<td>Returns a list of the groups as a generator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.metadata" title="Stoner.Folders.DataFolder.metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metadata</span></code></a></td>
<td>Returns the proxy accessor for operations on combined metadata.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.mindepth" title="Stoner.Folders.DataFolder.mindepth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mindepth</span></code></a></td>
<td>Gives the minimum number of levels of group below the current objectFolder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.not_empty" title="Stoner.Folders.DataFolder.not_empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">not_empty</span></code></a></td>
<td>An iterator for objectFolder that checks whether the loaded metadataObject objects have any data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.objects" title="Stoner.Folders.DataFolder.objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">objects</span></code></a></td>
<td>The objects in the folder are stored in a <code class="xref py py-class docutils literal notranslate"><span class="pre">regexpDict</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.pattern" title="Stoner.Folders.DataFolder.pattern"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pattern</span></code></a></td>
<td>Provide support for getting the pattern attribute.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.shape" title="Stoner.Folders.DataFolder.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></td>
<td>Return a data structure that is characteristic of the objectFolder’s shape.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.type" title="Stoner.Folders.DataFolder.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></td>
<td>Defines the (sub)class of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code> instances.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.add_group" title="Stoner.Folders.DataFolder.add_group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_group</span></code></a>(key)</td>
<td>Add a new group to the current baseFolder with the given key.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.append" title="Stoner.Folders.DataFolder.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(value)</td>
<td>Append an item to the folder object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.clear" title="Stoner.Folders.DataFolder.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td>Clear the subgroups.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.concatentate" title="Stoner.Folders.DataFolder.concatentate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">concatentate</span></code></a>([sort,&nbsp;reverse])</td>
<td>Concatentates all the files in a objectFolder into a single metadataObject like object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.count" title="Stoner.Folders.DataFolder.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(name)</td>
<td>Provide a count method like a sequence.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.extend" title="Stoner.Folders.DataFolder.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(values)</td>
<td>S.extend(iterable) – extend sequence by appending elements from the iterable</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.extract" title="Stoner.Folders.DataFolder.extract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></a>(*metadata,&nbsp;**kargs)</td>
<td>Walks through the terminal group and gets the listed metadata from each file and constructsa replacement metadataObject.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.file" title="Stoner.Folders.DataFolder.file"><code class="xref py py-obj docutils literal notranslate"><span class="pre">file</span></code></a>(name,&nbsp;value[,&nbsp;create,&nbsp;pathsplit])</td>
<td>Recursively add groups in order to put the named value into a virtual tree of <a class="reference internal" href="Stoner.Folders.baseFolder.html#Stoner.Folders.baseFolder" title="Stoner.Folders.baseFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">baseFolder</span></code></a>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.filter" title="Stoner.Folders.DataFolder.filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter</span></code></a>([filter,&nbsp;invert,&nbsp;copy])</td>
<td>Filter the current set of files by some criterion</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.filterout" title="Stoner.Folders.DataFolder.filterout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filterout</span></code></a>(filter[,&nbsp;copy])</td>
<td>Synonym for self.filter(filter,invert=True)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.flatten" title="Stoner.Folders.DataFolder.flatten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code></a>([depth])</td>
<td>Compresses all the groups and sub-groups iunto a single flat file list.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.gather" title="Stoner.Folders.DataFolder.gather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gather</span></code></a>([xcol,&nbsp;ycol])</td>
<td>Collects xy and y columns from the subfiles in the final group in the tree and builds iunto a <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.get" title="Stoner.Folders.DataFolder.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(name[,&nbsp;default])</td>
<td>Return either a sub-group or named object from this folder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.getlist" title="Stoner.Folders.DataFolder.getlist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getlist</span></code></a>([recursive,&nbsp;directory,&nbsp;flatten,&nbsp;…])</td>
<td>Scans the current directory, optionally recursively to build a list of filenames</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group</span></code></a>(key)</td>
<td>Take the files and sort them into a series of separate objectFolder objects according to the value of the key</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.index" title="Stoner.Folders.DataFolder.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(name[,&nbsp;start,&nbsp;end])</td>
<td>Provide an index method like a sequence.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.insert" title="Stoner.Folders.DataFolder.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(ix,&nbsp;value)</td>
<td>Implements the insert method with the option to append as well.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.items" title="Stoner.Folders.DataFolder.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</td>
<td>Return the key,value pairs for the subbroups of this folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.keep_latest" title="Stoner.Folders.DataFolder.keep_latest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keep_latest</span></code></a>()</td>
<td>Filter out earlier revisions of files with the same name.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.keys" title="Stoner.Folders.DataFolder.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</td>
<td>Return the keys used to access the sub-=groups of this folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.make_name" title="Stoner.Folders.DataFolder.make_name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_name</span></code></a>([value])</td>
<td>Construct a name from the value object if possible.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.next" title="Stoner.Folders.DataFolder.next"><code class="xref py py-obj docutils literal notranslate"><span class="pre">next</span></code></a>()</td>
<td>Python 2.7 style iterator function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.pop" title="Stoner.Folders.DataFolder.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>([name,&nbsp;default])</td>
<td>Return and remove either a subgroup or named object from this folder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.popitem" title="Stoner.Folders.DataFolder.popitem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code></a>()</td>
<td>Return the most recent subgroup from this folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.prune" title="Stoner.Folders.DataFolder.prune"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prune</span></code></a>()</td>
<td>Remove any groups from the objectFolder (and subgroups).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.remove" title="Stoner.Folders.DataFolder.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(value)</td>
<td>S.remove(value) – remove first occurrence of value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.reverse" title="Stoner.Folders.DataFolder.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>()</td>
<td>S.reverse() – reverse <em>IN PLACE</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.save" title="Stoner.Folders.DataFolder.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>([root])</td>
<td>Save the entire data folder out to disc using the groups as a directory tree, calling the save method for each file in turn.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.select" title="Stoner.Folders.DataFolder.select"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select</span></code></a>(*args,&nbsp;**kargs)</td>
<td>A generator that can be used to select particular data files from the objectFolder</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.setdefault" title="Stoner.Folders.DataFolder.setdefault"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code></a>(k[,&nbsp;d])</td>
<td>Return or set a subgroup or named object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.slice_metadata" title="Stoner.Folders.DataFolder.slice_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_metadata</span></code></a>(key[,&nbsp;output])</td>
<td>Return an array of the metadata values for each item/file in the top level group</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.sort" title="Stoner.Folders.DataFolder.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>([key,&nbsp;reverse])</td>
<td>Sort the files by some key</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.unflatten" title="Stoner.Folders.DataFolder.unflatten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unflatten</span></code></a>()</td>
<td>Takes a file list an unflattens them according to the file paths.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.unload" title="Stoner.Folders.DataFolder.unload"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unload</span></code></a>(name)</td>
<td>Removes the instance from memory without losing the name in the Folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.update" title="Stoner.Folders.DataFolder.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(other)</td>
<td>Update this folder with a dictionary or another folder.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.values" title="Stoner.Folders.DataFolder.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a>()</td>
<td>Return the sub-groups of this folder.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.walk_groups" title="Stoner.Folders.DataFolder.walk_groups"><code class="xref py py-obj docutils literal notranslate"><span class="pre">walk_groups</span></code></a>(walker,&nbsp;**kargs)</td>
<td>Walks through a heirarchy of groups and calls walker for each file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Folders.DataFolder.zip_groups" title="Stoner.Folders.DataFolder.zip_groups"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zip_groups</span></code></a>(groups)</td>
<td>Return a list of tuples of metadataObjects drawn from the specified groups</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.basenames">
<code class="descname">basenames</code><a class="headerlink" href="#Stoner.Folders.DataFolder.basenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of just the filename parts of the objectFolder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.clone">
<code class="descname">clone</code><a class="headerlink" href="#Stoner.Folders.DataFolder.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone just does a deepcopy as a property for compatibility with <a class="reference internal" href="Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.DataFile</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.depth">
<code class="descname">depth</code><a class="headerlink" href="#Stoner.Folders.DataFolder.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the maximum number of levels of group below the current objectFolder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.each">
<code class="descname">each</code><a class="headerlink" href="#Stoner.Folders.DataFolder.each" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a proxy object for calling attributes of the member type of the folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.files">
<code class="descname">files</code><a class="headerlink" href="#Stoner.Folders.DataFolder.files" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator of potentially unloaded named objects.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.groups">
<code class="descname">groups</code><a class="headerlink" href="#Stoner.Folders.DataFolder.groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Subfolders are held in an ordered dictionary of groups.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.instance">
<code class="descname">instance</code><a class="headerlink" href="#Stoner.Folders.DataFolder.instance" title="Permalink to this definition">¶</a></dt>
<dd><p>A default instance of the type of object in the folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.key">
<code class="descname">key</code><a class="headerlink" href="#Stoner.Folders.DataFolder.key" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow overriding for getting and setting the key in mixins.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.loaded">
<code class="descname">loaded</code><a class="headerlink" href="#Stoner.Folders.DataFolder.loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that indicates wether the contents of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Folders.objectFolder</span></code> has been loaded into memory.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.ls">
<code class="descname">ls</code><a class="headerlink" href="#Stoner.Folders.DataFolder.ls" title="Permalink to this definition">¶</a></dt>
<dd><p>List just the names of the objects in the folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.lsgrp">
<code class="descname">lsgrp</code><a class="headerlink" href="#Stoner.Folders.DataFolder.lsgrp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the groups as a generator.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#Stoner.Folders.DataFolder.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the proxy accessor for operations on combined metadata.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.mindepth">
<code class="descname">mindepth</code><a class="headerlink" href="#Stoner.Folders.DataFolder.mindepth" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the minimum number of levels of group below the current objectFolder.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.not_empty">
<code class="descname">not_empty</code><a class="headerlink" href="#Stoner.Folders.DataFolder.not_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator for objectFolder that checks whether the loaded metadataObject objects have any data.</p>
<p>Returns the next non-empty DatFile member of the objectFolder.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">not_empty will also silently skip over any cases where loading the metadataObject object will raise
and exception.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.objects">
<code class="descname">objects</code><a class="headerlink" href="#Stoner.Folders.DataFolder.objects" title="Permalink to this definition">¶</a></dt>
<dd><p>The objects in the folder are stored in a <code class="xref py py-class docutils literal notranslate"><span class="pre">regexpDict</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.pattern">
<code class="descname">pattern</code><a class="headerlink" href="#Stoner.Folders.DataFolder.pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide support for getting the pattern attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.shape">
<code class="descname">shape</code><a class="headerlink" href="#Stoner.Folders.DataFolder.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a data structure that is characteristic of the objectFolder’s shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Folders.DataFolder.type">
<code class="descname">type</code><a class="headerlink" href="#Stoner.Folders.DataFolder.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the (sub)class of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code> instances.</p>
</dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="method">
<dt id="Stoner.Folders.DataFolder.add_group">
<code class="descname">add_group</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.add_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new group to the current baseFolder with the given key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) – A hashable value to be used as the dictionary key in the groups dictionary</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A copy of the objectFolder</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If key already exists in the groups dictionary then no action is taken.</p>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Propagate any extra attributes into the groups.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append an item to the folder object</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the subgroups.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.concatentate">
<code class="descname">concatentate</code><span class="sig-paren">(</span><em>sort=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Folders.html#DataFolder.concatentate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Folders.DataFolder.concatentate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatentates all the files in a objectFolder into a single metadataObject like object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first simple">
<li><strong>sort</strong> (<em>column index</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, or </em><em>clallable function</em>) – Sort the resultant metadataObject by this column (if a column index),
or by the <em>x</em> column if None or True, or not at all if False. <em>sort</em> is passed directly to the eponymous method as the
<em>order</em> paramter.</li>
<li><strong>reverse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Reverse the order of the sort (defaults to False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The current objectFolder with only one metadataObject item containing all the data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a count method like a sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (str, regexp, or <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code>) – The thing to count matches for.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>(int)</em> – The number of matching metadataObject instances.</td>
</tr>
</tbody>
</table>
<p>If <em>name</em> is a string, then matching is based on either exact matches of the name, or if it includes a * or ? then the basis of a globbing match.
<em>name</em> may also be a regular expressiuon, in which case matches are made on the basis of  the match with the name of the metadataObject. Finally,
if <em>name</em> is a metadataObject, then it matches for an equyality test.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>S.extend(iterable) – extend sequence by appending elements from the iterable</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.extract">
<code class="descname">extract</code><span class="sig-paren">(</span><em>*metadata</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Folders.html#DataFolder.extract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Folders.DataFolder.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks through the terminal group and gets the listed metadata from each file and constructsa replacement metadataObject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*metadata</strong> (<em>str</em>) – One or more metadata indices that should be used to construct the new data file.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Ketyword Arguments:</dt>
<dd>copy (bool): Take a copy of the <a class="reference internal" href="#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFolder</span></code></a> before starting the extract (default is True)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An instance of a metadataObject like object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.file">
<code class="descname">file</code><span class="sig-paren">(</span><em>name</em>, <em>value</em>, <em>create=True</em>, <em>pathsplit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.file" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively add groups in order to put the named value into a virtual tree of <a class="reference internal" href="Stoner.Folders.baseFolder.html#Stoner.Folders.baseFolder" title="Stoner.Folders.baseFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">baseFolder</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>str</em>) – A name (which may be a nested path) of the object to file.</li>
<li><strong>value</strong> (<em>metadataObject</em>) – The object to be filed - it should be an instance of <a class="reference internal" href="Stoner.Folders.baseFolder.html#Stoner.Folders.baseFolder.type" title="Stoner.Folders.baseFolder.type"><code class="xref py py-attr docutils literal notranslate"><span class="pre">baseFolder.type</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Keyword Aprameters:</dt>
<dd>create(bool): Whether to create missing groups or to raise an error (default True to create groups).
pathsplit(str or None): Character to use to split the name into path components. Defaults to using os.path.split()</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>(baseFolder)</em> – A reference to the group where the value was eventually filed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>filter=None</em>, <em>invert=False</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the current set of files by some criterion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filter</strong> (<em>string or callable</em>) – Either a string flename pattern or a callable function which takes a single parameter x which is an instance of a
metadataObject and evaluates True or False</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first simple">
<li><strong>invert</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Invert the sense of the filter (done by doing an XOR whith the filter condition</li>
<li><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If set True then the <a class="reference internal" href="#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFolder</span></code></a> is copied before being filtered. Default is False - work in place.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The current objectFolder object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.filterout">
<code class="descname">filterout</code><span class="sig-paren">(</span><em>filter</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.filterout" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for self.filter(filter,invert=True)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter</strong> (<em>string or callable</em>) – Either a string flename pattern or a callable function which takes a single parameter x which is an instance of a
metadataObject and evaluates True or False</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If set True then the <a class="reference internal" href="#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFolder</span></code></a> is copied before being filtered. Default is False - work in place.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The current objectFolder object with the files in the file list filtered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Compresses all the groups and sub-groups iunto a single flat file list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><strong>)</strong> (<a class="reference internal" href="#Stoner.Folders.DataFolder.depth" title="Stoner.Folders.DataFolder.depth"><em>depth</em></a>) – Only flatten ub-=groups that are within (<em>depth</em> of the deepest level.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A copy of the now flattened DatFolder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.gather">
<code class="descname">gather</code><span class="sig-paren">(</span><em>xcol=None</em>, <em>ycol=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Folders.html#DataFolder.gather"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Folders.DataFolder.gather" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects xy and y columns from the subfiles in the final group in the tree and builds iunto a <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>xcol</strong> (<a class="reference internal" href="Stoner.DataFolder.index.html#Stoner.DataFolder.index" title="Stoner.DataFolder.index"><em>index</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – Column in each file that has x data. if None, then the setas settings are used</li>
<li><strong>ycol</strong> (<a class="reference internal" href="Stoner.DataFolder.index.html#Stoner.DataFolder.index" title="Stoner.DataFolder.index"><em>index</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – Column(s) in each filwe that contain the y data. If none, then the setas settings are used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This is a wrapper around walk_groups that assembles the data into a single file for further analysis/plotting.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>name</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Return either a sub-group or named object from this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.getlist">
<code class="descname">getlist</code><span class="sig-paren">(</span><em>recursive=None</em>, <em>directory=None</em>, <em>flatten=None</em>, <em>discard_earlier=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.getlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Scans the current directory, optionally recursively to build a list of filenames</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>recursive</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Do a walk through all the directories for files</li>
<li><strong>directory</strong> (<a class="reference external" href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.7)"><em>string</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.7)"><em>False</em></a>) – Either a string path to a new directory or False to open a dialog box or not set in which case existing
directory is used.</li>
<li><strong>flatten</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – After scanning the directory tree, flaten all the subgroupos to make a flat file list. (this is the previous behaviour of</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:keyword <code class="xref py py-meth docutils literal notranslate"><span class="pre">objectFolder.getlist:</span>
<span class="pre">:kwtype</span> <span class="pre">:py:meth:`objectFolder.getlist:</span> <span class="pre">)()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the current DataFoder directory with the files stored in the files attribute</td>
</tr>
</tbody>
</table>
<p>getlist() scans a directory tree finding files that match the pattern. By default it will recurse through the entire
directory tree finding sub directories and creating groups in the data folder for each sub directory.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.group">
<code class="descname">group</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the files and sort them into a series of separate objectFolder objects according to the value of the key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string or callable or list</em>) – Either a simple string or callable function or a list. If a string then it is interpreted as an item of
metadata in each file. If a callable function then takes a single argument x which should be an instance of a metadataObject and returns
some vale. If key is a list then the grouping is done recursively for each element in key.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A copy of the current objectFolder object in which the groups attribute is a dictionary of objectFolder objects with sub lists of files</td>
</tr>
</tbody>
</table>
<p>If ne of the grouping metadata keys does not exist in one file then no exception is raised - rather the fiiles will be returned into the group
with key None. Metadata keys that are generated from the filename are supported.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>name</em>, <em>start=None</em>, <em>end=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide an index method like a sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (str, regexp, or <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code>) – The thing to search for.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><strong>start</strong><strong>,</strong><strong>end</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – limit the index search to a sub-range as per Python 3.5+ list.index</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>(int)</em> – The index of the first matching metadataObject instances.</td>
</tr>
</tbody>
</table>
<p>If <em>name</em> is a string, then matching is based on either exact matches of the name, or if it includes a * or ? then the basis of a globbing match.
<em>name</em> may also be a regular expressiuon, in which case matches are made on the basis of  the match with the name of the metadataObject. Finally,
if <em>name</em> is a metadataObject, then it matches for an equyality test.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>ix</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the insert method with the option to append as well.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the key,value pairs for the subbroups of this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.keep_latest">
<code class="descname">keep_latest</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.keep_latest" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out earlier revisions of files with the same name.</p>
<p>The CM group LabVIEW software will avoid overwirting files when measuring by inserting !#### where #### is an integer revision number just before the
filename extension. This method will look for instances of several files which differ in name only by the presence of the revision number and will
kepp only the highest revision number. This is useful if several measurements of the same experiment have been carried out, but only the last file is
the correct one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the DataFolder.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the keys used to access the sub-=groups of this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.make_name">
<code class="descname">make_name</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.make_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a name from the value object if possible.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Python 2.7 style iterator function.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>name=-1</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return and remove either a subgroup or named object from this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the most recent subgroup from this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove any groups from the objectFolder (and subgroups).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of thte pruned objectFolder.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>S.remove(value) – remove first occurrence of value.
Raise ValueError if the value is not present.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>S.reverse() – reverse <em>IN PLACE</em></p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>root=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the entire data folder out to disc using the groups as a directory tree,
calling the save method for each file in turn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>root</strong> (<em>string</em>) – The root directory to start creating files and subdirectories under. If set to None or not specified, the current folder’s
diretory attribute will be used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of the saved files</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.select">
<code class="descname">select</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.select" title="Permalink to this definition">¶</a></dt>
<dd><p>A generator that can be used to select particular data files from the objectFolder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>various</em>) – A single positional argument if present is interpreted as follows:</li>
<li><strong>* If a callable function is given, the entire metadataObject is presented to it.</strong> – If it evaluates True then that metadataObject is selected. This allows arbitary select operations</li>
<li><strong>* If a dict is given, then it and the kargs dictionary are merged and used to select the metadataObjects</strong></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first simple">
<li><strong>recurse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Also recursively slect through the sub groups</li>
<li><strong>kargs</strong> (<em>varuous</em>) – <p>Arbitary keyword arguments are interpreted as requestion matches against the corresponding
metadata values. The keyword argument may have an additional <em>__operator*</em> appended to it which is interpreted
as follows:</p>
<ul>
<li><em>eq</em> metadata value equals argument value (this is the default test for scalar argument)</li>
<li><em>ne</em> metadata value doe not equal argument value</li>
<li><em>gt</em> metadata value doe greater than argument value</li>
<li><em>lt</em> metadata value doe less than argument value</li>
<li><em>ge</em> metadata value doe greater than or equal to argument value</li>
<li><em>le</em> metadata value doe less than or equal to argument value</li>
<li><em>contains</em> metadata value contains argument value</li>
<li><em>in</em> metadata value is in the argument value (this is the default test for non-tuple iterable arguments)</li>
<li><em>startswith</em> metadata value startswith argument value</li>
<li><em>endswith</em> metadata value endwith argument value</li>
<li><em>icontains</em>,*iin*, <em>istartswith</em>,*iendswith* as above but case insensitive</li>
<li><em>between</em> metadata value lies beween the minimum and maximum values of the arguement (the default test for 2-length tuple arguments)</li>
<li><em>ibetween</em>,*ilbetween*,*iubetween* as above but include both,lower or upper values</li>
</ul>
</li>
<li><strong>syntax is inspired by the Django project for selecting</strong><strong>, </strong><strong>but is not quite as rich.</strong> (<em>The</em>) – </li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>(baseFGolder)</em> – a new baseFolder instance that contains just the matching metadataObjects.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If any of the tests is True, then the metadataObject will be selected, so the effect is a logical OR. To
achieve a logical AND, you can chain two selects together:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">temp__le</span><span class="o">=</span><span class="mf">4.2</span><span class="p">,</span><span class="n">vti_temp__lt</span><span class="o">=</span><span class="mf">4.2</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">field_gt</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
<p>will select metadata objects that have either temp or vti_temp metadata values below 4.2 AND field metadata values greater than 3.</p>
<p class="last">If you need to select on a aparameter called <em>recurse</em>, pass a dictionary of {“recurse”:value} as the sole
positional argument. If you need to select on a metadata value that ends in an operator word, then append
<em>__eq</em> in the keyword name to force the equality test. If the metadata keys to select on are not valid python identifiers,
then pass them via the first positional dictionary value.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em>, <em>d=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.setdefault" title="Permalink to this definition">¶</a></dt>
<dd><p>Return or set a subgroup or named object.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.slice_metadata">
<code class="descname">slice_metadata</code><span class="sig-paren">(</span><em>key</em>, <em>output='smart'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.slice_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of the metadata values for each item/file in the top level group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>str, regexp or list of str</em>) – the meta data key(s) to return</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Keyword Parameters:</dt>
<dd>output (str): Output format - values are
-   dict: return an array of dictionaries
-   list: return a list of lists
-   array: return a numpy array
-   Data: return a <a class="reference internal" href="Stoner.Data.html#Stoner.Data" title="Stoner.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Data</span></code></a> object
-   smart: (default) return either a list if only one key or a list of dictionaries</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>(array of metadata)</em> –<dl class="docutils">
<dt>If single key is given and is an exact match then</dt>
<dd>returns an array of the matching values. If the key results in a regular
expression match, then returns an array of dictionaries of all matching keys. If key is a
list ir other iterable, then return a 2D array where each column corresponds to one of the keys.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Add options to recurse through all groups? Put back RCT’s values only functionality?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>key=None</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the files by some key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.7)"><em>string</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#callable" title="(in Python v3.7)"><em>callable</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a>) – Either a string or a callable function. If a string then this is interpreted as a
metadata key, if callable then it is assumed that this is a a function of one paramater x
that is a <code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.Core.metadataObject</span></code> object and that returns a key value.
If key is not specified (default), then a sort is performed on the filename</td>
</tr>
</tbody>
</table>
<p>reverse (bool): Optionally sort in reverse order</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the current objectFolder object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.unflatten">
<code class="descname">unflatten</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.unflatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a file list an unflattens them according to the file paths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A copy of the objectFolder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.unload">
<code class="descname">unload</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.unload" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the instance from memory without losing the name in the Folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<em>string or int</em>) – Specifies the entry to unload from memeory.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>(DataFolder)</em> – returns a copy of itself.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update this folder with a dictionary or another folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub-groups of this folder.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.walk_groups">
<code class="descname">walk_groups</code><span class="sig-paren">(</span><em>walker</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.walk_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Walks through a heirarchy of groups and calls walker for each file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>walker</strong> (<em>callable</em>) – a callable object that takes either a metadataObject instance or a objectFolder instance.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>group</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – (default False) determines whether the walker function will expect to be given the objectFolder
representing the lowest level group or individual metadataObject objects from the lowest level group</li>
<li><strong>replace_terminal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – if group is True and the walker function returns an instance of metadataObject then the return value is appended
to the files and the group is removed from the current objectFolder. This will unwind the group heirarchy by one level.</li>
<li><strong>obly_terminal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Only execute the walker function on groups that have no sub-groups inside them (i.e. are terminal groups)</li>
<li><strong>walker_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – a dictionary of static arguments for the walker function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>The walker function should have a prototype of the form:</dt>
<dd>walker(f,list_of_group_names,**walker_args)
where f is either a objectFolder or metadataObject.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Folders.DataFolder.zip_groups">
<code class="descname">zip_groups</code><span class="sig-paren">(</span><em>groups</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Folders.DataFolder.zip_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of tuples of metadataObjects drawn from the specified groups</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>groups</strong> (<em>list of strings</em>) – A list of keys of groups in the Lpy:class:<cite>objectFolder</cite></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>A list of tuples of groups of files</em> –     [(grp_1_file_1,grp_2_file_1….grp_n_files_1),(grp_1_file_2,grp_2_file_2….grp_n_file_2)….(grp_1_file_m,grp_2_file_m…grp_n_file_m)]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/StonerLogo2.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="Stoner.Folders.DiskBasedFolder.html"
                        title="previous chapter">DiskBasedFolder</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Stoner.Folders.PlotFolder.html"
                        title="next chapter">PlotFolder</a></p>
<div class="sourcelink">
  <a href="../_sources/classes/Stoner.Folders.DataFolder.rst.txt" rel="nofollow">
    Show page source
  </a>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Stoner.Folders.DiskBasedFolder.html" title="Previous document">DiskBasedFolder</a>
        </li>
        <li>
          <a href="Stoner.Folders.PlotFolder.html" title="Next document">PlotFolder</a>
          &rarr;
        </li>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">Stoner Package</a></li>
      <li>
        <a href="../Stoner.html"><code class="docutils literal notranslate"><span class="pre">Stoner</span></code> Package</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2013-15, Gavin Burnell et al.Last updated on Jul 18, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.7.5
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>