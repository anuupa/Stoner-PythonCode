
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ImageArray &#8212; Stoner Pacakge API Documentation</title>
    <link rel="stylesheet" href="../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="ImageStack" href="Stoner.Image.ImageStack.html" />
    <link rel="prev" title="proxy" href="Stoner.folders.metadata.proxy.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../index.html ">
        Stoner Pacakge API Documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Stoner.folders.metadata.proxy.html" title="Previous document">proxy</a>
        </li>
        <li>
          <a href="Stoner.Image.ImageStack.html" title="Next document">ImageStack</a>
          &rarr;
        </li>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">Stoner Package</a></li>
      <li>
        <a href="../Stoner.html"><code class="docutils literal notranslate"><span class="pre">Stoner</span></code> Package</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="imagearray">
<h1>ImageArray<a class="headerlink" href="#imagearray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="Stoner.Image.ImageArray">
<em class="property">class </em><code class="descclassname">Stoner.Image.</code><code class="descname">ImageArray</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="https://docs.scipy.org/doc/numpy/reference/maskedarray.baseclass.html#numpy.ma.MaskedArray" title="numpy.ma.MaskedArray"><code class="docutils literal notranslate"><span class="pre">numpy.ma.MaskedArray</span></code></a>, <a class="reference internal" href="Stoner.core.base.metadataObject.html#Stoner.core.base.metadataObject" title="Stoner.core.base.metadataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stoner.core.base.metadataObject</span></code></a></p>
<p><a class="reference internal" href="#Stoner.Image.ImageArray" title="Stoner.Image.core.ImageArray"><code class="docutils literal notranslate"><span class="pre">Stoner.Image.ImageArray</span></code></a> is a numpy array like class with a metadata parameter and pass through to skimage methods.</p>
<blockquote>
<div><p>ImageArray is for manipulating images stored as a 2d numpy array.
It is built to be almost identical to a numpy array except for one extra
parameter which is the metadata. This stores information about the image
in a dictionary object for later retrieval.
All standard numpy functions should work as normal and casting two types
together should yield a ImageArray type (ie. ImageArray+np.ndarray=ImageArray)</p>
<p>In addition any function from skimage should work and return a ImageArray.
They can be called as eg. im=im.gaussian(sigma=2). Don’t include the module
name, just the function name (ie not filters.gaussian). Also omit the first
image argument required by skimage.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>metadata (dict):</dt>
<dd>dictionary of metadata for the image</dd>
<dt>clone (self):</dt>
<dd>copy of self</dd>
<dt>max_box (tuple):</dt>
<dd>coordinate extent (xmin,xmax,ymin,ymax)</dd>
</dl>
</dd>
</dl>
<p>For clarity it should be noted that any function will not alter the current
instance, it will clone it first then return the clone after performing the
function on it.</p>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For arrays the indexing is (row, column). However the normal way to index
an image would be to do (horizontal, vert), which is the opposite.
In ImageArray the coordinate system is chosen similar to skimage. y points
down x points right and the origin is in the top left corner of the image.
When indexing the array therefore you need to give it (y,x) coordinates
for (row, column).:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="o">----&gt;</span> <span class="n">x</span> <span class="p">(</span><span class="n">column</span><span class="p">)</span>
<span class="o">|</span>
<span class="o">|</span>
<span class="n">v</span>
<span class="n">y</span> <span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>eg I want the 4th pixel in the horizontal direction and the 10th pixel down
from the top I would ask for ImageArray[10,4]</p>
<p class="last">but if I want to translate the image 4 in the x direction and 10 in the y
I would call im=im.translate((4,10))</p>
</div>
<p class="rubric">Attributes Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.CCW" title="Stoner.Image.ImageArray.CCW"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CCW</span></code></a></td>
<td>Rotate counter-clockwise by 90 deg.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.CW" title="Stoner.Image.ImageArray.CW"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CW</span></code></a></td>
<td>Rotate clockwise by 90 deg.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.T" title="Stoner.Image.ImageArray.T"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.aspect" title="Stoner.Image.ImageArray.aspect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aspect</span></code></a></td>
<td>Return the aspect ratio (width/height) of the image.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.base" title="Stoner.Image.ImageArray.base"><code class="xref py py-obj docutils literal notranslate"><span class="pre">base</span></code></a></td>
<td>Base object if memory is from some other object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.baseclass" title="Stoner.Image.ImageArray.baseclass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">baseclass</span></code></a></td>
<td>Class of the underlying data (read-only).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.centre" title="Stoner.Image.ImageArray.centre"><code class="xref py py-obj docutils literal notranslate"><span class="pre">centre</span></code></a></td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.clone" title="Stoner.Image.ImageArray.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clone</span></code></a></td>
<td>return a copy of the instance</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.ctypes" title="Stoner.Image.ImageArray.ctypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ctypes</span></code></a></td>
<td>An object to simplify the interaction of the array with the ctypes module.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.data" title="Stoner.Image.ImageArray.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></td>
<td>Return the current data, as a view of the original underlying data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.draw" title="Stoner.Image.ImageArray.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw</span></code></a></td>
<td>DrawProxy is an opbject for accessing the skimage draw sub module.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.dtype" title="Stoner.Image.ImageArray.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></td>
<td>Data-type of the array’s elements.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.fill_value" title="Stoner.Image.ImageArray.fill_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_value</span></code></a></td>
<td>Filling value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.flags" title="Stoner.Image.ImageArray.flags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flags</span></code></a></td>
<td>Information about the memory layout of the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.flat" title="Stoner.Image.ImageArray.flat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flat</span></code></a></td>
<td>MaskedArray.flat doesn’t work the same as array.flat.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.fmts" title="Stoner.Image.ImageArray.fmts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fmts</span></code></a></td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.hardmask" title="Stoner.Image.ImageArray.hardmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hardmask</span></code></a></td>
<td>Hardness of the mask</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.imag" title="Stoner.Image.ImageArray.imag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">imag</span></code></a></td>
<td>Imaginary part.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.itemsize" title="Stoner.Image.ImageArray.itemsize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemsize</span></code></a></td>
<td>Length of one array element in bytes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.mask" title="Stoner.Image.ImageArray.mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask</span></code></a></td>
<td>Mask</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.max_box" title="Stoner.Image.ImageArray.max_box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_box</span></code></a></td>
<td>return the coordinate extent (xmin,xmax,ymin,ymax)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.metadata" title="Stoner.Image.ImageArray.metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metadata</span></code></a></td>
<td>Read the metadata dictionary.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.nbytes" title="Stoner.Image.ImageArray.nbytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nbytes</span></code></a></td>
<td>Total bytes consumed by the elements of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.ndim" title="Stoner.Image.ImageArray.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></td>
<td>Number of array dimensions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.real" title="Stoner.Image.ImageArray.real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></a></td>
<td>Real part</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.recordmask" title="Stoner.Image.ImageArray.recordmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recordmask</span></code></a></td>
<td>Return the mask of the records.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.shape" title="Stoner.Image.ImageArray.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></td>
<td>Tuple of array dimensions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.sharedmask" title="Stoner.Image.ImageArray.sharedmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sharedmask</span></code></a></td>
<td>Share status of the mask (read-only).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.size" title="Stoner.Image.ImageArray.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></td>
<td>Number of elements in the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.strides" title="Stoner.Image.ImageArray.strides"><code class="xref py py-obj docutils literal notranslate"><span class="pre">strides</span></code></a></td>
<td>Tuple of bytes to step in each dimension when traversing an array.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods Summary</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.all" title="Stoner.Image.ImageArray.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if all elements evaluate to True.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.anom" title="Stoner.Image.ImageArray.anom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anom</span></code></a>([axis,&nbsp;dtype])</td>
<td>Compute the anomalies (deviations from the arithmetic mean) along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.any" title="Stoner.Image.ImageArray.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>([axis,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns True if any of the elements of <cite>a</cite> evaluate to True.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.argmax" title="Stoner.Image.ImageArray.argmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code></a>([axis,&nbsp;fill_value,&nbsp;out])</td>
<td>Returns array of indices of the maximum values along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.argmin" title="Stoner.Image.ImageArray.argmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code></a>([axis,&nbsp;fill_value,&nbsp;out])</td>
<td>Return array of indices to the minimum values along the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.argpartition" title="Stoner.Image.ImageArray.argpartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argpartition</span></code></a>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Returns the indices that would partition this array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.argsort" title="Stoner.Image.ImageArray.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>([axis,&nbsp;kind,&nbsp;order,&nbsp;endwith,&nbsp;fill_value])</td>
<td>Return an ndarray of indices that sort the array along the specified axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.asfloat" title="Stoner.Image.ImageArray.asfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asfloat</span></code></a>([normalise,&nbsp;clip,&nbsp;clip_negative])</td>
<td>Return the image converted to floating point type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.asint" title="Stoner.Image.ImageArray.asint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asint</span></code></a>([dtype])</td>
<td>convert the image to unsigned integer format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.astype" title="Stoner.Image.ImageArray.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype[,&nbsp;order,&nbsp;casting,&nbsp;subok,&nbsp;copy])</td>
<td>Copy of the array, cast to a specified type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.box" title="Stoner.Image.ImageArray.box"><code class="xref py py-obj docutils literal notranslate"><span class="pre">box</span></code></a>(*args,&nbsp;**kargs)</td>
<td>Alias for <a class="reference internal" href="#Stoner.Image.ImageArray.crop" title="Stoner.Image.ImageArray.crop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.crop()</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.byteswap" title="Stoner.Image.ImageArray.byteswap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">byteswap</span></code></a>([inplace])</td>
<td>Swap the bytes of the array elements</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.choose" title="Stoner.Image.ImageArray.choose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">choose</span></code></a>(choices[,&nbsp;out,&nbsp;mode])</td>
<td>Use an index array to construct a new array from a set of choices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.clear" title="Stoner.Image.ImageArray.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.clip" title="Stoner.Image.ImageArray.clip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code></a>([min,&nbsp;max,&nbsp;out])</td>
<td>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.clip_intensity" title="Stoner.Image.ImageArray.clip_intensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_intensity</span></code></a>([clip_negative,&nbsp;limits])</td>
<td>Clip intensity outside the range -1,1 or 0,1</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.compress" title="Stoner.Image.ImageArray.compress"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compress</span></code></a>(condition[,&nbsp;axis,&nbsp;out])</td>
<td>Return <cite>a</cite> where condition is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.compressed" title="Stoner.Image.ImageArray.compressed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compressed</span></code></a>()</td>
<td>Return all the non-masked data as a 1-D array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.conj" title="Stoner.Image.ImageArray.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a>()</td>
<td>Complex-conjugate all elements.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.conjugate" title="Stoner.Image.ImageArray.conjugate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code></a>()</td>
<td>Return the complex conjugate, element-wise.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.convert_float" title="Stoner.Image.ImageArray.convert_float"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_float</span></code></a>([clip_neg])</td>
<td>Deproicated compatability.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.convert_int" title="Stoner.Image.ImageArray.convert_int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_int</span></code></a>()</td>
<td>Depricated compatability meothd.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.copy" title="Stoner.Image.ImageArray.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([order])</td>
<td>Return a copy of the array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.count" title="Stoner.Image.ImageArray.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>([axis,&nbsp;keepdims])</td>
<td>Count the non-masked elements of the array along the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.crop" title="Stoner.Image.ImageArray.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>(*args,&nbsp;**kargs)</td>
<td>Crop the image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.crop_image" title="Stoner.Image.ImageArray.crop_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop_image</span></code></a>(*args,&nbsp;**kargs)</td>
<td>Back compatability alias for <a class="reference internal" href="#Stoner.Image.ImageArray.crop" title="Stoner.Image.ImageArray.crop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.crop()</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.cumprod" title="Stoner.Image.ImageArray.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative product of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.cumsum" title="Stoner.Image.ImageArray.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>([axis,&nbsp;dtype,&nbsp;out])</td>
<td>Return the cumulative sum of the array elements over the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.diagonal" title="Stoner.Image.ImageArray.diagonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diagonal</span></code></a>([offset,&nbsp;axis1,&nbsp;axis2])</td>
<td>Return specified diagonals.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.dot" title="Stoner.Image.ImageArray.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dot</span></code></a>(b[,&nbsp;out])</td>
<td>Masked dot product of two arrays.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.dtype_limits" title="Stoner.Image.ImageArray.dtype_limits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype_limits</span></code></a>([clip_negative])</td>
<td>Return intensity limits, i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.dump" title="Stoner.Image.ImageArray.dump"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump</span></code></a>(file)</td>
<td>Dump a pickle of the array to the specified file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.dumps" title="Stoner.Image.ImageArray.dumps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumps</span></code></a>()</td>
<td>Returns the pickle of the array as a string.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.fill" title="Stoner.Image.ImageArray.fill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill</span></code></a>(value)</td>
<td>Fill the array with a scalar value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.filled" title="Stoner.Image.ImageArray.filled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filled</span></code></a>([fill_value])</td>
<td>Return a copy of self, with masked values filled with a given value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.flatten" title="Stoner.Image.ImageArray.flatten"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flatten</span></code></a>([order])</td>
<td>Return a copy of the array collapsed into one dimension.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.get" title="Stoner.Image.ImageArray.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(k[,d])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.get_fill_value" title="Stoner.Image.ImageArray.get_fill_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fill_value</span></code></a>()</td>
<td>Return the filling value of the masked array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.get_imag" title="Stoner.Image.ImageArray.get_imag"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_imag</span></code></a>()</td>
<td>Return the imaginary part of the masked array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.get_real" title="Stoner.Image.ImageArray.get_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_real</span></code></a>()</td>
<td>Return the real part of the masked array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.getfield" title="Stoner.Image.ImageArray.getfield"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getfield</span></code></a>(dtype[,&nbsp;offset])</td>
<td>Returns a field of the given array as a certain type.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.harden_mask" title="Stoner.Image.ImageArray.harden_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">harden_mask</span></code></a>()</td>
<td>Force the mask to hard.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.ids" title="Stoner.Image.ImageArray.ids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ids</span></code></a>()</td>
<td>Return the addresses of the data and mask areas.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.iscontiguous" title="Stoner.Image.ImageArray.iscontiguous"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iscontiguous</span></code></a>()</td>
<td>Return a boolean indicating whether the data is contiguous.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.item" title="Stoner.Image.ImageArray.item"><code class="xref py py-obj docutils literal notranslate"><span class="pre">item</span></code></a>(*args)</td>
<td>Copy an element of an array to a standard Python scalar and return it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.items" title="Stoner.Image.ImageArray.items"><code class="xref py py-obj docutils literal notranslate"><span class="pre">items</span></code></a>()</td>
<td>Make sure we implement an items that doesn’t just iterate over self!</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.itemset" title="Stoner.Image.ImageArray.itemset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">itemset</span></code></a>(*args)</td>
<td>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.keys" title="Stoner.Image.ImageArray.keys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">keys</span></code></a>()</td>
<td>Return the keys of the metadata dictionary.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.max" title="Stoner.Image.ImageArray.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>([axis,&nbsp;out,&nbsp;fill_value,&nbsp;keepdims])</td>
<td>Return the maximum along a given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.mean" title="Stoner.Image.ImageArray.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Returns the average of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.min" title="Stoner.Image.ImageArray.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>([axis,&nbsp;out,&nbsp;fill_value,&nbsp;keepdims])</td>
<td>Return the minimum along a given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.mini" title="Stoner.Image.ImageArray.mini"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mini</span></code></a>([axis])</td>
<td>Return the array minimum along the specified axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.newbyteorder" title="Stoner.Image.ImageArray.newbyteorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">newbyteorder</span></code></a>([new_order])</td>
<td>Return the array with the same data viewed with a different byte order.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.nonzero" title="Stoner.Image.ImageArray.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a>()</td>
<td>Return the indices of unmasked elements that are not zero.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.partition" title="Stoner.Image.ImageArray.partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code></a>(kth[,&nbsp;axis,&nbsp;kind,&nbsp;order])</td>
<td>Rearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.pop" title="Stoner.Image.ImageArray.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>(k[,d])</td>
<td>If key is not found, d is returned if given, otherwise KeyError is raised.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.popitem" title="Stoner.Image.ImageArray.popitem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">popitem</span></code></a>()</td>
<td>as a 2-tuple; but raise KeyError if D is empty.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.prod" title="Stoner.Image.ImageArray.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the product of the array elements over the given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.product" title="Stoner.Image.ImageArray.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the product of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.ptp" title="Stoner.Image.ImageArray.ptp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptp</span></code></a>([axis,&nbsp;out,&nbsp;fill_value,&nbsp;keepdims])</td>
<td>Return (maximum - minimum) along the given dimension (i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.put" title="Stoner.Image.ImageArray.put"><code class="xref py py-obj docutils literal notranslate"><span class="pre">put</span></code></a>(indices,&nbsp;values[,&nbsp;mode])</td>
<td>Set storage-indexed locations to corresponding values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.ravel" title="Stoner.Image.ImageArray.ravel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ravel</span></code></a>([order])</td>
<td>Returns a 1D version of self, as a view.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.repeat" title="Stoner.Image.ImageArray.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(repeats[,&nbsp;axis])</td>
<td>Repeat elements of an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.reshape" title="Stoner.Image.ImageArray.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(*s,&nbsp;**kwargs)</td>
<td>Give a new shape to the array without changing its data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.resize" title="Stoner.Image.ImageArray.resize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resize</span></code></a>(newshape[,&nbsp;refcheck,&nbsp;order])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.round" title="Stoner.Image.ImageArray.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a>([decimals,&nbsp;out])</td>
<td>Return each element rounded to the given number of decimals.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.save" title="Stoner.Image.ImageArray.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>([filename])</td>
<td>Saves the image into the file ‘filename’.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.save_npy" title="Stoner.Image.ImageArray.save_npy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_npy</span></code></a>(filename)</td>
<td>Save the ImageArray as a numpy array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.save_png" title="Stoner.Image.ImageArray.save_png"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_png</span></code></a>(filename)</td>
<td>Save the ImageArray with metadata in a png file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.save_tiff" title="Stoner.Image.ImageArray.save_tiff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_tiff</span></code></a>(filename[,&nbsp;forcetype])</td>
<td>Save the ImageArray as a tiff image with metadata PIL can save in modes “L” (8bit unsigned int), “I” (32bit signed int), or “F” (32bit signed float).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.searchsorted" title="Stoner.Image.ImageArray.searchsorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code></a>(v[,&nbsp;side,&nbsp;sorter])</td>
<td>Find indices where elements of v should be inserted in a to maintain order.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.set_fill_value" title="Stoner.Image.ImageArray.set_fill_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_fill_value</span></code></a>([value])</td>
<td>Set the filling value of the masked array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.setdefault" title="Stoner.Image.ImageArray.setdefault"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setdefault</span></code></a>(k[,d])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.setfield" title="Stoner.Image.ImageArray.setfield"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setfield</span></code></a>(val,&nbsp;dtype[,&nbsp;offset])</td>
<td>Put a value into a specified place in a field defined by a data-type.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.setflags" title="Stoner.Image.ImageArray.setflags"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setflags</span></code></a>([write,&nbsp;align,&nbsp;uic])</td>
<td>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.shrink_mask" title="Stoner.Image.ImageArray.shrink_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shrink_mask</span></code></a>()</td>
<td>Reduce a mask to nomask when possible.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.soften_mask" title="Stoner.Image.ImageArray.soften_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">soften_mask</span></code></a>()</td>
<td>Force the mask to soft.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.sort" title="Stoner.Image.ImageArray.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>([axis,&nbsp;kind,&nbsp;order,&nbsp;endwith,&nbsp;fill_value])</td>
<td>Sort the array, in-place</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.squeeze" title="Stoner.Image.ImageArray.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([axis])</td>
<td>Remove single-dimensional entries from the shape of <cite>a</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.std" title="Stoner.Image.ImageArray.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Returns the standard deviation of the array elements along given axis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.sum" title="Stoner.Image.ImageArray.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;keepdims])</td>
<td>Return the sum of the array elements over the given axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.swapaxes" title="Stoner.Image.ImageArray.swapaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code></a>(axis1,&nbsp;axis2)</td>
<td>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.take" title="Stoner.Image.ImageArray.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(indices[,&nbsp;axis,&nbsp;out,&nbsp;mode])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.tobytes" title="Stoner.Image.ImageArray.tobytes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tobytes</span></code></a>([fill_value,&nbsp;order])</td>
<td>Return the array data as a string containing the raw bytes in the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.tofile" title="Stoner.Image.ImageArray.tofile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tofile</span></code></a>(fid[,&nbsp;sep,&nbsp;format])</td>
<td>Save a masked array to a file in binary format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.toflex" title="Stoner.Image.ImageArray.toflex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toflex</span></code></a>()</td>
<td>Transforms a masked array into a flexible-type array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.tolist" title="Stoner.Image.ImageArray.tolist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code></a>([fill_value])</td>
<td>Return the data portion of the masked array as a hierarchical Python list.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.torecords" title="Stoner.Image.ImageArray.torecords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">torecords</span></code></a>()</td>
<td>Transforms a masked array into a flexible-type array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.tostring" title="Stoner.Image.ImageArray.tostring"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tostring</span></code></a>([fill_value,&nbsp;order])</td>
<td>This function is a compatibility alias for tobytes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.trace" title="Stoner.Image.ImageArray.trace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trace</span></code></a>([offset,&nbsp;axis1,&nbsp;axis2,&nbsp;dtype,&nbsp;out])</td>
<td>Return the sum along diagonals of the array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.transpose" title="Stoner.Image.ImageArray.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(*axes)</td>
<td>Returns a view of the array with axes transposed.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.unshare_mask" title="Stoner.Image.ImageArray.unshare_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unshare_mask</span></code></a>()</td>
<td>Copy the mask and set the sharedmask flag to False.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.update" title="Stoner.Image.ImageArray.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>([E,&nbsp;]**F)</td>
<td>If E present and has a .keys() method, does:     for k in E: D[k] = E[k] If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.values" title="Stoner.Image.ImageArray.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a>()</td>
<td>Return the values of the metadata dictionary.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#Stoner.Image.ImageArray.var" title="Stoner.Image.ImageArray.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>([axis,&nbsp;dtype,&nbsp;out,&nbsp;ddof,&nbsp;keepdims])</td>
<td>Compute the variance along the specified axis.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#Stoner.Image.ImageArray.view" title="Stoner.Image.ImageArray.view"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code></a>([dtype,&nbsp;type])</td>
<td>New view of array with the same data.</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes Documentation</p>
<dl class="attribute">
<dt id="Stoner.Image.ImageArray.CCW">
<code class="descname">CCW</code><a class="headerlink" href="#Stoner.Image.ImageArray.CCW" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate counter-clockwise by 90 deg.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.CW">
<code class="descname">CW</code><a class="headerlink" href="#Stoner.Image.ImageArray.CW" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate clockwise by 90 deg.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.T">
<code class="descname">T</code><a class="headerlink" href="#Stoner.Image.ImageArray.T" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.aspect">
<code class="descname">aspect</code><a class="headerlink" href="#Stoner.Image.ImageArray.aspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the aspect ratio (width/height) of the image.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.base">
<code class="descname">base</code><a class="headerlink" href="#Stoner.Image.ImageArray.base" title="Permalink to this definition">¶</a></dt>
<dd><p>Base object if memory is from some other object.</p>
<p>The base of an array that owns its memory is None:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Slicing creates a view, whose memory is shared with x:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.baseclass">
<code class="descname">baseclass</code><a class="headerlink" href="#Stoner.Image.ImageArray.baseclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of the underlying data (read-only).</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.centre">
<code class="descname">centre</code><a class="headerlink" href="#Stoner.Image.ImageArray.centre" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.clone">
<code class="descname">clone</code><a class="headerlink" href="#Stoner.Image.ImageArray.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>return a copy of the instance</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.ctypes">
<code class="descname">ctypes</code><a class="headerlink" href="#Stoner.Image.ImageArray.ctypes" title="Permalink to this definition">¶</a></dt>
<dd><p>An object to simplify the interaction of the array with the ctypes
module.</p>
<p>This attribute creates an object that makes it easier to use arrays
when calling shared libraries with the ctypes module. The returned
object has, among others, data, shape, and strides attributes (see
Notes below) which themselves return ctypes objects that can be used
as arguments to a shared library.</p>
<p>None</p>
<dl class="docutils">
<dt>c <span class="classifier-delimiter">:</span> <span class="classifier">Python object</span></dt>
<dd>Possessing attributes data, shape, strides, etc.</dd>
</dl>
<p>numpy.ctypeslib</p>
<p>Below are the public attributes of this object which were documented
in “Guide to NumPy” (we have omitted undocumented public attributes,
as well as documented private attributes):</p>
<ul class="simple">
<li>data: A pointer to the memory area of the array as a Python integer.
This memory area may contain data that is not aligned, or not in correct
byte-order. The memory area may not even be writeable. The array
flags and data-type of this array should be respected when passing this
attribute to arbitrary C-code to avoid trouble that can include Python
crashing. User Beware! The value of this attribute is exactly the same
as self._array_interface_[‘data’][0].</li>
<li>shape (c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the C-integer corresponding to dtype(‘p’) on this
platform. This base-type could be c_int, c_long, or c_longlong
depending on the platform. The c_intp type is defined accordingly in
numpy.ctypeslib. The ctypes array contains the shape of the underlying
array.</li>
<li>strides (c_intp*self.ndim): A ctypes array of length self.ndim where
the basetype is the same as for the shape attribute. This ctypes array
contains the strides information from the underlying array. This strides
information is important for showing how many bytes must be jumped to
get to the next element in the array.</li>
<li>data_as(obj): Return the data pointer cast to a particular c-types object.
For example, calling self._as_parameter_ is equivalent to
self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
pointer to a ctypes array of floating-point data:
self.data_as(ctypes.POINTER(ctypes.c_double)).</li>
<li>shape_as(obj): Return the shape tuple as an array of some other c-types
type. For example: self.shape_as(ctypes.c_short).</li>
<li>strides_as(obj): Return the strides tuple as an array of some other
c-types type. For example: self.strides_as(ctypes.c_longlong).</li>
</ul>
<p>Be careful using the ctypes attribute - especially on temporary
arrays or arrays constructed on the fly. For example, calling
<code class="docutils literal notranslate"><span class="pre">(a+b).ctypes.data_as(ctypes.c_void_p)</span></code> returns a pointer to memory
that is invalid because the array created as (a+b) is deallocated
before the next Python statement. You can avoid this problem using
either <code class="docutils literal notranslate"><span class="pre">c=a+b</span></code> or <code class="docutils literal notranslate"><span class="pre">ct=(a+b).ctypes</span></code>. In the latter case, ct will
hold a reference to the array until ct is deleted or re-assigned.</p>
<p>If the ctypes module is not available, then the ctypes attribute
of array objects still returns something useful, but ctypes objects
are not returned and errors may be raised instead. In particular,
the object will still have the as parameter attribute which will
return an integer equal to the data attribute.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>
<span class="go">30439712</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x01F01300&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">))</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_longlong(4294967296L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">shape</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">shape_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_long</span><span class="p">)</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">strides</span>
<span class="go">&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">strides_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span><span class="p">)</span>
<span class="go">&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.data">
<code class="descname">data</code><a class="headerlink" href="#Stoner.Image.ImageArray.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current data, as a view of the original
underlying data.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.draw">
<code class="descname">draw</code><a class="headerlink" href="#Stoner.Image.ImageArray.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>DrawProxy is an opbject for accessing the skimage draw sub module.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#Stoner.Image.ImageArray.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Data-type of the array’s elements.</p>
<p>None</p>
<p>d : numpy dtype object</p>
<p>numpy.dtype</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;int32&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="go">&lt;type &#39;numpy.dtype&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.fill_value">
<code class="descname">fill_value</code><a class="headerlink" href="#Stoner.Image.ImageArray.fill_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Filling value.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.flags">
<code class="descname">flags</code><a class="headerlink" href="#Stoner.Image.ImageArray.flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Information about the memory layout of the array.</p>
<dl class="docutils">
<dt>C_CONTIGUOUS (C)</dt>
<dd>The data is in a single, C-style contiguous segment.</dd>
<dt>F_CONTIGUOUS (F)</dt>
<dd>The data is in a single, Fortran-style contiguous segment.</dd>
<dt>OWNDATA (O)</dt>
<dd>The array owns the memory it uses or borrows it from another object.</dd>
<dt>WRITEABLE (W)</dt>
<dd>The data area can be written to.  Setting this to False locks
the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
from its base array at creation time, but a view of a writeable
array may be subsequently locked while the base array remains writeable.
(The opposite is not true, in that a view of a locked array may not
be made writeable.  However, currently, locking a base object does not
lock any views that already reference it, so under that circumstance it
is possible to alter the contents of a locked array via a previously
created writeable view onto it.)  Attempting to change a non-writeable
array raises a RuntimeError exception.</dd>
<dt>ALIGNED (A)</dt>
<dd>The data and all elements are aligned appropriately for the hardware.</dd>
<dt>WRITEBACKIFCOPY (X)</dt>
<dd>This array is a copy of some other array. The C-API function
PyArray_ResolveWritebackIfCopy must be called before deallocating
to the base array will be updated with the contents of this array.</dd>
<dt>UPDATEIFCOPY (U)</dt>
<dd>(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.
When this array is
deallocated, the base array will be updated with the contents of
this array.</dd>
<dt>FNC</dt>
<dd>F_CONTIGUOUS and not C_CONTIGUOUS.</dd>
<dt>FORC</dt>
<dd>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</dd>
<dt>BEHAVED (B)</dt>
<dd>ALIGNED and WRITEABLE.</dd>
<dt>CARRAY (CA)</dt>
<dd>BEHAVED and C_CONTIGUOUS.</dd>
<dt>FARRAY (FA)</dt>
<dd>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</dd>
</dl>
<p>The <cite>flags</cite> object can be accessed dictionary-like (as in <code class="docutils literal notranslate"><span class="pre">a.flags['WRITEABLE']</span></code>),
or by using lowercased attribute names (as in <code class="docutils literal notranslate"><span class="pre">a.flags.writeable</span></code>). Short flag
names are only supported in dictionary access.</p>
<p>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be
changed by the user, via direct assignment to the attribute or dictionary
entry, or by calling <cite>ndarray.setflags</cite>.</p>
<p>The array flags cannot be set arbitrarily:</p>
<ul class="simple">
<li>UPDATEIFCOPY can only be set <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li>WRITEBACKIFCOPY can only be set <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li>ALIGNED can only be set <code class="docutils literal notranslate"><span class="pre">True</span></code> if the data is truly aligned.</li>
<li>WRITEABLE can only be set <code class="docutils literal notranslate"><span class="pre">True</span></code> if the array owns its own memory
or the ultimate owner of the memory exposes a writeable buffer
interface or is a string.</li>
</ul>
<p>Arrays can be both C-style and Fortran-style contiguous simultaneously.
This is clear for 1-dimensional arrays, but can also be true for higher
dimensional arrays.</p>
<p>Even for contiguous arrays a stride for a given dimension
<code class="docutils literal notranslate"><span class="pre">arr.strides[dim]</span></code> may be <em>arbitrary</em> if <code class="docutils literal notranslate"><span class="pre">arr.shape[dim]</span> <span class="pre">==</span> <span class="pre">1</span></code>
or the array has no elements.
It does <em>not</em> generally hold that <code class="docutils literal notranslate"><span class="pre">self.strides[-1]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code>
for C-style contiguous arrays or <code class="docutils literal notranslate"><span class="pre">self.strides[0]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span></code> for
Fortran-style contiguous arrays is true.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.flat">
<code class="descname">flat</code><a class="headerlink" href="#Stoner.Image.ImageArray.flat" title="Permalink to this definition">¶</a></dt>
<dd><p>MaskedArray.flat doesn’t work the same as array.flat.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.fmts">
<code class="descname">fmts</code><em class="property"> = ['png', 'npy', 'tiff', 'tif']</em><a class="headerlink" href="#Stoner.Image.ImageArray.fmts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.hardmask">
<code class="descname">hardmask</code><a class="headerlink" href="#Stoner.Image.ImageArray.hardmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Hardness of the mask</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.imag">
<code class="descname">imag</code><a class="headerlink" href="#Stoner.Image.ImageArray.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Imaginary part.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.itemsize">
<code class="descname">itemsize</code><a class="headerlink" href="#Stoner.Image.ImageArray.itemsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Length of one array element in bytes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.mask">
<code class="descname">mask</code><a class="headerlink" href="#Stoner.Image.ImageArray.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Mask</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.max_box">
<code class="descname">max_box</code><a class="headerlink" href="#Stoner.Image.ImageArray.max_box" title="Permalink to this definition">¶</a></dt>
<dd><p>return the coordinate extent (xmin,xmax,ymin,ymax)</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#Stoner.Image.ImageArray.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the metadata dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.nbytes">
<code class="descname">nbytes</code><a class="headerlink" href="#Stoner.Image.ImageArray.nbytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Total bytes consumed by the elements of the array.</p>
<p>Does not include memory consumed by non-element attributes of the
array object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nbytes</span>
<span class="go">480</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">480</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#Stoner.Image.ImageArray.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of array dimensions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.real">
<code class="descname">real</code><a class="headerlink" href="#Stoner.Image.ImageArray.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Real part</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.recordmask">
<code class="descname">recordmask</code><a class="headerlink" href="#Stoner.Image.ImageArray.recordmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mask of the records.</p>
<p>A record is masked when all the fields are masked.</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.shape">
<code class="descname">shape</code><a class="headerlink" href="#Stoner.Image.ImageArray.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of array dimensions.</p>
<p>The shape property is usually used to get the current shape of an array,
but may also be used to reshape the array in-place by assigning a tuple of
array dimensions to it.  As with <cite>numpy.reshape</cite>, one of the new shape
dimensions can be -1, in which case its value is inferred from the size of
the array and the remaining dimensions. Reshaping an array in-place will
fail if a copy is required.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">total size of new array must be unchanged</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))[::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">AttributeError</span>: <span class="n">incompatible shape for a non-contiguous array</span>
</pre></div>
</div>
<p>numpy.reshape : similar function
ndarray.reshape : similar method</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.sharedmask">
<code class="descname">sharedmask</code><a class="headerlink" href="#Stoner.Image.ImageArray.sharedmask" title="Permalink to this definition">¶</a></dt>
<dd><p>Share status of the mask (read-only).</p>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.size">
<code class="descname">size</code><a class="headerlink" href="#Stoner.Image.ImageArray.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of elements in the array.</p>
<p>Equal to <code class="docutils literal notranslate"><span class="pre">np.prod(a.shape)</span></code>, i.e., the product of the array’s
dimensions.</p>
<p><cite>a.size</cite> returns a standard arbitrary precision Python integer. This
may not be the case with other methods of obtaining the same value
(like the suggested <code class="docutils literal notranslate"><span class="pre">np.prod(a.shape)</span></code>, which returns an instance
of <code class="docutils literal notranslate"><span class="pre">np.int_</span></code>), and may be relevant if the value is used further in
calculations that may overflow a fixed size integer type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">size</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="Stoner.Image.ImageArray.strides">
<code class="descname">strides</code><a class="headerlink" href="#Stoner.Image.ImageArray.strides" title="Permalink to this definition">¶</a></dt>
<dd><p>Tuple of bytes to step in each dimension when traversing an array.</p>
<p>The byte offset of element <code class="docutils literal notranslate"><span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...,</span> <span class="pre">i[n])</span></code> in an array <cite>a</cite>
is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
</pre></div>
</div>
<p>A more detailed explanation of strides can be found in the
“ndarray.rst” file in the NumPy reference guide.</p>
<p>Imagine an array of 32-bit integers (each 4 bytes):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>This array is stored in memory as 40 bytes, one after the other
(known as a contiguous block of memory).  The strides of an array tell
us how many bytes we have to skip in memory to move to the next position
along a certain axis.  For example, we have to skip 4 bytes (1 value) to
move to the next column, but 20 bytes (5 values) to get to the same
position in the next row.  As such, the strides for the array <cite>x</cite> will be
<code class="docutils literal notranslate"><span class="pre">(20,</span> <span class="pre">4)</span></code>.</p>
<p>numpy.lib.stride_tricks.as_strided</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(48, 16, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">strides</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span><span class="o">/</span><span class="n">y</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">17</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="o">*</span><span class="mi">7</span><span class="o">*</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">strides</span>
<span class="go">(32, 4, 224, 1344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">813</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">itemsize</span>
<span class="go">813</span>
</pre></div>
</div>
</dd></dl>

<p class="rubric">Methods Documentation</p>
<dl class="method">
<dt id="Stoner.Image.ImageArray.all">
<code class="descname">all</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if all elements evaluate to True.</p>
<p>The output array is masked where all the values along the given axis
are masked: if the output would have been a scalar and that all the
values are masked, then the output is <cite>masked</cite>.</p>
<p>Refer to <cite>numpy.all</cite> for full documentation.</p>
<p>ndarray.all : corresponding function for ndarrays
numpy.all : equivalent function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.anom">
<code class="descname">anom</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.anom" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the anomalies (deviations from the arithmetic mean)
along the given axis.</p>
<p>Returns an array of anomalies, with the same shape as the input and
where the arithmetic mean is computed along the given axis.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis over which the anomalies are taken.
The default is to use the mean of the flattened array as reference.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype, optional</span></dt>
<dd><dl class="first last docutils">
<dt>Type to use in computing the variance. For arrays of integer type</dt>
<dd>the default is float32; for arrays of float types it is the same as
the array type.</dd>
</dl>
</dd>
</dl>
<p>mean : Compute the mean of the array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">anom</span><span class="p">()</span>
<span class="go">masked_array(data = [-1.  0.  1.],</span>
<span class="go">             mask = False,</span>
<span class="go">       fill_value = 1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.any">
<code class="descname">any</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if any of the elements of <cite>a</cite> evaluate to True.</p>
<p>Masked values are considered as False during computation.</p>
<p>Refer to <cite>numpy.any</cite> for full documentation.</p>
<p>ndarray.any : corresponding function for ndarrays
numpy.any : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.argmax">
<code class="descname">argmax</code><span class="sig-paren">(</span><em>axis=None</em>, <em>fill_value=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns array of indices of the maximum values along the given axis.
Masked values are treated as if they had the value fill_value.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, integer}</span></dt>
<dd>If None, the index is into the flattened array, otherwise along
the specified axis</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used to fill in the masked values.  If None, the output of
maximum_fill_value(self._data) is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">{None, array}, optional</span></dt>
<dd>Array into which the result can be placed. Its type is preserved
and it must be of the right shape to hold the output.</dd>
</dl>
<p>index_array : {integer_array}</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.argmin">
<code class="descname">argmin</code><span class="sig-paren">(</span><em>axis=None</em>, <em>fill_value=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return array of indices to the minimum values along the given axis.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, integer}</span></dt>
<dd>If None, the index is into the flattened array, otherwise along
the specified axis</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used to fill in the masked values.  If None, the output of
minimum_fill_value(self._data) is used instead.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">{None, array}, optional</span></dt>
<dd>Array into which the result can be placed. Its type is preserved
and it must be of the right shape to hold the output.</dd>
</dl>
<dl class="docutils">
<dt>ndarray or scalar</dt>
<dd>If multi-dimension input, returns a new ndarray of indices to the
minimum values along the given axis.  Otherwise, returns a scalar
of index to the minimum values along the given axis.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[-- --]</span>
<span class="go"> [2 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[1 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.argpartition">
<code class="descname">argpartition</code><span class="sig-paren">(</span><em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.argpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would partition this array.</p>
<p>Refer to <cite>numpy.argpartition</cite> for full documentation.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<p>numpy.argpartition : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>axis=&lt;no value&gt;</em>, <em>kind='quicksort'</em>, <em>order=None</em>, <em>endwith=True</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
<cite>fill_value</cite>.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first">Axis along which to sort. If None, the default, the flattened array
is used.</p>
<div class="last versionchanged">
<p><span class="versionmodified">Changed in version 1.13.0: </span>Previously, the default was documented to be -1, but that was
in error. At some future date, the default will change to -1, as
originally intended.
Until then, the axis should be given explicitly when
<code class="docutils literal notranslate"><span class="pre">arr.ndim</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, to avoid a FutureWarning.</p>
</div>
</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  Not all fields need be
specified.</dd>
<dt>endwith <span class="classifier-delimiter">:</span> <span class="classifier">{True, False}, optional</span></dt>
<dd>Whether missing values (if any) should be treated as the largest values
(True) or the smallest values (False)
When the array contains unmasked values at the same extremes of the
datatype, the ordering of these values and the masked values is
undefined.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used internally for the masked values.
If <code class="docutils literal notranslate"><span class="pre">fill_value</span></code> is not None, it supersedes <code class="docutils literal notranslate"><span class="pre">endwith</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>index_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, int</span></dt>
<dd>Array of indices that sort <cite>a</cite> along the specified axis.
In other words, <code class="docutils literal notranslate"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.</dd>
</dl>
<p>MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
ndarray.sort : Inplace sort.</p>
<p>See <cite>sort</cite> for notes on the different sorting algorithms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [3 2 --],</span>
<span class="go">             mask = [False False  True],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
<span class="go">array([1, 0, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.asfloat">
<code class="descname">asfloat</code><span class="sig-paren">(</span><em>normalise=True</em>, <em>clip=False</em>, <em>clip_negative=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.asfloat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.asfloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image converted to floating point type.</p>
<p>If currently an int type and normalise then floats will be normalised
to the maximum allowed value of the int type.
If currently a float type then no change occurs.
If clip then clip values outside the range -1,1
If clip_negative then further clip values to range 0,1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>normalise</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – normalise the image to the max value of current int type</li>
<li><strong>clip_negative</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – clip negative intensity to 0</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.asint">
<code class="descname">asint</code><span class="sig-paren">(</span><em>dtype=&lt;class 'numpy.uint16'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.asint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.asint" title="Permalink to this definition">¶</a></dt>
<dd><p>convert the image to unsigned integer format.</p>
<p>May raise warnings about loss of precision.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em>, <em>order='K'</em>, <em>casting='unsafe'</em>, <em>subok=True</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of the array, cast to a specified type.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype</span></dt>
<dd>Typecode or data-type to which the array is cast.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout order of the result.
‘C’ means C order, ‘F’ means Fortran order, ‘A’
means ‘F’ order if all the arrays are Fortran contiguous,
‘C’ order otherwise, and ‘K’ means as close to the
order the array elements appear in memory as possible.
Default is ‘K’.</dd>
<dt>casting <span class="classifier-delimiter">:</span> <span class="classifier">{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional</span></dt>
<dd><p class="first">Controls what kind of data casting may occur. Defaults to ‘unsafe’
for backwards compatibility.</p>
<blockquote class="last">
<div><ul class="simple">
<li>‘no’ means the data types should not be cast at all.</li>
<li>‘equiv’ means only byte-order changes are allowed.</li>
<li>‘safe’ means only casts which can preserve values are allowed.</li>
<li>‘same_kind’ means only safe casts or casts within a kind,
like float64 to float32, are allowed.</li>
<li>‘unsafe’ means any data conversions may be done.</li>
</ul>
</div></blockquote>
</dd>
<dt>subok <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If True, then sub-classes will be passed-through (default), otherwise
the returned array will be forced to be a base-class array.</dd>
<dt>copy <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>By default, astype always returns a newly allocated array. If this
is set to false, and the <cite>dtype</cite>, <cite>order</cite>, and <cite>subok</cite>
requirements are satisfied, the input array is returned instead
of a copy.</dd>
</dl>
<dl class="docutils">
<dt>arr_t <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Unless <cite>copy</cite> is False and the other conditions for returning the input
array are satisfied (see description for <cite>copy</cite> input parameter), <cite>arr_t</cite>
is a new array of the same shape as the input array, with dtype, order
given by <cite>dtype</cite>, <cite>order</cite>.</dd>
</dl>
<p>Starting in NumPy 1.9, astype method now returns an error if the string
dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
value of integer/float array that is being casted. Previously the casting
was allowed even if the result was truncated.</p>
<dl class="docutils">
<dt>ComplexWarning</dt>
<dd>When casting from complex to float or int. To avoid this,
one should use <code class="docutils literal notranslate"><span class="pre">a.real.astype(t)</span></code>.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1. ,  2. ,  2.5])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.box">
<code class="descname">box</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.box"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.box" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#Stoner.Image.ImageArray.crop" title="Stoner.Image.ImageArray.crop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.crop()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.byteswap">
<code class="descname">byteswap</code><span class="sig-paren">(</span><em>inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.byteswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the bytes of the array elements</p>
<p>Toggle between low-endian and big-endian data representation by
returning a byteswapped array, optionally swapped in-place.</p>
<dl class="docutils">
<dt>inplace <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, swap bytes in-place, default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>The byteswapped array. If <cite>inplace</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this is
a view to self.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">8755</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="go">[&#39;0x1&#39;, &#39;0x100&#39;, &#39;0x2233&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([  256,     1, 13090], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="go">[&#39;0x100&#39;, &#39;0x1&#39;, &#39;0x3322&#39;]</span>
</pre></div>
</div>
<p>Arrays of strings are not swapped</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;ceg&#39;</span><span class="p">,</span> <span class="s1">&#39;fac&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span>
<span class="go">array([&#39;ceg&#39;, &#39;fac&#39;],</span>
<span class="go">      dtype=&#39;|S3&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.choose">
<code class="descname">choose</code><span class="sig-paren">(</span><em>choices</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.choose" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an index array to construct a new array from a set of choices.</p>
<p>Refer to <cite>numpy.choose</cite> for full documentation.</p>
<p>numpy.choose : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None.  Remove all items from D.<a class="headerlink" href="#Stoner.Image.ImageArray.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.clip">
<code class="descname">clip</code><span class="sig-paren">(</span><em>min=None</em>, <em>max=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array whose values are limited to <code class="docutils literal notranslate"><span class="pre">[min,</span> <span class="pre">max]</span></code>.
One of max or min must be given.</p>
<p>Refer to <cite>numpy.clip</cite> for full documentation.</p>
<p>numpy.clip : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.clip_intensity">
<code class="descname">clip_intensity</code><span class="sig-paren">(</span><em>clip_negative=False</em>, <em>limits=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.clip_intensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.clip_intensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip intensity outside the range -1,1 or 0,1</p>
<dl class="docutils">
<dt>Keyword ArgumentsL</dt>
<dd><dl class="first docutils">
<dt>clip_negative(bool):</dt>
<dd>if True clip to range 0,1 else range -1,1</dd>
</dl>
<p class="last">limits (low,high): Clip the intensity between low and high rather than zero and 1.</p>
</dd>
</dl>
<p>Ensure data range is -1 to 1 or 0 to 1 if clip_negative is True.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.compress">
<code class="descname">compress</code><span class="sig-paren">(</span><em>condition</em>, <em>axis=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>a</cite> where condition is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>If condition is a <cite>MaskedArray</cite>, missing values are considered
as <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="docutils">
<dt>condition <span class="classifier-delimiter">:</span> <span class="classifier">var</span></dt>
<dd>Boolean 1-d array selecting which entries to return. If len(condition)
is less than the size of a along the axis, then output is truncated
to length of condition array.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, int}, optional</span></dt>
<dd>Axis along which the operation must be performed.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">{None, ndarray}, optional</span></dt>
<dd>Alternative output array in which to place the result. It must have
the same shape as the expected output but the type will be cast if
necessary.</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">MaskedArray</span></dt>
<dd>A <code class="xref py py-class docutils literal notranslate"><span class="pre">MaskedArray</span></code> object.</dd>
</dl>
<p>Please note the difference with <a class="reference internal" href="#Stoner.Image.ImageArray.compressed" title="Stoner.Image.ImageArray.compressed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compressed()</span></code></a> !
The output of <a class="reference internal" href="#Stoner.Image.ImageArray.compress" title="Stoner.Image.ImageArray.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compress()</span></code></a> has a mask, the output of
<a class="reference internal" href="#Stoner.Image.ImageArray.compressed" title="Stoner.Image.ImageArray.compressed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compressed()</span></code></a> does not.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">masked_array(data = [1 3],</span>
<span class="go">      mask = [False False],</span>
<span class="go">      fill_value=999999)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compress</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[1 3]</span>
<span class="go"> [-- --]</span>
<span class="go"> [7 9]],</span>
<span class="go">      mask =</span>
<span class="go"> [[False False]</span>
<span class="go"> [ True  True]</span>
<span class="go"> [False False]],</span>
<span class="go">      fill_value=999999)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.compressed">
<code class="descname">compressed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the non-masked data as a 1-D array.</p>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new <cite>ndarray</cite> holding the non-masked data is returned.</dd>
</dl>
<p>The result is <strong>not</strong> a MaskedArray!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">compressed</span><span class="p">())</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex-conjugate all elements.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate, element-wise.</p>
<p>Refer to <cite>numpy.conjugate</cite> for full documentation.</p>
<p>numpy.conjugate : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.convert_float">
<code class="descname">convert_float</code><span class="sig-paren">(</span><em>clip_neg=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.convert_float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.convert_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Deproicated compatability. <a class="reference internal" href="#Stoner.Image.ImageArray.asfloat" title="Stoner.Image.ImageArray.asfloat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.asfloat()</span></code></a> preferred</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.convert_int">
<code class="descname">convert_int</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.convert_int"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.convert_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Depricated compatability meothd. <a class="reference internal" href="#Stoner.Image.ImageArray.asint" title="Stoner.Image.ImageArray.asint"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.asint()</span></code></a> preferred</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>Controls the memory layout of the copy. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible. (Note that this function and <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.copy.html#numpy.copy" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.copy()</span></code></a> are very
similar, but have different default values for their order=
arguments.)</dd>
</dl>
<p>numpy.copy
numpy.copyto</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>axis=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the non-masked elements of the array along the given axis.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the count is performed.
The default (<cite>axis</cite> = <cite>None</cite>) performs the count over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, the count is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the array.</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or scalar</span></dt>
<dd>An array with the same shape as the input array, with the specified
axis removed. If the array is a 0-d array, or if <cite>axis</cite> is None, a
scalar is returned.</dd>
</dl>
<p>count_masked : Count masked elements in array or along a given axis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[0 1 2]</span>
<span class="go"> [-- -- --]],</span>
<span class="go">             mask =</span>
<span class="go"> [[False False False]</span>
<span class="go"> [ True  True  True]],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>When the <cite>axis</cite> keyword is specified an array of appropriate size is
returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop the image.</p>
<p>This is essentially like taking a view onto the array
but uses image x,y coords (x,y –&gt; col,row)
Returns a view according to the coords given. If box is None it will
allow the user to select a rectangle. If a tuple is given with None
included then max extent is used for that coord (analagous to slice).
If copy then return a copy of self with the cropped image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>box</strong> (<em>tuple</em>) – (xmin,xmax,ymin,ymax)
If None image will be shown and user will be asked to select
a box (bit experimental)</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – If True return a copy of ImageFile with the cropped image</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>(ImageArray)</em> –     view or copy of array asked for</td>
</tr>
</tbody>
</table>
<p class="rubric">Example</p>
<p>a=ImageFile(np.arange(12).reshape(3,4))</p>
<p>a.crop(1,3,None,None)</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.crop_image">
<code class="descname">crop_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.crop_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.crop_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Back compatability alias for <a class="reference internal" href="#Stoner.Image.ImageArray.crop" title="Stoner.Image.ImageArray.crop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ImageArray.crop()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of the array elements over the given axis.</p>
<p>Masked values are set to 1 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.</p>
<p>Refer to <cite>numpy.cumprod</cite> for full documentation.</p>
<p>The mask is lost if <cite>out</cite> is not a valid MaskedArray !</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>ndarray.cumprod : corresponding function for ndarrays
numpy.cumprod : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the array elements over the given axis.</p>
<p>Masked values are set to 0 internally during the computation.
However, their position is saved, and the result will be masked at
the same locations.</p>
<p>Refer to <cite>numpy.cumsum</cite> for full documentation.</p>
<p>The mask is lost if <cite>out</cite> is not a valid <code class="xref py py-class docutils literal notranslate"><span class="pre">MaskedArray</span></code> !</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>ndarray.cumsum : corresponding function for ndarrays
numpy.cumsum : equivalent function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">marr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">marr</span><span class="o">.</span><span class="n">cumsum</span><span class="p">())</span>
<span class="go">[0 1 3 -- -- -- 9 16 24 33]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.diagonal">
<code class="descname">diagonal</code><span class="sig-paren">(</span><em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals. In NumPy 1.9 the returned array is a
read-only view instead of a copy as in previous NumPy versions.  In
a future version the read-only restriction will be removed.</p>
<p>Refer to <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.diagonal.html#numpy.diagonal" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.diagonal()</span></code></a> for full documentation.</p>
<p>numpy.diagonal : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>b</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Masked dot product of two arrays. Note that <cite>out</cite> and <cite>strict</cite> are
located in different positions than in <cite>ma.dot</cite>. In order to
maintain compatibility with the functional version, it is
recommended that the optional arguments be treated as keyword only.
At some point that may be mandatory.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.0.</span></p>
</div>
<dl class="docutils">
<dt>b <span class="classifier-delimiter">:</span> <span class="classifier">masked_array_like</span></dt>
<dd>Inputs array.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">masked_array, optional</span></dt>
<dd>Output argument. This must have the exact kind that would be
returned if it was not used. In particular, it must have the
right type, must be C-contiguous, and its dtype must be the
dtype that would be returned for <cite>ma.dot(a,b)</cite>. This is a
performance feature. Therefore, if these conditions are not
met, an exception is raised, instead of attempting to be
flexible.</dd>
<dt>strict <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">Whether masked data are propagated (True) or set to 0 (False)
for the computation. Default is False.  Propagating the mask
means that if a masked value appears in a row or column, the
whole row or column is considered masked.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 1.10.2.</span></p>
</div>
</dd>
</dl>
<p>numpy.ma.dot : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.dtype_limits">
<code class="descname">dtype_limits</code><span class="sig-paren">(</span><em>clip_negative=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.dtype_limits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.dtype_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return intensity limits, i.e. (min, max) tuple, of the image’s dtype.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>ndarray</em>) – Input image.</li>
<li><strong>clip_negative</strong> (<em>bool</em>) – If True, clip the negative range (i.e. return 0 for min intensity)
even if the image dtype allows negative values.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>(imin, imax</em> – tuple): Lower and upper intensity limits.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>file</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump a pickle of the array to the specified file.
The array can be read back with pickle.load or numpy.load.</p>
<dl class="docutils">
<dt>file <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A string naming the dump file.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pickle of the array as a string.
pickle.loads or numpy.loads will convert the string back to an array.</p>
<p>None</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.fill">
<code class="descname">fill</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the array with a scalar value.</p>
<dl class="docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>All elements of <cite>a</cite> will be assigned this value.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.filled">
<code class="descname">filled</code><span class="sig-paren">(</span><em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.filled" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of self, with masked values filled with a given value.
<strong>However</strong>, if there are no masked values to fill, self will be
returned instead as an ndarray.</p>
<dl class="docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>The value to use for invalid entries (None by default).
If None, the <cite>fill_value</cite> attribute of the array is used instead.</dd>
</dl>
<dl class="docutils">
<dt>filled_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> with invalid entries replaced by <em>fill_value</em>
(be it the function argument or the attribute of <code class="docutils literal notranslate"><span class="pre">self</span></code>), or
<code class="docutils literal notranslate"><span class="pre">self</span></code> itself as an ndarray if there are no invalid entries to
be replaced.</dd>
</dl>
<p>The result is <strong>not</strong> a MaskedArray!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">999</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
<span class="go">array([1, 2, -999, 4, -999])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">filled</span><span class="p">())</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
</pre></div>
</div>
<p>Subclassing is preserved. This means that if, e.g., the data part of
the masked array is a recarray, <cite>filled</cite> returns a recarray:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8,i8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
<span class="go">rec.array([(999999,      2), (    -3, 999999)],</span>
<span class="go">          dtype=[(&#39;f0&#39;, &#39;&lt;i8&#39;), (&#39;f1&#39;, &#39;&lt;i8&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.flatten">
<code class="descname">flatten</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the array collapsed into one dimension.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>‘C’ means to flatten in row-major (C-style) order.
‘F’ means to flatten in column-major (Fortran-
style) order. ‘A’ means to flatten in column-major
order if <cite>a</cite> is Fortran <em>contiguous</em> in memory,
row-major order otherwise. ‘K’ means to flatten
<cite>a</cite> in the order the elements occur in memory.
The default is ‘C’.</dd>
</dl>
<dl class="docutils">
<dt>y <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A copy of the input array, flattened to one dimension.</dd>
</dl>
<p>ravel : Return a flattened array.
flat : A 1-D flat iterator over the array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="go">array([1, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 3, 2, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#Stoner.Image.ImageArray.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.get_fill_value">
<code class="descname">get_fill_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.get_fill_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the filling value of the masked array.</p>
<dl class="docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd>The filling value.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span><span class="o">.</span><span class="n">get_fill_value</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">999999</span>
<span class="go">999999</span>
<span class="go">1e+20</span>
<span class="go">(1e+20+0j)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">get_fill_value</span><span class="p">()</span>
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.get_imag">
<code class="descname">get_imag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.get_imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the masked array.</p>
<p>The returned array is a view on the imaginary part of the <cite>MaskedArray</cite>
whose <cite>get_imag</cite> method is called.</p>
<p>None</p>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">MaskedArray</span></dt>
<dd>The imaginary part of the masked array.</dd>
</dl>
<p>get_real, real, imag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mf">3.45</span><span class="o">+</span><span class="mf">1.6</span><span class="n">j</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">get_imag</span><span class="p">()</span>
<span class="go">masked_array(data = [1.0 -- 1.6],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.get_real">
<code class="descname">get_real</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.get_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the masked array.</p>
<p>The returned array is a view on the real part of the <cite>MaskedArray</cite>
whose <cite>get_real</cite> method is called.</p>
<p>None</p>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">MaskedArray</span></dt>
<dd>The real part of the masked array.</dd>
</dl>
<p>get_imag, real, imag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mf">3.45</span><span class="o">+</span><span class="mf">1.6</span><span class="n">j</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">get_real</span><span class="p">()</span>
<span class="go">masked_array(data = [1.0 -- 3.45],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 1e+20)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.getfield">
<code class="descname">getfield</code><span class="sig-paren">(</span><em>dtype</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.getfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a field of the given array as a certain type.</p>
<p>A field is a view of the array data with a given data-type. The values in
the view are determined by the given type and the offset into the current
array in bytes. The offset needs to be such that the view dtype fits in the
array dtype; for example an array of dtype complex128 has 16-byte elements.
If taking a view with a 32-bit integer (4 bytes), the offset needs to be
between 0 and 12 bytes.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">str or dtype</span></dt>
<dd>The data type of the view. The dtype size of the view can not be larger
than that of the array itself.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of bytes to skip before beginning the element view.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">4.</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.+1.j,  0.+0.j],</span>
<span class="go">       [ 0.+0.j,  2.+4.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">       [ 0.,  2.]])</span>
</pre></div>
</div>
<p>By choosing an offset of 8 bytes we can select the complex part of the
array for our view:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.],</span>
<span class="go">   [ 0.,  4.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.harden_mask">
<code class="descname">harden_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.harden_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the mask to hard.</p>
<p>Whether the mask of a masked array is hard or soft is determined by
its <cite>hardmask</cite> property. <cite>harden_mask</cite> sets <cite>hardmask</cite> to True.</p>
<p>hardmask</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.ids">
<code class="descname">ids</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the addresses of the data and mask areas.</p>
<p>None</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ids</span><span class="p">()</span>
<span class="go">(166670640, 166659832)</span>
</pre></div>
</div>
<p>If the array has no mask, the address of <cite>nomask</cite> is returned. This address
is typically not close to the data in memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">ids</span><span class="p">()</span>
<span class="go">(166691080, 3083169284L)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.iscontiguous">
<code class="descname">iscontiguous</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.iscontiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a boolean indicating whether the data is contiguous.</p>
<p>None</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">iscontiguous</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><cite>iscontiguous</cite> returns one of the flags of the masked array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : True</span>
<span class="go">  OWNDATA : False</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.item">
<code class="descname">item</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.item" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy an element of an array to a standard Python scalar and return it.</p>
<p>*args : Arguments (variable number and type)</p>
<blockquote>
<div><ul class="simple">
<li>none: in this case, the method only works for arrays
with one element (<cite>a.size == 1</cite>), which element is
copied into a standard Python scalar object and returned.</li>
<li>int_type: this argument is interpreted as a flat index into
the array, specifying which element to copy and return.</li>
<li>tuple of int_types: functions as does a single int_type argument,
except that the argument is interpreted as an nd-index into the
array.</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>z <span class="classifier-delimiter">:</span> <span class="classifier">Standard Python scalar object</span></dt>
<dd>A copy of the specified element of the array as a suitable
Python scalar</dd>
</dl>
<p>When the data type of <cite>a</cite> is longdouble or clongdouble, item() returns
a scalar array object because there is no available Python scalar that
would not lose information. Void arrays return a buffer object for item(),
unless fields are defined, in which case a tuple is returned.</p>
<p><cite>item</cite> is very similar to a[args], except, instead of an array scalar,
a standard Python scalar is returned. This can be useful for speeding up
access to elements of the array and doing arithmetic on elements of the
array using Python’s optimized math.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 8, 3],</span>
<span class="go">       [8, 5, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure we implement an items that doesn’t just iterate over self!</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.itemset">
<code class="descname">itemset</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.itemset" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</p>
<p>There must be at least 1 argument, and define the last argument
as <em>item</em>.  Then, <code class="docutils literal notranslate"><span class="pre">a.itemset(*args)</span></code> is equivalent to but faster
than <code class="docutils literal notranslate"><span class="pre">a[args]</span> <span class="pre">=</span> <span class="pre">item</span></code>.  The item should be a scalar value and <cite>args</cite>
must select a single item in the array <cite>a</cite>.</p>
<dl class="docutils">
<dt>\*args <span class="classifier-delimiter">:</span> <span class="classifier">Arguments</span></dt>
<dd>If one argument: a scalar, only used in case <cite>a</cite> is of size 1.
If two arguments: the last argument is the value to be set
and must be a scalar, the first argument specifies a single array
element location. It is either an int or a tuple.</dd>
</dl>
<p>Compared to indexing syntax, <cite>itemset</cite> provides some speed increase
for placing a scalar into a particular location in an <cite>ndarray</cite>,
if you must do this.  However, generally this is discouraged:
among other problems, it complicates the appearance of the code.
Also, when using <cite>itemset</cite> (and <cite>item</cite>) inside a loop, be sure
to assign the methods to a local variable to avoid the attribute
look-up at each loop iteration.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 8, 3],</span>
<span class="go">       [8, 5, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">itemset</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 0, 3],</span>
<span class="go">       [8, 5, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the keys of the metadata dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>fill_value=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum along a given axis.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, int}, optional</span></dt>
<dd>Axis along which to operate.  By default, <code class="docutils literal notranslate"><span class="pre">axis</span></code> is None and the
flattened input is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used to fill in the masked values.
If None, use the output of maximum_fill_value().</dd>
</dl>
<dl class="docutils">
<dt>amax <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>New array holding the result.
If <code class="docutils literal notranslate"><span class="pre">out</span></code> was specified, <code class="docutils literal notranslate"><span class="pre">out</span></code> is returned.</dd>
</dl>
<dl class="docutils">
<dt>maximum_fill_value</dt>
<dd>Returns the maximum filling value for a given datatype.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the average of the array elements along given axis.</p>
<p>Masked entries are ignored, and result elements which are not
finite will be masked.</p>
<p>Refer to <cite>numpy.mean</cite> for full documentation.</p>
<p>ndarray.mean : corresponding function for ndarrays
numpy.mean : Equivalent function
numpy.ma.average: Weighted average.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [1 2 --],</span>
<span class="go">             mask = [False False  True],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">1.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>fill_value=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum along a given axis.</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, int}, optional</span></dt>
<dd>Axis along which to operate.  By default, <code class="docutils literal notranslate"><span class="pre">axis</span></code> is None and the
flattened input is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">array_like, optional</span></dt>
<dd>Alternative output array in which to place the result.  Must be of
the same shape and buffer length as the expected output.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used to fill in the masked values.
If None, use the output of <cite>minimum_fill_value</cite>.</dd>
</dl>
<dl class="docutils">
<dt>amin <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>New array holding the result.
If <code class="docutils literal notranslate"><span class="pre">out</span></code> was specified, <code class="docutils literal notranslate"><span class="pre">out</span></code> is returned.</dd>
</dl>
<dl class="docutils">
<dt>minimum_fill_value</dt>
<dd>Returns the minimum filling value for a given datatype.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.mini">
<code class="descname">mini</code><span class="sig-paren">(</span><em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.mini" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array minimum along the specified axis.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.13.0: </span>This function is identical to both:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">self.min(keepdims=True,</span> <span class="pre">axis=axis).squeeze(axis=axis)</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">np.ma.minimum.reduce(self,</span> <span class="pre">axis=axis)</span></code></li>
</ul>
</div></blockquote>
<p>Typically though, <code class="docutils literal notranslate"><span class="pre">self.min(axis=axis)</span></code> is sufficient.</p>
</div>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The axis along which to find the minima. Default is None, in which case
the minimum value in the whole array is returned.</dd>
</dl>
<dl class="docutils">
<dt>min <span class="classifier-delimiter">:</span> <span class="classifier">scalar or MaskedArray</span></dt>
<dd>If <cite>axis</cite> is None, the result is a scalar. Otherwise, if <cite>axis</cite> is
given and the array is at least 2-D, the result is a masked array with
dimension one smaller than the array on which <cite>mini</cite> is called.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[0 --]</span>
<span class="go"> [2 3]</span>
<span class="go"> [4 --]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mini</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mini</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">masked_array(data = [0 3],</span>
<span class="go">             mask = [False False],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mini</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[0 2 4]</span>
</pre></div>
</div>
<p>There is a small difference between <cite>mini</cite> and <cite>min</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">mini</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">masked_array(data = --,</span>
<span class="go">             mask = True,</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">masked</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.newbyteorder">
<code class="descname">newbyteorder</code><span class="sig-paren">(</span><em>new_order='S'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.newbyteorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array with the same data viewed with a different byte order.</p>
<p>Equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbytorder</span><span class="p">(</span><span class="n">new_order</span><span class="p">))</span>
</pre></div>
</div>
<p>Changes are also made in all fields and sub-arrays of the array data
type.</p>
<dl class="docutils">
<dt>new_order <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first">Byte order to force; a value from the byte order specifications
below. <cite>new_order</cite> codes can be any of:</p>
<ul class="simple">
<li>‘S’ - swap dtype from current to opposite endian</li>
<li>{‘&lt;’, ‘L’} - little endian</li>
<li>{‘&gt;’, ‘B’} - big endian</li>
<li>{‘=’, ‘N’} - native order</li>
<li>{‘|’, ‘I’} - ignore (no change to byte order)</li>
</ul>
<p class="last">The default value (‘S’) results in swapping the current
byte order. The code does a case-insensitive check on the first
letter of <cite>new_order</cite> for the alternatives above.  For example,
any of ‘B’ or ‘b’ or ‘biggish’ are valid to specify big-endian.</p>
</dd>
</dl>
<dl class="docutils">
<dt>new_arr <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>New array object with the dtype reflecting given change to the
byte order.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of unmasked elements that are not zero.</p>
<p>Returns a tuple of arrays, one for each dimension, containing the
indices of the non-zero elements in that dimension. The corresponding
non-zero values can be obtained with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()]</span>
</pre></div>
</div>
<p>To group the indices by element, rather than dimension, use
instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
</pre></div>
</div>
<p>The result of this is always a 2d array, with a row for each non-zero
element.</p>
<p>None</p>
<dl class="docutils">
<dt>tuple_of_arrays <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Indices of elements that are non-zero.</dd>
</dl>
<dl class="docutils">
<dt>numpy.nonzero :</dt>
<dd>Function operating on ndarrays.</dd>
<dt>flatnonzero :</dt>
<dd>Return indices that are non-zero in the flattened version of the input
array.</dd>
<dt>ndarray.nonzero :</dt>
<dd>Equivalent ndarray method.</dd>
<dt>count_nonzero :</dt>
<dd>Counts the number of non-zero elements in the input array.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]],</span>
<span class="go">      mask =</span>
<span class="go"> False,</span>
<span class="go">      fill_value=1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([0, 1, 2]), array([0, 1, 2]))</span>
</pre></div>
</div>
<p>Masked elements are ignored.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[1.0 0.0 0.0]</span>
<span class="go"> [0.0 -- 0.0]</span>
<span class="go"> [0.0 0.0 1.0]],</span>
<span class="go">      mask =</span>
<span class="go"> [[False False False]</span>
<span class="go"> [False  True False]</span>
<span class="go"> [False False False]],</span>
<span class="go">      fill_value=1e+20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([0, 2]), array([0, 2]))</span>
</pre></div>
</div>
<p>Indices can also be grouped by element.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">masked_array(data =</span>
<span class="go"> [[False False False]</span>
<span class="go"> [ True  True  True]</span>
<span class="go"> [ True  True  True]],</span>
<span class="go">      mask =</span>
<span class="go"> False,</span>
<span class="go">      fill_value=999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ma</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> method of the condition array can also be called.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.partition">
<code class="descname">partition</code><span class="sig-paren">(</span><em>kth</em>, <em>axis=-1</em>, <em>kind='introselect'</em>, <em>order=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Rearranges the elements in the array in such a way that the value of the
element in kth position is in the position it would be in a sorted array.
All elements smaller than the kth element are moved before this element and
all equal or greater are moved behind it. The ordering of the elements in
the two partitions is undefined.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.0.</span></p>
</div>
<dl class="docutils">
<dt>kth <span class="classifier-delimiter">:</span> <span class="classifier">int or sequence of ints</span></dt>
<dd>Element index to partition by. The kth element value will be in its
final sorted position and all smaller elements will be moved before it
and all equal or greater elements behind it.
The order of all elements in the partitions is undefined.
If provided with a sequence of kth it will partition all elements
indexed by kth of them into their sorted position at once.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to sort. Default is -1, which means sort along the
last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘introselect’}, optional</span></dt>
<dd>Selection algorithm. Default is ‘introselect’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str, optional</span></dt>
<dd>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc. A single field can
be specified as a string, and not all fields need to be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</dd>
</dl>
<p>numpy.partition : Return a parititioned copy of an array.
argpartition : Indirect partition.
sort : Full sort.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">np.partition</span></code> for notes on the different algorithms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([2, 1, 3, 4])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 4])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#Stoner.Image.ImageArray.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; (k, v), remove and return some (key, value) pair<a class="headerlink" href="#Stoner.Image.ImageArray.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>as a 2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.prod">
<code class="descname">prod</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis.</p>
<p>Masked elements are set to 1 internally for computation.</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<p>Arithmetic is modular when using integer types, and no error is raised
on overflow.</p>
<p>ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of the array elements over the given axis.</p>
<p>Masked elements are set to 1 internally for computation.</p>
<p>Refer to <cite>numpy.prod</cite> for full documentation.</p>
<p>Arithmetic is modular when using integer types, and no error is raised
on overflow.</p>
<p>ndarray.prod : corresponding function for ndarrays
numpy.prod : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.ptp">
<code class="descname">ptp</code><span class="sig-paren">(</span><em>axis=None</em>, <em>out=None</em>, <em>fill_value=None</em>, <em>keepdims=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.ptp" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (maximum - minimum) along the given dimension
(i.e. peak-to-peak value).</p>
<dl class="docutils">
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">{None, int}, optional</span></dt>
<dd>Axis along which to find the peaks.  If None (default) the
flattened array is used.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">{None, array_like}, optional</span></dt>
<dd>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output
but the type will be cast if necessary.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used to fill in the masked values.</dd>
</dl>
<dl class="docutils">
<dt>ptp <span class="classifier-delimiter">:</span> <span class="classifier">ndarray.</span></dt>
<dd>A new array holding the result, unless <code class="docutils literal notranslate"><span class="pre">out</span></code> was
specified, in which case a reference to <code class="docutils literal notranslate"><span class="pre">out</span></code> is returned.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>indices</em>, <em>values</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Set storage-indexed locations to corresponding values.</p>
<p>Sets self._data.flat[n] = values[n] for each n in indices.
If <cite>values</cite> is shorter than <cite>indices</cite> then it will repeat.
If <cite>values</cite> has some masked values, the initial mask is updated
in consequence, else the corresponding values are unmasked.</p>
<dl class="docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">1-D array_like</span></dt>
<dd>Target indices, interpreted as integers.</dd>
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Values to place in self._data copy at target indices.</dd>
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">{‘raise’, ‘wrap’, ‘clip’}, optional</span></dt>
<dd>Specifies how out-of-bounds indices will behave.
‘raise’ : raise an error.
‘wrap’ : wrap around.
‘clip’ : clip to the range.</dd>
</dl>
<p><cite>values</cite> can be a scalar or length 1 array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">put</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[10 -- 3]</span>
<span class="go"> [-- 20 --]</span>
<span class="go"> [7 -- 30]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">999</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[10 -- 3]</span>
<span class="go"> [-- 999 --]</span>
<span class="go"> [7 -- 30]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.ravel">
<code class="descname">ravel</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 1D version of self, as a view.</p>
<dl class="docutils">
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’, ‘A’, ‘K’}, optional</span></dt>
<dd>The elements of <cite>a</cite> are read using this index order. ‘C’ means to
index the elements in C-like order, with the last axis index
changing fastest, back to the first axis index changing slowest.
‘F’ means to index the elements in Fortran-like index order, with
the first index changing fastest, and the last index changing
slowest. Note that the ‘C’ and ‘F’ options take no account of the
memory layout of the underlying array, and only refer to the order
of axis indexing.  ‘A’ means to read the elements in Fortran-like
index order if <cite>m</cite> is Fortran <em>contiguous</em> in memory, C-like order
otherwise.  ‘K’ means to read the elements in the order they occur
in memory, except for reversing the data when strides are negative.
By default, ‘C’ index order is used.</dd>
</dl>
<dl class="docutils">
<dt>MaskedArray</dt>
<dd>Output view is of shape <code class="docutils literal notranslate"><span class="pre">(self.size,)</span></code> (or
<code class="docutils literal notranslate"><span class="pre">(np.ma.product(self.shape),)</span></code>).</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
<span class="go">[1 -- 3 -- 5 -- 7 -- 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.repeat">
<code class="descname">repeat</code><span class="sig-paren">(</span><em>repeats</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<p>Refer to <cite>numpy.repeat</cite> for full documentation.</p>
<p>numpy.repeat : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>*s</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Give a new shape to the array without changing its data.</p>
<p>Returns a masked array containing the same data, but with a new shape.
The result is a view on the original array; if this is not possible, a
ValueError is raised.</p>
<dl class="docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd>The new shape should be compatible with the original shape. If an
integer is supplied, then the result will be a 1-D array of that
length.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’, ‘F’}, optional</span></dt>
<dd>Determines whether the array data should be viewed as in C
(row-major) or FORTRAN (column-major) order.</dd>
</dl>
<dl class="docutils">
<dt>reshaped_array <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>A new view on the array.</dd>
</dl>
<p>reshape : Equivalent function in the masked array module.
numpy.ndarray.reshape : Equivalent method on ndarray object.
numpy.reshape : Equivalent function in the NumPy module.</p>
<p>The reshaping operation cannot guarantee that a copy will not be made,
to modify the shape in place, use <code class="docutils literal notranslate"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">s</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[-- 2]</span>
<span class="go"> [3 --]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[--]</span>
<span class="go"> [2]</span>
<span class="go"> [3]</span>
<span class="go"> [--]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.resize">
<code class="descname">resize</code><span class="sig-paren">(</span><em>newshape</em>, <em>refcheck=True</em>, <em>order=False</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.resize" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method does nothing, except raise a ValueError exception. A
masked array does not own its data and therefore cannot safely be
resized in place. Use the <cite>numpy.ma.resize</cite> function instead.</p>
</div>
<p>This method is difficult to implement safely and may be deprecated in
future releases of NumPy.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.round">
<code class="descname">round</code><span class="sig-paren">(</span><em>decimals=0</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Return each element rounded to the given number of decimals.</p>
<p>Refer to <cite>numpy.around</cite> for full documentation.</p>
<p>ndarray.around : corresponding function for ndarrays
numpy.around : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>filename=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the image into the file ‘filename’.</p>
<p>Metadata will be preserved in .png and .tif format.</p>
<p>fmt can be ‘png’, ‘npy’, ‘tif’, ‘tiff’  or a list of more than one of those.
tif is recommended since metadata is lost in .npy format but data is
converted to integer format for png so that definition cannot be
saved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> (<em>string, bool or None</em>) – Filename to save data as, if this is
None then the current filename for the object is used
If this is not set, then then a file dialog is used. If
filename is False then a file dialog is forced.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li><strong>fmt</strong> (<a class="reference external" href="https://docs.python.org/3/library/string.html#module-string" title="(in Python v3.7)"><em>string</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – format to save data as. ‘tif’, ‘png’ or ‘npy’
or a list of them. If not included will guess from filename.</li>
<li><strong>forcetype</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – <p>integer data will be converted to np.float32 type
for saving. if forcetype then preserve and save as int type (will</p>
<blockquote>
<div>be unsigned).</div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Since Stoner.Image is meant to be a general 2d array often with negative
and floating point data this poses a problem for saving images. Images
are naturally saved as 8 or more bit unsigned integer values representing colour.
The only obvious way to save an image and preserve negative data
is to save as a float32 tif. This has the advantage over the npy
data type which cannot be opened by external programs and will not
save metadata.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.save_npy">
<code class="descname">save_npy</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.save_npy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.save_npy" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the ImageArray as a numpy array.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.save_png">
<code class="descname">save_png</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.save_png"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.save_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the ImageArray with metadata in a png file.
This can only save as 8bit unsigned integer so there is likely
to be a loss of precision on floating point data</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.save_tiff">
<code class="descname">save_tiff</code><span class="sig-paren">(</span><em>filename</em>, <em>forcetype=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/Stoner/Image/core.html#ImageArray.save_tiff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Stoner.Image.ImageArray.save_tiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the ImageArray as a tiff image with metadata
PIL can save in modes “L” (8bit unsigned int), “I” (32bit signed int),
or “F” (32bit signed float). In general max info is preserved for “F”
type so if forcetype is not specified then this is the default. For
boolean type data mode “L” will suffice and this is chosen in all cases.
The type name is added as a string to the metadata before saving.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Keyword Arguments:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><strong>forcetype</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – if forcetype then preserve data type as best as
possible on save.
Otherwise integer data will be converted to np.float32 type
for saving. (bool will remain as int since there’s no danger of
loss of information)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.searchsorted">
<code class="descname">searchsorted</code><span class="sig-paren">(</span><em>v</em>, <em>side='left'</em>, <em>sorter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements of v should be inserted in a to maintain order.</p>
<p>For full documentation, see <cite>numpy.searchsorted</cite></p>
<p>numpy.searchsorted : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.set_fill_value">
<code class="descname">set_fill_value</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.set_fill_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the filling value of the masked array.</p>
<dl class="docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>The new filling value. Default is None, in which case a default
based on the data type is used.</dd>
</dl>
<p>ma.set_fill_value : Equivalent function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill_value</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill_value</span>
<span class="go">3.1415926535897931</span>
</pre></div>
</div>
<p>Reset to default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">fill_value</span>
<span class="go">1e+20</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#Stoner.Image.ImageArray.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.setfield">
<code class="descname">setfield</code><span class="sig-paren">(</span><em>val</em>, <em>dtype</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.setfield" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a value into a specified place in a field defined by a data-type.</p>
<p>Place <cite>val</cite> into <cite>a</cite>’s field defined by <cite>dtype</cite> and beginning <cite>offset</cite>
bytes into the field.</p>
<dl class="docutils">
<dt>val <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd>Value to be placed in field.</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">dtype object</span></dt>
<dd>Data-type of the field in which to place <cite>val</cite>.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The number of bytes into the field at which to place <cite>val</cite>.</dd>
</dl>
<p>None</p>
<p>getfield</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">getfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">array([[3, 3, 3],</span>
<span class="go">       [3, 3, 3],</span>
<span class="go">       [3, 3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],</span>
<span class="go">       [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],</span>
<span class="go">       [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">setfield</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.setflags">
<code class="descname">setflags</code><span class="sig-paren">(</span><em>write=None</em>, <em>align=None</em>, <em>uic=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.setflags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
respectively.</p>
<p>These Boolean-valued flags affect how numpy interprets the memory
area used by <cite>a</cite> (see Notes below). The ALIGNED flag can only
be set to True if the data is actually aligned according to the type.
The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
to True. The flag WRITEABLE can only be set to True if the array owns its
own memory, or the ultimate owner of the memory exposes a writeable buffer
interface, or is a string. (The exception for string is made so that
unpickling can be done without copying memory.)</p>
<dl class="docutils">
<dt>write <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> can be written to.</dd>
<dt>align <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> is aligned properly for its type.</dd>
<dt>uic <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>Describes whether or not <cite>a</cite> is a copy of another “base” array.</dd>
</dl>
<p>Array flags provide information about how the memory area used
for the array is to be interpreted. There are 7 Boolean flags
in use, only four of which can be changed by the user:
WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</p>
<p>WRITEABLE (W) the data area can be written to;</p>
<p>ALIGNED (A) the data and strides are aligned appropriately for the hardware
(as determined by the compiler);</p>
<p>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</p>
<p>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
called, the base array will be updated with the contents of this array.</p>
<p>All flags can be accessed using the single (upper case) letter as well
as the full name.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[3, 1, 7],</span>
<span class="go">       [2, 0, 0],</span>
<span class="go">       [8, 5, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : True</span>
<span class="go">  ALIGNED : True</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">write</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">flags</span>
<span class="go">  C_CONTIGUOUS : True</span>
<span class="go">  F_CONTIGUOUS : False</span>
<span class="go">  OWNDATA : True</span>
<span class="go">  WRITEABLE : False</span>
<span class="go">  ALIGNED : False</span>
<span class="go">  WRITEBACKIFCOPY : False</span>
<span class="go">  UPDATEIFCOPY : False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">setflags</span><span class="p">(</span><span class="n">uic</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">cannot set WRITEBACKIFCOPY flag to True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.shrink_mask">
<code class="descname">shrink_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.shrink_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce a mask to nomask when possible.</p>
<p>None</p>
<p>None</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span> <span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mask</span>
<span class="go">array([[False, False],</span>
<span class="go">       [False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shrink_mask</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mask</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.soften_mask">
<code class="descname">soften_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.soften_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the mask to soft.</p>
<p>Whether the mask of a masked array is hard or soft is determined by
its <cite>hardmask</cite> property. <cite>soften_mask</cite> sets <cite>hardmask</cite> to False.</p>
<p>hardmask</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><em>axis=-1</em>, <em>kind='quicksort'</em>, <em>order=None</em>, <em>endwith=True</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the array, in-place</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array to be sorted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</dd>
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt>
<dd>Sorting algorithm. Default is ‘quicksort’.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd>When <cite>a</cite> is a structured array, this argument specifies which fields
to compare first, second, and so on.  This list does not need to
include all of the fields.</dd>
<dt>endwith <span class="classifier-delimiter">:</span> <span class="classifier">{True, False}, optional</span></dt>
<dd>Whether missing values (if any) should be treated as the largest values
(True) or the smallest values (False)
When the array contains unmasked values at the same extremes of the
datatype, the ordering of these values and the masked values is
undefined.</dd>
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">{var}, optional</span></dt>
<dd>Value used internally for the masked values.
If <code class="docutils literal notranslate"><span class="pre">fill_value</span></code> is not None, it supersedes <code class="docutils literal notranslate"><span class="pre">endwith</span></code>.</dd>
</dl>
<dl class="docutils">
<dt>sorted_array <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>Array of the same type and shape as <cite>a</cite>.</dd>
</dl>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">sort</span></code> for notes on the different sorting algorithms.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1 3 5 -- --]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Put missing values in the front</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">endwith</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[-- -- 1 3 5]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fill_value takes over endwith</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">endwith</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1 -- -- 3 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of <cite>a</cite>.</p>
<p>Refer to <cite>numpy.squeeze</cite> for full documentation.</p>
<p>numpy.squeeze : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the standard deviation of the array elements along given axis.</p>
<p>Masked entries are ignored.</p>
<p>Refer to <cite>numpy.std</cite> for full documentation.</p>
<p>ndarray.std : corresponding function for ndarrays
numpy.std : Equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of the array elements over the given axis.</p>
<p>Masked elements are set to 0 internally.</p>
<p>Refer to <cite>numpy.sum</cite> for full documentation.</p>
<p>ndarray.sum : corresponding function for ndarrays
numpy.sum : equivalent function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[4 5 16]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[8 5 12]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">&lt;type &#39;numpy.int64&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.swapaxes">
<code class="descname">swapaxes</code><span class="sig-paren">(</span><em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<p>numpy.swapaxes : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>indices</em>, <em>axis=None</em>, <em>out=None</em>, <em>mode='raise'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.take" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.tobytes">
<code class="descname">tobytes</code><span class="sig-paren">(</span><em>fill_value=None</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.tobytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the array data as a string containing the raw bytes in the array.</p>
<p>The array is filled with a fill value before the string conversion.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.0.</span></p>
</div>
<dl class="docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>Value used to fill in the masked values. Default is None, in which
case <cite>MaskedArray.fill_value</cite> is used.</dd>
<dt>order <span class="classifier-delimiter">:</span> <span class="classifier">{‘C’,’F’,’A’}, optional</span></dt>
<dd><p class="first">Order of the data item in the copy. Default is ‘C’.</p>
<ul class="last simple">
<li>‘C’   – C order (row major).</li>
<li>‘F’   – Fortran order (column major).</li>
<li>‘A’   – Any, current order of array.</li>
<li>None  – Same as ‘A’.</li>
</ul>
</dd>
</dl>
<p>ndarray.tobytes
tolist, tofile</p>
<p>As for <cite>ndarray.tobytes</cite>, information about the shape, dtype, etc.,
but also about <cite>fill_value</cite>, will be lost.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]),</span> <span class="n">mask</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;\x01\x00\x00\x00?B\x0f\x00?B\x0f\x00\x04\x00\x00\x00&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.tofile">
<code class="descname">tofile</code><span class="sig-paren">(</span><em>fid</em>, <em>sep=''</em>, <em>format='%s'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.tofile" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a masked array to a file in binary format.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function is not implemented yet.</p>
</div>
<dl class="docutils">
<dt>NotImplementedError</dt>
<dd>When <cite>tofile</cite> is called.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.toflex">
<code class="descname">toflex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.toflex" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a masked array into a flexible-type array.</p>
<p>The flexible type array that is returned will have two fields:</p>
<ul class="simple">
<li>the <code class="docutils literal notranslate"><span class="pre">_data</span></code> field stores the <code class="docutils literal notranslate"><span class="pre">_data</span></code> part of the array.</li>
<li>the <code class="docutils literal notranslate"><span class="pre">_mask</span></code> field stores the <code class="docutils literal notranslate"><span class="pre">_mask</span></code> part of the array.</li>
</ul>
<p>None</p>
<dl class="docutils">
<dt>record <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new flexible-type <cite>ndarray</cite> with two fields: the first element
containing a value, the second element containing the corresponding
mask boolean. The returned record shape matches self.shape.</dd>
</dl>
<p>A side-effect of transforming a masked array into a flexible <cite>ndarray</cite> is
that meta information (<code class="docutils literal notranslate"><span class="pre">fill_value</span></code>, …) will be lost.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">toflex</span><span class="p">())</span>
<span class="go">[[(1, False) (2, True) (3, False)]</span>
<span class="go"> [(4, True) (5, False) (6, True)]</span>
<span class="go"> [(7, False) (8, True) (9, False)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the data portion of the masked array as a hierarchical Python list.</p>
<p>Data items are converted to the nearest compatible Python type.
Masked values are converted to <cite>fill_value</cite>. If <cite>fill_value</cite> is None,
the corresponding entries in the output list will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">scalar, optional</span></dt>
<dd>The value to use for invalid entries. Default is None.</dd>
</dl>
<dl class="docutils">
<dt>result <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>The Python list representation of the masked array.</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[[1, None, 3], [None, 5, None], [7, None, 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>
<span class="go">[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.torecords">
<code class="descname">torecords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.torecords" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a masked array into a flexible-type array.</p>
<p>The flexible type array that is returned will have two fields:</p>
<ul class="simple">
<li>the <code class="docutils literal notranslate"><span class="pre">_data</span></code> field stores the <code class="docutils literal notranslate"><span class="pre">_data</span></code> part of the array.</li>
<li>the <code class="docutils literal notranslate"><span class="pre">_mask</span></code> field stores the <code class="docutils literal notranslate"><span class="pre">_mask</span></code> part of the array.</li>
</ul>
<p>None</p>
<dl class="docutils">
<dt>record <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>A new flexible-type <cite>ndarray</cite> with two fields: the first element
containing a value, the second element containing the corresponding
mask boolean. The returned record shape matches self.shape.</dd>
</dl>
<p>A side-effect of transforming a masked array into a flexible <cite>ndarray</cite> is
that meta information (<code class="docutils literal notranslate"><span class="pre">fill_value</span></code>, …) will be lost.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 -- 3]</span>
<span class="go"> [-- 5 --]</span>
<span class="go"> [7 -- 9]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">toflex</span><span class="p">())</span>
<span class="go">[[(1, False) (2, True) (3, False)]</span>
<span class="go"> [(4, True) (5, False) (6, True)]</span>
<span class="go"> [(7, False) (8, True) (9, False)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.tostring">
<code class="descname">tostring</code><span class="sig-paren">(</span><em>fill_value=None</em>, <em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.tostring" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is a compatibility alias for tobytes. Despite its name it
returns bytes not strings.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>offset=0</em>, <em>axis1=0</em>, <em>axis2=1</em>, <em>dtype=None</em>, <em>out=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>Refer to <cite>numpy.trace</cite> for full documentation.</p>
<p>numpy.trace : equivalent function</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>*axes</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array, this has no effect. (To change between column and
row vectors, first cast the 1-D array into a matrix object.)
For a 2-D array, this is the usual matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<code class="docutils literal notranslate"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></code>, then
<code class="docutils literal notranslate"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></code>.</p>
<p>axes : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>’s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>’s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a “convenience” alternative to the tuple form)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>View of <cite>a</cite>, with axes suitably permuted.</dd>
</dl>
<p>ndarray.T : Array property returning the array transposed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.unshare_mask">
<code class="descname">unshare_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.unshare_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the mask and set the sharedmask flag to False.</p>
<p>Whether the mask is shared between masked arrays can be seen from
the <cite>sharedmask</cite> property. <cite>unshare_mask</cite> ensures the mask is not shared.
A copy of the mask is only made if it was shared.</p>
<p>sharedmask</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from mapping/iterable E and F.<a class="headerlink" href="#Stoner.Image.ImageArray.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the values of the metadata dictionary.</p>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>axis=None</em>, <em>dtype=None</em>, <em>out=None</em>, <em>ddof=0</em>, <em>keepdims=&lt;no value&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl class="docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd>Array containing numbers whose variance is desired.  If <cite>a</cite> is not an
array, a conversion is attempted.</dd>
<dt>axis <span class="classifier-delimiter">:</span> <span class="classifier">None or int or tuple of ints, optional</span></dt>
<dd><p class="first">Axis or axes along which the variance is computed.  The default is to
compute the variance of the flattened array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.0.</span></p>
</div>
<p class="last">If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type, optional</span></dt>
<dd>Type to use in computing the variance.  For arrays of integer type
the default is <cite>float32</cite>; for arrays of float types it is the same as
the array type.</dd>
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd>Alternate output array in which to place the result.  It must have
the same shape as the expected output, but the type is cast if
necessary.</dd>
<dt>ddof <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>“Delta Degrees of Freedom”: the divisor used in the calculation is
<code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> represents the number of elements. By
default <cite>ddof</cite> is zero.</dd>
<dt>keepdims <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first">If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p class="last">If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>var</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="docutils">
<dt>variance <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, see dtype parameter above</span></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</dd>
</dl>
<p>std , mean, nanmean, nanstd, nanvar
numpy.doc.ufuncs : Section “Output arguments”</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.20249999932944759</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.2025</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Stoner.Image.ImageArray.view">
<code class="descname">view</code><span class="sig-paren">(</span><em>dtype=None</em>, <em>type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#Stoner.Image.ImageArray.view" title="Permalink to this definition">¶</a></dt>
<dd><p>New view of array with the same data.</p>
<dl class="docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">data-type or ndarray sub-class, optional</span></dt>
<dd>Data-type descriptor of the returned view, e.g., float32 or int16. The
default, None, results in the view having the same data-type as <cite>a</cite>.
This argument can also be specified as an ndarray sub-class, which
then specifies the type of the returned object (this is equivalent to
setting the <code class="docutils literal notranslate"><span class="pre">type</span></code> parameter).</dd>
<dt>type <span class="classifier-delimiter">:</span> <span class="classifier">Python type, optional</span></dt>
<dd>Type of the returned view, e.g., ndarray or matrix.  Again, the
default None results in type preservation.</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">a.view()</span></code> is used two different ways:</p>
<p><code class="docutils literal notranslate"><span class="pre">a.view(some_dtype)</span></code> or <code class="docutils literal notranslate"><span class="pre">a.view(dtype=some_dtype)</span></code> constructs a view
of the array’s memory with a different data-type.  This can cause a
reinterpretation of the bytes of memory.</p>
<p><code class="docutils literal notranslate"><span class="pre">a.view(ndarray_subclass)</span></code> or <code class="docutils literal notranslate"><span class="pre">a.view(type=ndarray_subclass)</span></code> just
returns an instance of <cite>ndarray_subclass</cite> that looks at the same array
(same shape, dtype, etc.)  This does not cause a reinterpretation of the
memory.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">a.view(some_dtype)</span></code>, if <code class="docutils literal notranslate"><span class="pre">some_dtype</span></code> has a different number of
bytes per entry than the previous dtype (for example, converting a
regular array to a structured array), then the behavior of the view
cannot be predicted just from the superficial appearance of <code class="docutils literal notranslate"><span class="pre">a</span></code> (shown
by <code class="docutils literal notranslate"><span class="pre">print(a)</span></code>). It also depends on exactly how <code class="docutils literal notranslate"><span class="pre">a</span></code> is stored in
memory. Therefore if <code class="docutils literal notranslate"><span class="pre">a</span></code> is C-ordered versus fortran-ordered, versus
defined as a slice or transpose, etc., the view may give different
results.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
</pre></div>
</div>
<p>Viewing array data using a different type and dtype:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">matrix([[513]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt;</span>
</pre></div>
</div>
<p>Creating a view on a structured array so it can be used in calculations</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
</pre></div>
</div>
<p>Making changes to the view changes the underlying array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[(1, 20) (3, 4)]</span>
</pre></div>
</div>
<p>Using a view to convert an array to a recarray:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">a</span>
<span class="go">array([1], dtype=int8)</span>
</pre></div>
</div>
<p>Views share data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(9, 10)</span>
</pre></div>
</div>
<p>Views that change the dtype size (bytes per entry) should normally be
avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [4, 5]], dtype=int16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">new type not compatible with array.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)])</span>
<span class="go">array([[(1, 2)],</span>
<span class="go">       [(4, 5)]], dtype=[(&#39;width&#39;, &#39;&lt;i2&#39;), (&#39;length&#39;, &#39;&lt;i2&#39;)])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/StonerLogo2.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="Stoner.folders.metadata.proxy.html"
                        title="previous chapter">proxy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Stoner.Image.ImageStack.html"
                        title="next chapter">ImageStack</a></p>
<div class="sourcelink">
  <a href="../_sources/classes/Stoner.Image.ImageArray.rst.txt" rel="nofollow">
    Show page source
  </a>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="Stoner.folders.metadata.proxy.html" title="Previous document">proxy</a>
        </li>
        <li>
          <a href="Stoner.Image.ImageStack.html" title="Next document">ImageStack</a>
          &rarr;
        </li>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../index.html">Stoner Package</a></li>
      <li>
        <a href="../Stoner.html"><code class="docutils literal notranslate"><span class="pre">Stoner</span></code> Package</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2013-15, Gavin Burnell et al.Last updated on Apr 22, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.7.9
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>