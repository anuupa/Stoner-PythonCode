<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Stoner.Analysis &mdash; Stoner Pacakge API Documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Stoner Pacakge API Documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Stoner Package</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for Stoner.Analysis</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Stoner .Analysis provides a subclass of :py:class:`Stoner.Core.DataFile` that has extra analysis routines builtin.</span>

<span class="sd">Provides  :py:class:`AnalyseFile` - DataFile with extra bells and whistles.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;AnalyseFile&quot;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">Stoner.compat</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">Stoner.Core</span> <span class="kn">import</span> <span class="n">DataFile</span>
<span class="kn">import</span> <span class="nn">Stoner.FittingFuncs</span>
<span class="kn">import</span> <span class="nn">Stoner.nlfit</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">_np_</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">cumtrapz</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getargspec</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="k">try</span><span class="p">:</span> <span class="c">#Allow lmfit to be optional</span>
    <span class="kn">from</span> <span class="nn">lmfit.model</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span><span class="n">ModelFit</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Model</span><span class="o">=</span><span class="bp">None</span>
    <span class="n">ModelFit</span><span class="o">=</span><span class="bp">None</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">cov2corr</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts a covariance matrix to a correlation matrix. Taken from bvp.utils.misc</span>

<span class="sd">    Args:</span>
<span class="sd">        M (2D _np_.array): Co-varriance Matric</span>

<span class="sd">    Returns:</span>
<span class="sd">        Correlation Matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cov2corr expects a square ndarray, got </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Found NaNs in my covariance matrix: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">M</span><span class="p">)</span>

    <span class="c"># TODO check Nan and positive diagonal</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Expected positive elements for square matrix, got diag = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">return</span> <span class="n">R</span>

<div class="viewcode-block" id="AnalyseFile"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.html#Stoner.Analysis.AnalyseFile">[docs]</a><span class="k">class</span> <span class="nc">AnalyseFile</span><span class="p">(</span><span class="n">DataFile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:py:class:`Stoner.Analysis.AnalyseFile` extends :py:class:`Stoner.Core.DataFile` with numpy and scipy passthrough functions.</span>

<span class="sd">    Note:</span>
<span class="sd">        There is no separate constructor for this class - it inherits from DataFile</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AnalyseFile.SG_Filter"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.SG_Filter.html#Stoner.Analysis.AnalyseFile.SG_Filter">[docs]</a>    <span class="k">def</span> <span class="nf">SG_Filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Implements Savitsky-Golay filtering of data for smoothing and differentiating data.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (index): Column of Data to be filtered</span>
<span class="sd">            prints (int): Number of data points to use in the filtering window. Should be an odd number &gt; poly+1 (default 15)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            poly (int): Order of polynomial to fit to the data. Must be equal or greater than order (default 1)</span>
<span class="sd">            order (int): Order of differentiation to carry out. Default=0 meaning smooth the data only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array representing the smoothed or differentiated data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If col is not specified or is None then the :py:atrt:`DataFile.setas` column assignments are used</span>
<span class="sd">            to set an x and y column. If col is a tuple, then it is assumed to secify and x-column and y-column</span>
<span class="sd">            for differentiating data. This is now a pass through to :py:func:`scipy.signal.savgol_filter`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="kn">import</span> <span class="n">ordinal</span>
        <span class="k">if</span> <span class="n">points</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Ensure window length is odd</span>
                <span class="n">points</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="n">col</span><span class="o">=</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">],</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycols&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ddata</span><span class="o">=</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">window_length</span><span class="o">=</span><span class="n">points</span><span class="p">,</span><span class="n">polyorder</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span><span class="n">deriv</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&quot;interp&quot;</span><span class="p">)</span>
            <span class="n">r</span><span class="o">=</span><span class="n">ddata</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="n">ddata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">r</span><span class="o">=</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">window_length</span><span class="o">=</span><span class="n">points</span><span class="p">,</span><span class="n">polyorder</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span><span class="n">deriv</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&quot;interp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">header</span><span class="o">=</span><span class="s">&#39;{} after {} order Savitsky-Golay Filter&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)],</span><span class="n">ordinal</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">header</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span>

</div>
    <span class="k">def</span> <span class="nf">__get_math_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility routine to interpret col as either a column index or value or an array of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (various): If col can be interpreted as a column index then return the first matching column.</span>
<span class="sd">                If col is a 1D array of the same length as the data then just return the data. If col is a</span>
<span class="sd">                float then just return it as a float.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The matching data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="n">index_types</span><span class="p">):</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">data</span><span class="o">=</span><span class="n">col</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&quot;data&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">data</span><span class="o">=</span><span class="n">col</span><span class="o">*</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Bad column index: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span><span class="n">name</span>


    <span class="k">def</span> <span class="nf">__outlier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">column</span><span class="p">,</span><span class="n">window</span><span class="p">,</span><span class="n">metric</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal function for outlier detector.</span>

<span class="sd">        Calculates if the current row is an outlier from the surrounding data by looking</span>
<span class="sd">        at the number of standard deviations away from the average of the window it is.&quot;&quot;&quot;</span>
        <span class="n">av</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span><span class="n">column</span><span class="p">])</span>
        <span class="n">std</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span><span class="n">column</span><span class="p">])</span> <span class="c">#standard deviation</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">-</span><span class="n">av</span><span class="p">)</span><span class="o">&gt;</span><span class="n">metric</span><span class="o">*</span><span class="n">std</span>

    <span class="k">def</span> <span class="nf">__poly_outlier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">column</span><span class="p">,</span><span class="n">window</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alternative outlier detection function that fits a polynomial locally over the window.</span>

<span class="sd">        Args:</span>
<span class="sd">            row (1D array): Current row of data</span>
<span class="sd">            column int): Column index of y values to examine</span>
<span class="sd">            window (2D array): Local window of data</span>
<span class="sd">            metric (float): Some measure of how sensitive the dection should be</span>

<span class="sd">        Keyyword Arguments:</span>
<span class="sd">            xcol (column index): Column of data to use for X values. Defaults to current setas value</span>
<span class="sd">            order (int): Order of polynomial to fit. Must be &lt; length of window-1</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if current row is an outlier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;order should be smaller than the window length.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>

        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span><span class="n">xcol</span><span class="p">],</span><span class="n">window</span><span class="p">[:,</span><span class="n">column</span><span class="p">],</span><span class="n">deg</span><span class="o">=</span><span class="n">order</span><span class="p">,</span><span class="n">cov</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">pval</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span><span class="n">row</span><span class="p">[</span><span class="n">xcol</span><span class="p">])</span>
        <span class="n">perr</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">-</span><span class="n">pval</span><span class="p">)</span><span class="o">&gt;</span><span class="n">metric</span><span class="o">*</span><span class="n">perr</span>


    <span class="k">def</span> <span class="nf">__mpf_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">fa</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal routine for general non-linear least squeares fitting.</span>

<span class="sd">        Args:</span>
<span class="sd">            p (list or tuple): fitting parameter values for fitting function .</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            func (callable): fitting function</span>
<span class="sd">            x (array of float): X values</span>
<span class="sd">            y(array of float): Y data values</span>
<span class="sd">            err (array of float): Weightings of data values</span>

<span class="sd">        Note:</span>
<span class="sd">            All other keywords are passed to the fitting function directly.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Difference between model values ad actual y values divided by weighting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func</span><span class="o">=</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;func&#39;</span><span class="p">]</span>
        <span class="n">x</span><span class="o">=</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">err</span><span class="o">=</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;err&#39;</span><span class="p">]</span>
        <span class="k">del</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span>
        <span class="k">del</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">])</span>
        <span class="k">del</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;func&#39;</span><span class="p">])</span>
        <span class="k">del</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;fjac&#39;</span><span class="p">])</span>
        <span class="k">del</span><span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="s">&#39;err&#39;</span><span class="p">])</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">fa</span><span class="p">)</span>
        <span class="c"># stop the calculation.</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">model</span><span class="p">)</span><span class="o">/</span><span class="n">err</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">__threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Internal function that implements the threshold method - also used in peak-finder</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (float): Threshold valuye in data to look for</span>
<span class="sd">            rising (bool): Find points where data is rising up past threshold</span>
<span class="sd">            falling (bool): Find points where data is falling below the threshold</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array of fractional indices where the data has crossed the threshold assuming a</span>
<span class="sd">            straight line interpolation between two points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current</span><span class="o">=</span><span class="n">data</span>
        <span class="n">previous</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
        <span class="n">sdat</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rising</span><span class="o">==</span><span class="bp">True</span> <span class="ow">and</span> <span class="n">falling</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="n">expr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rising</span><span class="o">==</span><span class="bp">True</span> <span class="ow">and</span> <span class="n">falling</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">expr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;</span><span class="n">threshold</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">rising</span><span class="o">==</span><span class="bp">False</span> <span class="ow">and</span> <span class="n">falling</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
            <span class="n">expr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">False</span>
        <span class="n">intr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">threshold</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">intr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sdat</span> <span class="k">if</span> <span class="n">expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">intr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>


    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handles the local attributes as well as the inherited ones&quot;&quot;&quot;</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">AnalyseFile</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__dir__</span><span class="p">())</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>


<div class="viewcode-block" id="AnalyseFile.add"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.add.html#Stoner.Analysis.AnalyseFile.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one column, number or array (b) to another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the new data object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>
        <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">=</span><span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span><span class="o">=</span><span class="n">b</span>
            <span class="n">e1data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">e2data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">adata</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span><span class="n">err_header</span><span class="o">=</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="s">&quot;{}+{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_header</span><span class="o">=</span><span class="s">&quot;Error in &quot;</span><span class="o">+</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_data</span><span class="o">=</span><span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span><span class="n">err_header</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.apply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.apply.html#Stoner.Analysis.AnalyseFile.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the given function to each row in the data set and adds to the data set.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): A function that takes a numpy 1D array representing each row of data</span>
<span class="sd">            col (index): The column in which to place the result of the function</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            replace (bool): Isnert a new data column (False) or replace the data column (True, default)</span>
<span class="sd">            header (string or None): The new column header (defaults to the name of the function func</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the current instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
           <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()[</span><span class="s">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">nc</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">()):</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">Iterable</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="n">ret</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">ret</span>
        <span class="k">if</span> <span class="n">header</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">if</span> <span class="n">replace</span><span class="o">!=</span><span class="bp">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">header</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="AnalyseFile.bin"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.bin.html#Stoner.Analysis.AnalyseFile.bin">[docs]</a>    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">bins</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&quot;log&quot;</span><span class="p">,</span><span class="n">clone</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bin x-y data into new values of x with an error bar.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Index of column of data with X values</span>
<span class="sd">            ycol (index): Index of column of data with Y values</span>
<span class="sd">            bins (int or float): Number of bins (if integer) or size of bins (if float)</span>
<span class="sd">            mode (string): &quot;log&quot; or &quot;lin&quot; for logarithmic or linear binning</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            yerr (index): Column with y-error data if present.</span>
<span class="sd">            bin_start (float): Manually override the minimum bin value</span>
<span class="sd">            bin_stop (float): Manually override the maximum bin value</span>
<span class="sd">            clone (bool): Return a clone of the current AnalyseFile with binned data (True)</span>
<span class="sd">                          or just the numbers (False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a clone of the current data set with the new binned data or</span>
<span class="sd">            tuple of (bin centres, bin values, bin errors, number points/bin),</span>
<span class="sd">            depending on the *clone* parameter.</span>

<span class="sd">        Note:</span>
<span class="sd">            Algorithm inspired by MatLab code wbin,    Copyright (c) 2012:</span>
<span class="sd">            Michael Lindholm Nielsen</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&quot;yerr&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">yerr</span><span class="o">=</span><span class="n">kargs</span><span class="p">[</span><span class="s">&quot;yerr&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yerr</span><span class="o">=</span><span class="bp">None</span>

        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s">&quot;yerr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kargs</span> <span class="ow">and</span> <span class="n">cols</span><span class="p">[</span><span class="s">&quot;has_yerr&quot;</span><span class="p">]:</span>
                <span class="n">yerr</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;yerr&quot;</span><span class="p">]</span>

        <span class="n">bin_left</span><span class="p">,</span><span class="n">bin_right</span><span class="p">,</span><span class="n">bin_centres</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">make_bins</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>

        <span class="n">ycol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">yerr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

        <span class="n">ybin</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">ebin</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">nbins</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">for</span> <span class="n">limits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bin_left</span><span class="p">,</span><span class="n">bin_right</span><span class="p">):</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">limits</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">w</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">data</span><span class="p">[:,</span><span class="n">yerr</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">W</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">e</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
                <span class="n">W</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">e</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">ycol</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="n">y</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">ycol</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">W</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ybin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">ebin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="n">e</span>
            <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">clone</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">xcol</span><span class="p">]</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ybin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">ret</span><span class="o">&amp;</span><span class="n">ybin</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;</span><span class="n">ebin</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;</span><span class="n">nbins</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
                <span class="n">s</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="p">)</span>
                <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="s">&quot;.&quot;</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="n">s</span>
                <span class="n">head</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">ycol</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">head</span><span class="p">,</span><span class="s">&quot;d{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">),</span><span class="s">&quot;#/bin {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">,</span><span class="n">ybin</span><span class="p">,</span><span class="n">ebin</span><span class="p">,</span><span class="n">nbins</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
</div>
<div class="viewcode-block" id="AnalyseFile.chi2mapping"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.chi2mapping.html#Stoner.Analysis.AnalyseFile.chi2mapping">[docs]</a>    <span class="k">def</span> <span class="nf">chi2mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Non-linear fitting using the :py:mod:`Stoner.nlfit` module.</span>

<span class="sd">        Args:</span>
<span class="sd">            ini_file (string): Path to ini file with model</span>
<span class="sd">            func_name (string or callable): Name of function to fit with (as seen in FittingFuncs.py module in Stoner)</span>
<span class="sd">                or the function itself.</span>

<span class="sd">        ReturnsL</span>
<span class="sd">            AnalyseFile instance, matplotlib.fig instance (or None if plotting disabled), DataFile instance of parameter steps&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Stoner</span><span class="o">.</span><span class="n">nlfit</span><span class="o">.</span><span class="n">nlfit</span><span class="p">(</span><span class="n">ini_file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">chi2mapping</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="AnalyseFile.clip"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.clip.html#Stoner.Analysis.AnalyseFile.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clipper</span><span class="p">,</span><span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clips the data based on the column and the clipper value.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>
<span class="sd">            clipper (tuple or array): Either a tuple of (min,max) or a numpy.ndarray -</span>
<span class="sd">                in which case the max and min values in that array will be</span>
<span class="sd">                used as the clip limits</span>
<span class="sd">        Returns:</span>
<span class="sd">            This instance.&quot;</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="n">clipper</span><span class="o">=</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">clipper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">clipper</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="n">x</span><span class="o">&lt;</span><span class="n">clipper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">clipper</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.curve_fit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.curve_fit.html#Stoner.Analysis.AnalyseFile.curve_fit">[docs]</a>    <span class="k">def</span> <span class="nf">curve_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>  <span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;General curve fitting function passed through from scipy.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): The fitting function with the form def f(x,*p) where p is a list of fitting parameters</span>
<span class="sd">            xcol (index): The index of the x-column data to fit</span>
<span class="sd">            ycol (index): The index of the y-column data to fit</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            p0 (list, tuple or array): A vector of initial parameter values to try</span>
<span class="sd">            sigma (index): The index of the column with the y-error bars</span>
<span class="sd">            bounds (callable) A callable object that evaluates true if a row is to be included. Should be of the form f(x,y)</span>
<span class="sd">            result (bool): Determines whether the fitted data should be added into the DataFile object. If result is True then</span>
<span class="sd">                the last column will be used. If result is a string or an integer then it is used as a column index.</span>
<span class="sd">                Default to None for not adding fitted data</span>
<span class="sd">            replace (bool): Inidcatesa whether the fitted data replaces existing data or is inserted as a new column (default False)</span>
<span class="sd">            header (string or None): If this is a string then it is used as the name of the fitted data. (default None)</span>
<span class="sd">            absolute_sigma (bool, defaults to True) If False, `sigma` denotes relative weights of the data points.</span>
<span class="sd">                The returned covariance matrix `pcov` is based on *estimated*</span>
<span class="sd">                errors in the data, and is not affected by the overall</span>
<span class="sd">                magnitude of the values in `sigma`. Only the relative</span>
<span class="sd">                magnitudes of the `sigma` values matter.</span>
<span class="sd">                If True, `sigma` describes one standard deviation errors of</span>
<span class="sd">                the input data points. The estimated covariance in `pcov` is</span>
<span class="sd">                based on these values.</span>
<span class="sd">            output (str, default &quot;fit&quot;): Specifiy what to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            popt (array): Optimal values of the fitting parameters p</span>
<span class="sd">            pcov (2d array): The variance-co-variance matrix for the fitting parameters.</span>
<span class="sd">            The return value is determined by the *output* parameter. Options are:</span>
<span class="sd">                * &quot;ffit&quot;    (tuple of popt,pcov)</span>
<span class="sd">                * &quot;row&quot;     just a one dimensional numpy array of the fit paraeters interleaved with their uncertainties</span>
<span class="sd">                * &quot;full&quot;    a tuple of (popt,pcov,dictionary of optional outputs, message, return code, row).</span>
<span class="sd">        Note:</span>
<span class="sd">            If the columns are not specified (or set to None) then the X and Y data are taken using the</span>
<span class="sd">            :py:attr:`DataFile.setas` attribute.</span>

<span class="sd">            The fitting function should have prototype y=f(x,p[0],p[1],p[2]...)</span>
<span class="sd">            The x-column and y-column can be anything that :py:meth:`Stoner.Core.DataFile.find_col` can use as an index</span>
<span class="sd">            but typucally either strings to be matched against column headings or integers.</span>
<span class="sd">            The initial parameter values and weightings default to None which corresponds to all parameters starting</span>
<span class="sd">            at 1 and all points equally weighted. The bounds function has format b(x, y-vec) and rewturns true if the</span>
<span class="sd">            point is to be used in the fit and false if not.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :py:meth:`Stoner.Analysis.AnalyseFile.lmfit`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bounds</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;bounds&quot;</span><span class="p">,</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;result&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;replace&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">header</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;header&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="c">#Support either scale_covar or absolute_sigma, the latter wins if both supplied</span>
        <span class="n">scale_covar</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;scale_covar&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">absolute_sigma</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;absolute_sigma&quot;</span><span class="p">,</span><span class="ow">not</span> <span class="n">scale_covar</span><span class="p">)</span>
        <span class="c">#Support both asrow and output, the latter wins if both supplied</span>
        <span class="n">asrow</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;asrow&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">output</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;output&quot;</span><span class="p">,</span><span class="s">&quot;row&quot;</span> <span class="k">if</span> <span class="n">asrow</span> <span class="k">else</span> <span class="s">&quot;fit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">==</span><span class="s">&quot;full&quot;</span><span class="p">:</span>
            <span class="n">kargs</span><span class="p">[</span><span class="s">&quot;full_output&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>

        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">,</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;yerr&quot;</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">sigma</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;yerr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>


        <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">sigma</span><span class="p">)]</span>
        <span class="n">xdat</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span>  <span class="n">xdat</span><span class="p">,</span><span class="n">ydat</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="n">absolute_sigma</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="n">popt</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pcov</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">=</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">popt</span><span class="p">)):</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&#39;Fit &#39;</span><span class="o">+</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&#39;.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])]</span><span class="o">=</span><span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">xc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">header</span><span class="o">=</span><span class="s">&#39;Fitted with &#39;</span><span class="o">+</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">xc</span><span class="p">],</span> <span class="o">*</span><span class="n">popt</span><span class="p">),</span> <span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="n">row</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">popt</span><span class="p">)):</span>
            <span class="n">row</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">,[</span><span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pcov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])])</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">ret</span><span class="o">+</span><span class="p">(</span><span class="n">row</span><span class="p">,)</span>
        <span class="n">retval</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;fit&quot;</span><span class="p">:(</span><span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="p">),</span><span class="s">&quot;row&quot;</span><span class="p">:</span><span class="n">row</span><span class="p">,</span><span class="s">&quot;full&quot;</span><span class="p">:</span><span class="n">ret</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Specified output: {}, from curve_fit not recognised&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kargs</span><span class="p">[</span><span class="s">&quot;output&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="AnalyseFile.decompose"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.decompose.html#Stoner.Analysis.AnalyseFile.decompose">[docs]</a>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">sym</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">asym</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given (x,y) data, decomposes the y part into symmetric and antisymmetric contributions in x.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (index): Index of column with x data - defaults to first x column in self.setas</span>
<span class="sd">            ycol (index or list of indices): indices of y column(s) data</span>
<span class="sd">            sym (index): Index of column to place symmetric data in default, append to end of data</span>
<span class="sd">            asym (index): Index of column for asymmetric part of ata. Defaults to appending to end of data</span>
<span class="sd">            replace (bool): Overwrite data with output (true)</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the newly modified AnalyseFile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&quot;_startx&quot;</span> <span class="ow">in</span> <span class="n">kwords</span><span class="p">:</span>
                <span class="n">startx</span><span class="o">=</span><span class="n">kwords</span><span class="p">[</span><span class="s">&quot;_startx&quot;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">kwords</span><span class="p">[</span><span class="s">&quot;_startx&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startx</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="n">startx</span><span class="o">=</span><span class="n">startx</span><span class="p">)</span>
            <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ycol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># FIXME should work with multiple output columns</span>
        <span class="n">pxdata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">:</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">xdata</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pxdata</span><span class="p">,</span><span class="n">pxdata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ydata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">ycol</span><span class="p">]</span>
        <span class="n">symd</span><span class="o">=</span><span class="p">(</span><span class="n">ydata</span><span class="o">+</span><span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">asymd</span><span class="o">=</span><span class="p">(</span><span class="n">ydata</span><span class="o">-</span><span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">&amp;=</span><span class="n">symd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="s">&quot;Symmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">symd</span><span class="p">,</span><span class="s">&quot;Symmetric Data&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">&amp;=</span><span class="n">asymd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="s">&quot;Asymmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">asymd</span><span class="p">,</span><span class="s">&quot;Symmetric Data&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">asym</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="AnalyseFile.diffsum"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.diffsum.html#Stoner.Analysis.AnalyseFile.diffsum">[docs]</a>    <span class="k">def</span> <span class="nf">diffsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract one column, number or array (b) from another column (a) and divbdatae by their sums.</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the new data object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">=</span><span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span><span class="o">=</span><span class="n">b</span>
            <span class="n">e1data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">adata</span><span class="o">-</span><span class="n">bdata</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">e1data</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">adata</span><span class="o">-</span><span class="n">bdata</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">e2data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">adata</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span><span class="n">err_header</span><span class="o">=</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="s">&quot;({}-{})/({}+{})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">,</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_header</span><span class="o">=</span><span class="s">&quot;Error in &quot;</span><span class="o">+</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_data</span><span class="o">=</span><span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span><span class="o">-</span><span class="n">bdata</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">adata</span><span class="o">+</span><span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span><span class="n">err_header</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.divide"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.divide.html#Stoner.Analysis.AnalyseFile.divide">[docs]</a>    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divide one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the new data object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">=</span><span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span><span class="o">=</span><span class="n">b</span>
            <span class="n">e1data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span><span class="o">/</span><span class="n">adata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">e2data</span><span class="o">/</span><span class="n">bdata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">adata</span><span class="o">*</span><span class="n">bdata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">adata</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span><span class="n">err_header</span><span class="o">=</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="s">&quot;{}/{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_header</span><span class="o">=</span><span class="s">&quot;Error in &quot;</span><span class="o">+</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_data</span><span class="o">=</span><span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span><span class="o">/</span><span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span><span class="n">err_header</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.integrate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.integrate.html#Stoner.Analysis.AnalyseFile.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">result_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inegrate a column of data, optionally returning the cumulative integral.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): The X data column index (or header)</span>
<span class="sd">            ycol (index) The Y data column index (or header)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            result (index or None): Either a column index (or header) to overwrite with the cumulative data,</span>
<span class="sd">                or True to add a new column or None to not store the cumulative result.</span>
<span class="sd">            result_name (string): The new column header for the results column (if specified)</span>
<span class="sd">            bounds (callable): A function that evaluates for each row to determine if the data should be integrated over.</span>
<span class="sd">            kargs: Other keyword arguements are fed direct to the scipy.integrate.cumtrapz method</span>

<span class="sd">        Returns:</span>
<span class="sd">            The final integration result</span>

<span class="sd">        Note:</span>
<span class="sd">            This is a pass through to the scipy.integrate.cumtrapz routine which just uses trapezoidal integration. A better alternative would be</span>
<span class="sd">            to offer a variety of methods including simpson&#39;s rule and interpolation of data. If xcol or ycol are not specified then</span>
<span class="sd">            the current values from the :py:attr:`Stoner.Core.DataFile.setas` attribute are used.</span>


<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xdat</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="n">final</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">yd</span><span class="o">=</span><span class="n">ydat</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">resultdata</span><span class="o">=</span><span class="n">cumtrapz</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span><span class="n">yd</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="n">resultdata</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">resultdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span><span class="n">result_name</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span><span class="n">result_name</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resultdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">final</span><span class="o">=</span><span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final</span>

</div>
<div class="viewcode-block" id="AnalyseFile.interpolate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.interpolate.html#Stoner.Analysis.AnalyseFile.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newX</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="bp">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AnalyseFile.interpolate(newX, kind=&#39;linear&quot;,xcol=None).</span>

<span class="sd">        Args:</span>
<span class="sd">            ewX (1D array): Row indices or X column values to interpolate with</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kind (string): Type of interpolation function to use - does a pass through from numpy. Default is linear.</span>
<span class="sd">            xcol (index or None): Column index or label that contains the data to use with newX to determine which rows to return. Defaults to None.peaks</span>

<span class="sd">        Returns:</span>
<span class="sd">            2D numpy array representing a section of the current object&#39;s data.</span>

<span class="sd">        Note:</span>
<span class="sd">            Returns complete rows of data corresponding to the indices given in newX. if xcol is None, then newX is interpreted as (fractional) row indices.</span>
<span class="sd">            Otherwise, the column specified in xcol is thresholded with the values given in newX and the resultant row indices used to return the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">None</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># We need to convert newX to row indices</span>
            <span class="n">xfunc</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># xfunc(x) returns partial index</span>
            <span class="n">newX</span><span class="o">=</span><span class="n">xfunc</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
        <span class="n">inter</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="AnalyseFile.lmfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.lmfit.html#Stoner.Analysis.AnalyseFile.lmfit">[docs]</a>    <span class="k">def</span> <span class="nf">lmfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">p0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper around lmfit module fitting.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (lmfit.Model): An instance of an lmfit.Model that represents the model to be fitted to the data</span>
<span class="sd">            xcol (index or None): Columns to be used for the x  data for the fitting. If not givem defaults to the :py:attr:`Stoner.Core.DataFile.setas` x column</span>
<span class="sd">            ycol (index or None): Columns to be used for the  y data for the fitting. If not givem defaults to the :py:attr:`Stoner.Core.DataFile.setas` y column</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            p0 (list, tuple or array): A vector of initial parameter values to try</span>
<span class="sd">            sigma (index): The index of the column with the y-error bars</span>
<span class="sd">            bounds (callable) A callable object that evaluates true if a row is to be included. Should be of the form f(x,y)</span>
<span class="sd">            result (bool): Determines whether the fitted data should be added into the DataFile object. If result is True then</span>
<span class="sd">                the last column will be used. If result is a string or an integer then it is used as a column index.</span>
<span class="sd">                Default to None for not adding fitted data</span>
<span class="sd">            replace (bool): Inidcatesa whether the fitted data replaces existing data or is inserted as a new column (default False)</span>
<span class="sd">            header (string or None): If this is a string then it is used as the name of the fitted data. (default None)</span>
<span class="sd">            scale_covar (bool) : whether to automatically scale covariance matrix (leastsq only)</span>
<span class="sd">            output (str, default &quot;fit&quot;): Specifiy what to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lmfit module will refurn an instance of the :py:class:`lmfit.models.ModelFit` class that contains all</span>
<span class="sd">            relevant information about the fit.</span>
<span class="sd">            The return value is determined by the *output* parameter. Options are</span>
<span class="sd">                * &quot;ffit&quot;    just the :py:class:`lmfit.model.ModelFit` instance</span>
<span class="sd">                * &quot;row&quot;     just a one dimensional numpy array of the fit paraeters interleaved with their uncertainties</span>
<span class="sd">                * &quot;full&quot;    a tuple of the fit instance and the row.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :py:meth:`AnalyseFile.curve_fit`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Model</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#Will be the case if lmfit is not imported.</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;To use the lmfit function you need to be able to import the lmfit module</span><span class="se">\n</span><span class="s"> Try pip install lmfit</span><span class="se">\n</span><span class="s">at a command prompt.&quot;</span><span class="p">)</span>

        <span class="n">bounds</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;bounds&quot;</span><span class="p">,</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;result&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;replace&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">header</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;header&quot;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="c"># Support both absolute_sigma and scale_covar, but scale_covar wins here (c.f.curve_fit)</span>
        <span class="n">absolute_sigma</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;absolute_sigma&quot;</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">scale_covar</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;scale_covar&quot;</span><span class="p">,</span><span class="ow">not</span> <span class="n">absolute_sigma</span><span class="p">)</span>
        <span class="c">#Support both asrow and output, the latter wins if both supplied</span>
        <span class="n">asrow</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;asrow&quot;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">output</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;output&quot;</span><span class="p">,</span><span class="s">&quot;row&quot;</span> <span class="k">if</span> <span class="n">asrow</span> <span class="k">else</span> <span class="s">&quot;fit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span><span class="s">&quot;:&quot;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="n">prefix</span><span class="o">=</span><span class="s">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;:&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;model parameter must be an instance of lmfit.model/Model!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">xdata</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydata</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">p0</span><span class="o">=</span><span class="p">{</span><span class="n">p</span><span class="p">:</span><span class="n">pv</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">pv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span><span class="n">p0</span><span class="p">)}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;p0 should have been a tuple, list, ndarray or dict&quot;</span><span class="p">)</span>
                <span class="n">p0</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">kargs</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">index_types</span><span class="p">):</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">sigma</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Sigma should have been a column index or list of values&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">))</span>
            <span class="n">scale_covar</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">xvar</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">independent_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p0</span><span class="p">[</span><span class="n">xvar</span><span class="p">]</span><span class="o">=</span><span class="n">xdata</span>

        <span class="n">fit</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span><span class="bp">None</span><span class="p">,</span><span class="n">scale_covar</span><span class="o">=</span><span class="n">scale_covar</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">sigma</span><span class="p">,</span><span class="o">**</span><span class="n">p0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">row</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">index_types</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">best_fit</span><span class="p">,</span><span class="n">column_header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Didn&#39;t recognize result as an index type or True&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&quot;{}{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="n">p</span><span class="p">)]</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&quot;{}{} err&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="n">p</span><span class="p">)]</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span><span class="p">])</span>
            <span class="bp">self</span><span class="p">[</span><span class="s">&quot;{}chi^2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">chisqr</span>
            <span class="bp">self</span><span class="p">[</span><span class="s">&quot;{}nfev&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">nfev</span>
            <span class="n">retval</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;fit&quot;</span><span class="p">:</span><span class="n">fit</span><span class="p">,</span><span class="s">&quot;row&quot;</span><span class="p">:</span><span class="n">row</span><span class="p">,</span><span class="s">&quot;full&quot;</span><span class="p">:(</span><span class="n">fit</span><span class="p">,</span><span class="n">row</span><span class="p">)}</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Failed to recognise output format:{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Failed to complete fit. Error was:</span><span class="se">\n</span><span class="s">{}</span><span class="se">\n</span><span class="s">{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">lmdif_message</span><span class="p">,</span><span class="n">fit</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="AnalyseFile.make_bins"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.make_bins.html#Stoner.Analysis.AnalyseFile.make_bins">[docs]</a>    <span class="k">def</span> <span class="nf">make_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">bins</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility method to generate bin boundaries and centres along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Column of data with X values</span>
<span class="sd">            bins (int or float): Number of bins (int) or width of bins (if float)</span>
<span class="sd">            mode (string): &quot;lin&quot; for linear binning, &quot;log&quot; for logarithmic binning.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bin_start (float): Override minimum bin value</span>
<span class="sd">            bin_stop (float): Override the maximum bin value</span>

<span class="sd">        Returns:</span>
<span class="sd">            bin_start,bin_stop,bin_centres (1D arrays): The locations of the bin</span>
<span class="sd">                boundaries and centres for each bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&quot;bin_start&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmin</span><span class="o">=</span><span class="n">kargs</span><span class="p">[</span><span class="s">&quot;bin_start&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s">&quot;bin_stop&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmax</span><span class="o">=</span><span class="n">kargs</span><span class="p">[</span><span class="s">&quot;bin_stop&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span> <span class="c"># Given a number of bins</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;lin&quot;</span><span class="p">:</span>
                <span class="n">bin_width</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">bins</span>
                <span class="n">bin_start</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="o">-</span><span class="n">bin_width</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">bin_width</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="p">(</span><span class="n">bin_start</span><span class="o">+</span><span class="n">bin_stop</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lowerlower</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;log&quot;</span><span class="p">:</span>
                <span class="n">xminl</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
                <span class="n">xmaxl</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_width</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">xmaxl</span><span class="o">-</span><span class="n">xminl</span><span class="p">)</span><span class="o">/</span><span class="n">bins</span>
                <span class="n">bin_start</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span><span class="p">,</span><span class="n">xmaxl</span><span class="o">-</span><span class="n">bin_width</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span><span class="o">+</span><span class="n">bin_width</span><span class="p">,</span><span class="n">xmaxl</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="p">(</span><span class="n">bin_start</span><span class="o">+</span><span class="n">bin_stop</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                <span class="n">bin_start</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span>
                <span class="n">bin_stop</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_stop</span><span class="p">)</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span> <span class="c"># Given a bin with as a flot</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;lin&quot;</span><span class="p">:</span>
                <span class="n">bin_width</span><span class="o">=</span><span class="n">bins</span>
                <span class="n">bins</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="n">bins</span><span class="p">))</span>
                <span class="n">bin_start</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="o">-</span><span class="n">bin_width</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="o">+</span><span class="n">bin_width</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="p">(</span><span class="n">bin_start</span><span class="o">+</span><span class="n">bin_stop</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s">&quot;log&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span><span class="o">&lt;</span><span class="n">bins</span><span class="o">&lt;=</span><span class="mf">1.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Bin width must be between 0 ans 1 for log binning&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xmin</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The start of the binning must be a positive value in log mode.&quot;</span><span class="p">)</span>
                <span class="n">xp</span><span class="o">=</span><span class="n">xmin</span>
                <span class="n">splits</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">centers</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">while</span> <span class="n">xp</span><span class="o">&lt;</span><span class="n">xmax</span><span class="p">:</span>
                    <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
                    <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">bins</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">xp</span><span class="o">=</span><span class="n">xp</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_start</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bin_stop</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Attempting to bin into more bins than there is data.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bin_start</span><span class="p">,</span><span class="n">bin_stop</span><span class="p">,</span><span class="n">bin_centres</span>


</div>
<div class="viewcode-block" id="AnalyseFile.max"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.max.html#Stoner.Analysis.AnalyseFile.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;FInd maximum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (maximum value,row index of max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="AnalyseFile.mean"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.mean.html#Stoner.Analysis.AnalyseFile.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;FInd mean value of a data column.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The mean of the data.</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Fix the row index when the bounds function is used - see note of \b max</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="AnalyseFile.min"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.min.html#Stoner.Analysis.AnalyseFile.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;FInd minimum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (minimum value,row index of min value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">                &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="AnalyseFile.mpfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.mpfit.html#Stoner.Analysis.AnalyseFile.mpfit">[docs]</a>    <span class="k">def</span> <span class="nf">mpfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>  <span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="p">,</span> <span class="n">p_info</span><span class="p">,</span>  <span class="n">func_args</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">mpfit_kargs</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Runs the mpfit algorithm to do a curve fitting with constrined bounds etc.</span>

<span class="sd">                mpfit(func, xcol, ycol, p_info, func_args=dict(),sigma=None,bounds=labdax,y:True,**mpfit_kargs)</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): Fitting function def func(x,parameters, **func_args)</span>
<span class="sd">            xcol, ycol (index): index the x and y data sets</span>
<span class="sd">            p_info (list of dictionaries): Defines the fitting parameters</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            sigma (index): weights of the data poiints. If not specified, then equal weighting assumed</span>
<span class="sd">            bounds (callable): function that takes x,y pairs and returns true if to be used in the fitting</span>
<span class="sd">            **mpfit_kargs: other lkeywords passed straight to mpfit</span>

<span class="sd">        Returns:</span>
<span class="sd">            Best fit parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.mpfit</span> <span class="kn">import</span> <span class="n">mpfit</span>
        <span class="k">if</span> <span class="n">sigma</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="p">[</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="p">])</span>
            <span class="n">x</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="p">[</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="p">,</span> <span class="n">sigma</span><span class="p">])</span>
            <span class="n">x</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">func_args</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
        <span class="n">func_args</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
        <span class="n">func_args</span><span class="p">[</span><span class="s">&quot;err&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">sigma</span>
        <span class="n">func_args</span><span class="p">[</span><span class="s">&quot;func&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">func</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mpfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mpf_fn</span><span class="p">,</span> <span class="n">parinfo</span><span class="o">=</span><span class="n">p_info</span><span class="p">,</span><span class="n">functkw</span><span class="o">=</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">mpfit_kargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span>

</div>
<div class="viewcode-block" id="AnalyseFile.mpfit_iterfunct"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.mpfit_iterfunct.html#Stoner.Analysis.AnalyseFile.mpfit_iterfunct">[docs]</a>    <span class="k">def</span> <span class="nf">mpfit_iterfunct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">myfunct</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">fnorm</span><span class="p">,</span> <span class="n">functkw</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">parinfo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function that is called on every iteration of the non-linerar fitting.</span>

<span class="sd">        Args:</span>
<span class="sd">            myfunct (callable): Function being modelled</span>
<span class="sd">            iteration (int): Iteration number</span>
<span class="sd">            fnorm (list): ?</span>
<span class="sd">            functkw (dictionary): Keywords being passed to the user function</span>
<span class="sd">            parinfo (list of dicts): PArameter informatuion</span>
<span class="sd">            quiet (int): 0 to suppress output</span>
<span class="sd">            dof (float): Figure of merit ?</span>

<span class="sd">        Note:</span>
<span class="sd">            This functionb just prints a full stop for every iteration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="AnalyseFile.multiply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.multiply.html#Stoner.Analysis.AnalyseFile.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the new data object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>
        <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">=</span><span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span><span class="o">=</span><span class="n">b</span>
            <span class="n">e1data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span><span class="o">/</span><span class="n">adata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">e2data</span><span class="o">/</span><span class="n">bdata</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">adata</span><span class="o">*</span><span class="n">bdata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">adata</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span><span class="n">err_header</span><span class="o">=</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="s">&quot;{}*{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_header</span><span class="o">=</span><span class="s">&quot;Error in &quot;</span><span class="o">+</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_data</span><span class="o">=</span><span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span><span class="o">*</span><span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span><span class="n">err_header</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.nlfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.nlfit.html#Stoner.Analysis.AnalyseFile.nlfit">[docs]</a>    <span class="k">def</span> <span class="nf">nlfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini_file</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Non-linear fitting using the :py:mod:`Stoner.nlfit` module.</span>

<span class="sd">        Args:</span>
<span class="sd">            ini_file (string): path to ini file with model</span>
<span class="sd">            func (string or callable):Name of function to fit with (as seen in FittingFuncs.py module in Stoner)</span>
<span class="sd">                    or function instance to fit with</span>

<span class="sd">        Returns:</span>
<span class="sd">            AnalyseFile instance, matplotlib.fig instance (or None if plotting disabled in the inifile)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Stoner</span><span class="o">.</span><span class="n">nlfit</span><span class="o">.</span><span class="n">nlfit</span><span class="p">(</span><span class="n">ini_file</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="AnalyseFile.normalise"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.normalise.html#Stoner.Analysis.AnalyseFile.normalise">[docs]</a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalise data columns by dividing through by a base column value.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (index): One or more target columns to normalise can be a string, integer or list of strings or integers.</span>
<span class="sd">            base (index): The column to normalise to, can be an integer or string</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            replace (bool): Set True(default) to overwrite  the target data columns</span>
<span class="sd">            header (string or None): The new column header - default is target name(norm)</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the current object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span><span class="o">+</span><span class="s">&quot;(norm)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">base</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="AnalyseFile.outlier_detection"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.outlier_detection.html#Stoner.Analysis.AnalyseFile.outlier_detection">[docs]</a>    <span class="k">def</span> <span class="nf">outlier_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">certainty</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&#39;mask&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to detect outliers in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column(column index), specifing column for outlier detection. If not set,</span>
<span class="sd">                defaults to the current y set column.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            window(int): data window for anomoly detection</span>
<span class="sd">            certainty(float): eg 3 detects data 3 standard deviations from average</span>
<span class="sd">            action(str or callable): what to do with outlying points, options are</span>
<span class="sd">                * &#39;mask&#39; outlier points are masked (default)</span>
<span class="sd">                * &#39;mask row&#39; outlier rows are masked</span>
<span class="sd">                * &#39;delete&#39;  outlier rows are deleted</span>
<span class="sd">                * callable  the value of the action keyword is called with the outlier row</span>
<span class="sd">                * anything else defaults to do nothing.</span>

<span class="sd">            width(odd integer): Number of rows that an outliing spike could occupy. Defaults to 1.</span>
<span class="sd">            func (callable): A function that determines if the current row is an outlier.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the current AnalysisFile</span>

<span class="sd">        outlier_detection will add row numbers of detected outliers to the metadata</span>
<span class="sd">        of d, also will perform action depending on request eg &#39;mask&#39;, &#39;delete&#39;</span>
<span class="sd">        (any other action defaults to doing nothing).</span>

<span class="sd">        The detection looks at a window of the data, takes the average and looks</span>
<span class="sd">        to see if the current data point falls certainty * std deviations away from</span>
<span class="sd">        data average.</span>

<span class="sd">        The outlier detection function has the signatrure::</span>

<span class="sd">            def outlier(row,column,window,certainity,**kargs)</span>
<span class="sd">                #code</span>
<span class="sd">                return True # or False</span>

<span class="sd">        All extra keyword arguments are passed to the outlier detector.</span>

<span class="sd">        IF *action* is a callable function then it should take the form of::</span>

<span class="sd">            def action(i,column,row):</span>
<span class="sd">                pass</span>

<span class="sd">        where *i* is the number of the outlier row, *column* the same value as above</span>
<span class="sd">        and *row* is the data for the row.</span>

<span class="sd">        In all cases the indices of the outlier rows are added to the ;outlier&#39; metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__outlier</span>

        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">column</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="n">index</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">column</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="c">#going to be easier if this is an integer later on</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="n">wrap</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">exclude_centre</span><span class="o">=</span><span class="n">width</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">column</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">certainty</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&#39;outliers&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">index</span> <span class="c">#add outlier indecies to metadata</span>
        <span class="n">index</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c">#Always reverse the index in case we&#39;re deleting rows in sucession</span>
        <span class="k">if</span> <span class="n">action</span><span class="o">==</span><span class="s">&#39;mask&#39;</span> <span class="ow">or</span> <span class="n">action</span><span class="o">==</span><span class="s">&#39;mask row&#39;</span><span class="p">:</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">action</span><span class="o">==</span><span class="s">&#39;mask&#39;</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">column</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span>
        <span class="k">elif</span> <span class="n">action</span><span class="o">==</span><span class="s">&#39;delete&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">action</span><span class="p">):</span> <span class="c"># this will call the action function with each row in turn from back to start</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">action</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">column</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.peaks"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.peaks.html#Stoner.Analysis.AnalyseFile.peaks">[docs]</a>    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">significance</span><span class="o">=</span><span class="bp">None</span> <span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">peaks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">troughs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locates peaks and/or troughs in a column of data by using SG-differentiation.</span>

<span class="sd">        Args:</span>
<span class="sd">            ycol (index): is the column name or index of the data in which to search for peaks</span>
<span class="sd">            width (float): is the expected minium halalf-width of a peak in terms of the number of data points.</span>
<span class="sd">                This is used in the differnetiation code to find local maxima. Bigger equals less sensitive</span>
<span class="sd">                to experimental noise, smaller means better eable to see sharp peaks</span>
<span class="sd">            poly (int): This is the order of polynomial to use when differentiating the data to locate a peak. Must &gt;=2, higher numbers</span>
<span class="sd">                will find sharper peaks more accurately but at the risk of finding more false positives.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            significance (float): is used to decide whether a local maxmima is a significant peak. Essentially just the curvature</span>
<span class="sd">                of the data. Bigger means less sensistive, smaller means more likely to detect noise.</span>
<span class="sd">            xcol (index or None): name or index of data column that p[rovides the x-coordinate (default None)</span>
<span class="sd">            peaks (bool): select whether to measure peaks in data (default True)</span>
<span class="sd">            troughs (bool): select whether to measure troughs in data (default False)</span>
<span class="sd">            sort (bool): Sor the results by significance of peak</span>

<span class="sd">        Returns:</span>
<span class="sd">            If xcol is None then returns conplete rows of data corresponding to the found peaks/troughs. If xcol is not none, returns a 1D array of the x positions of the peaks/troughs.</span>
<span class="sd">            &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ycol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># Set Width to be length of data/20</span>
            <span class="n">width</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">/</span><span class="mi">20</span>
        <span class="k">assert</span> <span class="n">poly</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;poly must be at least 2nd order in peaks for checking for significance of peak or trough&quot;</span>
        <span class="k">if</span> <span class="n">significance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># Guess the significance based on the range of y and width settings</span>
            <span class="n">dm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ycol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ycol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dm</span><span class="o">=</span><span class="n">dm</span><span class="o">-</span><span class="n">dp</span>
            <span class="n">significance</span><span class="o">=</span><span class="mf">0.2</span><span class="o">*</span><span class="n">dm</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d1</span><span class="p">))</span>
        <span class="n">d2</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">xcol</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">index</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">xcol</span><span class="p">)</span>
        <span class="n">w</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">xcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xcol</span><span class="p">[</span><span class="n">width</span><span class="p">])</span> <span class="c"># Approximate width of our search peak in xcol</span>
        <span class="n">z</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__threshold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">troughs</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">peaks</span><span class="p">))</span>
        <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="n">zv</span> <span class="k">for</span> <span class="n">zv</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="n">zv</span><span class="o">&gt;</span><span class="n">w</span><span class="o">/</span><span class="mf">2.0</span> <span class="ow">and</span> <span class="n">zv</span><span class="o">&lt;</span><span class="nb">max</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]</span> <span class="c">#Throw out peaks or troughts too near the ends</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">z</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">z</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">index</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">z</span> <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">&gt;</span><span class="n">significance</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="AnalyseFile.polyfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.polyfit.html#Stoner.Analysis.AnalyseFile.polyfit">[docs]</a>    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">polynomial_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="bp">True</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pass through to numpy.polyfit.</span>

<span class="sd">            Args:</span>
<span class="sd">                xcol (index): Index to the column in the data with the X data in it</span>
<span class="sd">                ycol (index): Index to the column int he data with the Y data in it</span>
<span class="sd">                polynomial_order: Order of polynomial to fit (default 2)</span>
<span class="sd">                bounds (callable): A function that evaluates True if the current row should be included in the fit</span>
<span class="sd">                result (index or None): Add the fitted data to the current data object in a new column (default don&#39;t add)</span>
<span class="sd">                replace (bool): Overwrite or insert new data if result is not None (default False)</span>
<span class="sd">                header (string or None): Name of column_header of replacement data. Default is construct a string from the y column headser and polynomial order.</span>

<span class="sd">            Returns:</span>
<span class="sd">                The best fit polynomial as a numpy.poly object.</span>

<span class="sd">            Note:</span>
<span class="sd">                If the x or y columns are not specified (or are None) the the setas attribute is used instead.</span>

<span class="sd">                This method is depricated and may be removed in a future version in favour of the more general curve_fit</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="kn">import</span> <span class="n">ordinal</span>

        <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xcol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ycol</span><span class="o">=</span><span class="n">cols</span><span class="p">[</span><span class="s">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">working</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">p</span><span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)],</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span><span class="n">polynomial_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">header</span><span class="o">=</span><span class="s">&quot;Fitted {} with {} order polynomial&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span><span class="n">ordinal</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">column_header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

</div>
<div class="viewcode-block" id="AnalyseFile.span"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.span.html#Stoner.Analysis.AnalyseFile.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of the maximum and minumum values within the given column and bounds by calling into :py:meth:`AnalyseFile.max` and :py:meth:`AnalyseFile.min`.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple of (min value, max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="AnalyseFile.split"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.split.html#Stoner.Analysis.AnalyseFile.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits the current :py:class:`AnalyseFile` object into multiple :py:class:`AnalyseFile` objects where each one contains the rows</span>
<span class="sd">        from the original object which had the same value of a given column.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): The index of the column to look for values in.</span>
<span class="sd">                This can be a list in which case a :py:class:`Stoner.Folders.DataFolder` with groups</span>
<span class="sd">                with subfiles is built up by applying each item in the xcol list recursively.</span>
<span class="sd">            func (callable):  Function that can be evaluated to find the value to determine which output object</span>
<span class="sd">                each row belongs in. If this is left as the default None then the column value is converted</span>
<span class="sd">                to a string and that is used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A :py:class:`Stoner.Folders.DataFolder` object containing the individual :py:class:`AnalyseFile` objects</span>

<span class="sd">        Note:</span>
<span class="sd">            The function to be of the form f(x,r) where x is a single float value and r is a list of floats representing</span>
<span class="sd">            the complete row. The return value should be a hashable value. func can also be a list if xcol is a list,</span>
<span class="sd">            in which the func values are used along with the @a xcol values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Folders</span> <span class="kn">import</span> <span class="n">DataFolder</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">out</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">nolist</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">files</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
        <span class="n">morecols</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">morefuncs</span><span class="o">=</span><span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">morecols</span><span class="o">=</span><span class="n">xcol</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">morefuncs</span><span class="o">=</span><span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">_np_</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">)):</span>
                <span class="n">files</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
                <span class="n">files</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">():</span>
                <span class="n">x</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">xcol</span><span class="p">]</span>
                <span class="n">key</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                    <span class="n">files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
                    <span class="n">files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">files</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">+</span><span class="n">r</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">files</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span><span class="s">&quot;{}={}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">morecols</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">files</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">morecols</span><span class="p">,</span><span class="n">morefuncs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">files</span><span class="o">=</span><span class="p">[</span><span class="n">files</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">files</span><span class="o">.</span><span class="n">keys</span><span class="p">()))]</span>
        <span class="k">return</span> <span class="n">out</span>

</div>
<div class="viewcode-block" id="AnalyseFile.stitch"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.stitch.html#Stoner.Analysis.AnalyseFile.stitch">[docs]</a>    <span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">overlap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">min_overlap</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&quot;All&quot;</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">p0</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a scaling to this data set to make it stich to another dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DataFile): Another data set that is used as the base to stitch this one on to</span>
<span class="sd">            xcol,ycol (index or None): The x and y data columns. If left as None then the current setas attribute is used.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            overlap (tuple of (lower,higher) or None): The band of x values that are used in both data sets to match, if left as None, thenthe common overlap of the x data is used.</span>
<span class="sd">            min_overlap (float): If you know that overlap must be bigger than a certain amount, the bounds between the two data sets needs to be adjusted. In this case min_overlap shifts the boundary of the overlap on this DataFile.</span>
<span class="sd">            mode (str): Unless *func* is specified, controls which parameters are actually variable, defaults to all of them.</span>
<span class="sd">            func (callable): a stitching function that transforms :math:`(x,y)\\rightarrow(x&#39;,y&#39;)`. Default is to use functions defined by *mode*()</span>
<span class="sd">            p0 (iterable): if func is not None then p0 should be the starting values for the stitching function parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the current AnalyseFile with the x and y data columns adjusted to stitch</span>

<span class="sd">        To stitch the data together, the x and y data in the current data file is transforms so that</span>
<span class="sd">        :math:`x&#39;=x+A` and :math:`y&#39;=By+C` where :math:`A,B,C` are constants and :math:`(x&#39;,y&#39;)` are close matches to the</span>
<span class="sd">        :math:`(x,y)` data in *other*. The algorithm assumes that the overlap region contains equal</span>
<span class="sd">        numbers of :math:`(x,y)` points *mode controls whether A,B, and C are fixed or adjustable</span>

<span class="sd">        * &quot;All&quot; - all three parameters adjustable</span>
<span class="sd">        * &quot;Scale y, shift x&quot; - C is fixed at 0.0</span>
<span class="sd">        * &quot;Scale and shift y&quot; A is fixed at 0.0</span>
<span class="sd">        * &quot;Scale y&quot; - only B is adjustable</span>
<span class="sd">        * &quot;Shift y&quot; - Only c is adjsutable</span>
<span class="sd">        * &quot;Shift x&quot; - Only A is adjustable</span>
<span class="sd">        * &quot;Shift both&quot; - B is fixed at 1.0</span>
<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c">#Sort out the xcolumn and y column indexes</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ycol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ycol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">min_overlap</span>
        <span class="n">otherpoints</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">otherpoints</span><span class="o">=</span><span class="n">otherpoints</span><span class="p">[</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
        <span class="n">self_second</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># Calculate the overlap</span>
            <span class="n">lower</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">upper</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">overlap</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
                <span class="n">lower</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">upper</span><span class="o">=</span><span class="n">pints</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">overlap</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">overlap</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">upper</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">float</span><span class="p">)):</span>
            <span class="n">lower</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
            <span class="n">upper</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">inrange</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">lower</span><span class="p">,</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">upper</span><span class="p">)</span>
        <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">[</span><span class="n">inrange</span><span class="p">]</span>
        <span class="n">num_pts</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        
        <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
            <span class="n">otherpoints</span><span class="o">=</span><span class="n">otherpoints</span><span class="p">[</span><span class="o">-</span><span class="n">num_pts</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">otherpoints</span><span class="o">=</span><span class="n">otherpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_pts</span><span class="p">]</span>
        <span class="n">x</span><span class="o">=</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xp</span><span class="o">=</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yp</span><span class="o">=</span><span class="n">otherpoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>        
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">opts</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;all&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">:(</span><span class="n">x</span><span class="o">+</span><span class="n">A</span><span class="p">,</span><span class="n">y</span><span class="o">*</span><span class="n">B</span><span class="o">+</span><span class="n">C</span><span class="p">)),</span>
                  <span class="s">&quot;scale y and shift x&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">:(</span><span class="n">x</span><span class="o">+</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="o">*</span><span class="n">y</span><span class="p">)),</span>
                  <span class="s">&quot;scale and shift y&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">*</span><span class="n">B</span><span class="o">+</span><span class="n">C</span><span class="p">)),</span>
                  <span class="s">&quot;scale y&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">B</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">*</span><span class="n">B</span><span class="p">)),</span>
                  <span class="s">&quot;shift y&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">C</span><span class="p">:(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">C</span><span class="p">)),</span>
                  <span class="s">&quot;shift both&quot;</span><span class="p">:(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="p">:(</span><span class="n">x</span><span class="o">+</span><span class="n">A</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="n">C</span><span class="p">))}</span>
            <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;all&quot;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                  <span class="s">&quot;scale y,shift x&quot;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
                  <span class="s">&quot;scale and shift y&quot;</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
                  <span class="s">&quot;scale y&quot;</span><span class="p">:[</span><span class="mi">2</span><span class="p">],</span>
                  <span class="s">&quot;shift y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                  <span class="s">&quot;shift both&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]}</span>
            <span class="n">A0</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span><span class="o">-</span><span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">C0</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span><span class="o">-</span><span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">B0</span><span class="o">=</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span><span class="o">-</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">yp</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">-</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">p</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="n">A0</span><span class="p">,</span><span class="n">B0</span><span class="p">,</span><span class="n">C0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span><span class="n">string_types</span><span class="p">),</span><span class="s">&quot;mode keyword should be a string if func is not defined&quot;</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">,</span><span class="s">&quot;mode keyword should be one of {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">func</span><span class="o">=</span><span class="n">opts</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="n">mode</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">),</span><span class="s">&quot;Keyword func should be callable if given&quot;</span>
            <span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">varargs</span><span class="p">,</span><span class="n">keywords</span><span class="p">,</span><span class="n">defaults</span><span class="p">)</span><span class="o">=</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">Iterable</span><span class="p">),</span><span class="s">&quot;Keyword parameter p0 shoiuld be iterable if keyword func is given&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;Keyword p0 should be the same length as the optional arguments to func&quot;</span>
        <span class="c"># This is a bit of a hack, we turn (x,y) points into a 1D array of x and then y data</span>
        <span class="n">set1</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">set2</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span><span class="n">yp</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">),</span><span class="s">&quot;The number of points in the overlap are different in the two data sets&quot;</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">):</span>
            <span class="n">m</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">x</span><span class="o">=</span><span class="n">set1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>
            <span class="n">y</span><span class="o">=</span><span class="n">set1</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span>
            <span class="n">tmp</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
            <span class="n">out</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span><span class="n">set1</span><span class="p">,</span><span class="n">set2</span><span class="p">,</span><span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span> <span class="c"># Curve fit for optimal A,B,C</span>
        <span class="n">perr</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">xcol</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">ycol</span><span class="p">]</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">xcol</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">ycol</span><span class="p">],</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&quot;Stitching Coefficients&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&quot;Stitching Coeffient Errors&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">perr</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&quot;Stitching overlap&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s">&quot;Stitching Window&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">num_pts</span>

        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="AnalyseFile.subtract"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.subtract.html#Stoner.Analysis.AnalyseFile.subtract">[docs]</a>    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract one column, number or array (b) from another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the new data object</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">e1</span><span class="p">)</span><span class="o">=</span><span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span><span class="o">=</span><span class="n">b</span>
            <span class="n">e1data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span><span class="o">=</span><span class="bp">None</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">e2data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span><span class="o">=</span><span class="bp">None</span>
        <span class="n">adata</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span><span class="n">err_header</span><span class="o">=</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="s">&quot;{}-{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_header</span><span class="o">=</span><span class="s">&quot;Error in &quot;</span><span class="o">+</span><span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_data</span><span class="o">=</span><span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">bdata</span><span class="p">,</span><span class="n">e1data</span><span class="p">,</span><span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span><span class="o">-</span><span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span><span class="n">err_header</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="AnalyseFile.threshold"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalyseFile.threshold.html#Stoner.Analysis.AnalyseFile.threshold">[docs]</a>    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">all_vals</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">transpose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds partial indices where the data in column passes the threshold, rising or falling.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (index): Column index to look for data in</span>
<span class="sd">            threshold (float): Value to look for in column col</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            rising (bool):  look for case where the data is increasing in value (defaukt True)</span>
<span class="sd">            falling (bool): look for case where data is fallinh in value (default False)</span>
<span class="sd">            xcol (index or None): rather than returning a fractional row index, return the</span>
<span class="sd">                interpolated value in column xcol</span>
<span class="sd">                all_vals (bool): return all crossing points of the threshold or just the first. (default False)</span>
<span class="sd">            transpose (bbool): Swap the x and y columns around - this is most useful when the column assignments</span>
<span class="sd">                have been done via the setas attribute</span>
<span class="sd">            all_vals (bool): Return all values that match the criteria, or just the first in the file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a sing;le fractional row index, or an in terpolated x value</span>

<span class="sd">        Note:</span>
<span class="sd">            If you don&#39;t sepcify a col value or set it to None, then the assigned columns via the</span>
<span class="sd">            :py:attr:`DataFile.setas` attribute will be used.</span>

<span class="sd">        Warning:</span>
<span class="sd">            There has been an API change. Versions prior to 0.1.9 placed the column before the threshold in the positional</span>
<span class="sd">            argument list. In order to support the use of assigned columns, this has been swapped to the present order.</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;ycol&quot;</span><span class="p">)</span>
            <span class="n">xcol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s">&quot;xcol&quot;</span><span class="p">)</span>

        <span class="n">current</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">all_vals</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__threshold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__threshold</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">all_vals</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">all_vals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/StonerLogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Stoner Package</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Gavin Burnell et al.
      Last updated on Apr 07, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>