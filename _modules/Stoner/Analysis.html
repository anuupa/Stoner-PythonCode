
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Stoner.Analysis &#8212; Stoner Pacakge API Documentation</title>
    <link rel="stylesheet" href="../../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../../index.html ">
        Stoner Pacakge API Documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Stoner Package</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li>
      <li>
        <a href="../Stoner.html">Stoner</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Stoner.Analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Stoner .Analysis provides a subclass of :class:`.Data` that has extra analysis routines builtin.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AnalysisMixin&quot;</span><span class="p">,</span><span class="s2">&quot;GetAffineTransform&quot;</span><span class="p">,</span><span class="s2">&quot;ApplyAffineTransform&quot;</span><span class="p">]</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isclass</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np_</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">_sp_</span>
<span class="kn">from</span> <span class="nn">scipy.odr</span> <span class="k">import</span> <span class="n">Model</span> <span class="k">as</span> <span class="n">odrModel</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">cumtrapz</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">curve_fit</span><span class="p">,</span><span class="n">newton</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">savgol_filter</span>

<span class="kn">from</span> <span class="nn">.compat</span> <span class="k">import</span> <span class="n">python_v3</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">int_types</span><span class="p">,</span> <span class="n">index_types</span><span class="p">,</span> <span class="n">LooseVersion</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="k">import</span> <span class="n">isNone</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">all_type</span><span class="p">,</span> <span class="n">istuple</span><span class="p">,</span><span class="n">islike_list</span>

<span class="k">try</span><span class="p">:</span>  <span class="c1">#Allow lmfit to be optional</span>
    <span class="kn">import</span> <span class="nn">lmfit</span>
    <span class="k">if</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="n">lmfit</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span><span class="o">&lt;</span><span class="n">LooseVersion</span><span class="p">(</span><span class="s2">&quot;0.9.0&quot;</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">lmfit.model</span> <span class="k">import</span> <span class="n">Model</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">lmfit.model</span> <span class="k">import</span> <span class="n">Model</span>
    <span class="kn">from</span> <span class="nn">lmfit</span> <span class="k">import</span> <span class="n">Parameters</span>
    <span class="n">_lmfit</span><span class="o">=</span><span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Model</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">Parameters</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_lmfit</span><span class="o">=</span><span class="kc">False</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span> <span class="k">as</span> <span class="n">copy</span>
<span class="c1">#from matplotlib.pylab import * #Surely not?</span>
<span class="k">if</span> <span class="n">python_v3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getfullargspec</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getargspec</span> <span class="k">as</span> <span class="n">getfullargspec</span>


<span class="c1">#==========================================================================================================================================</span>
<span class="c1"># Module Private Functions</span>
<span class="c1">#==========================================================================================================================================</span>


<span class="k">class</span> <span class="nc">_odr_Model</span><span class="p">(</span><span class="n">odrModel</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A wrapper for converting lmfit models to odr models.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise with lmfit.models.Model or callable.&quot;&quot;&quot;</span>
        <span class="n">meta</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;meta&quot;</span><span class="p">,</span><span class="nb">dict</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">model</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Need at least one argument to make a fitting model.&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isclass</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">):</span> <span class="c1">#Instantiate if only a class passed in</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">=</span><span class="n">model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">func</span>
            <span class="n">model</span><span class="o">=</span><span class="k">lambda</span> <span class="n">beta</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span>
            <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">arguments</span><span class="p">,</span><span class="n">carargs</span><span class="p">,</span><span class="n">jeywords</span><span class="p">,</span><span class="n">defaults</span><span class="o">=</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">model</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># pylint: disable=W1505</span>
            <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1">#print(arguments,carargs,jeywords,defaults)</span>
            <span class="n">func</span><span class="o">=</span><span class="n">model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">=</span><span class="n">model</span>
            <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">**</span><span class="n">_</span><span class="p">):</span> <span class="c1"># pylint: disable=E0102</span>
                <span class="sd">&quot;&quot;&quot;Warapper for model function.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;__name__&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">p0</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;p0&quot;</span><span class="p">,</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;estimate&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]):</span>
            <span class="n">p0</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
                    <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span><span class="s2">&quot;param_hints&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_hints</span><span class="p">:</span>
                    <span class="n">p0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">param_hints</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">((</span><span class="s2">&quot;You must either supply a p0 of length </span><span class="si">{}</span><span class="s2"> or supply a value for keyword &quot;</span><span class="o">+</span>
                                       <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> for your model function&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]),</span><span class="n">k</span><span class="p">))</span>
        <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;estimate&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">p0</span>

        <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;meta&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">meta</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">_odr_Model</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_curve_fit_result</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Represent a result from fitting using :py:func:`scipy.optimize.curve_fit` as a class to make handling easier.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="p">,</span><span class="n">infodict</span><span class="p">,</span><span class="n">mesg</span><span class="p">,</span><span class="n">ier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the results of the curve fit full_output fit.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">popt</span><span class="o">=</span><span class="n">popt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcov</span><span class="o">=</span><span class="n">pcov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perr</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesg</span><span class="o">=</span><span class="n">mesg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ier</span><span class="o">=</span><span class="n">ier</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">infodict</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">infodict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="c1">#Following peroperties used to return desired information</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popt</span><span class="o">.</span><span class="n">size</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">popt</span>
        <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">perr</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">pcov</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">=</span><span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">def</span> <span class="nf">_lmfit_p0_dict</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Works out an initial starting value dictionary for lmfit.</span>

<span class="sd">    Args:</span>
<span class="sd">        p0 (list,tuple,dict,lmfit.Parameter): Starting poiint to use for fitting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary of parameter starting points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_lmfit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;lmfit module not available.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">pv</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">pv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">p0</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">Parameters</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="c1">#p0={k:p0[k].value for k in p0}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;p0 should have been a tuple, list, ndarray or dict, or lmfit.parameters&quot;</span><span class="p">)</span>
    <span class="c1">#p0={p0[k] for k in model.param_names}</span>
    <span class="k">return</span> <span class="n">p0</span>

<span class="k">def</span> <span class="nf">_prep_lmfit_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">kargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prepare an lmfit model instance.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        model (lmfit Model class or instance, or callable): the model to be fitted to the data.</span>
<span class="sd">        p0 (iterable or floats): The initial values of the fitting parameters.</span>
<span class="sd">        kargs (dict):Other keyword arguments passed to the fitting function</span>

<span class="sd">    Returns:</span>
<span class="sd">        model,p0, prefix (lmfit.Model instance, iterable, str)</span>

<span class="sd">    Converts the model parameter into an instance of lmfit.Model - either by instantiating the class or wrapping a</span>
<span class="sd">    callable into an lmfit.Model class. If the latter, then determines the p0 starting parameter vector and finally</span>
<span class="sd">    establishes a prefix string from the model if not provided in the keyword arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1">#Will be the case if lmfit is not imported.</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;To use the lmfit function you need to be able to import the lmfit module</span><span class="se">\n</span><span class="s2"> Try pip install lmfit</span><span class="se">\n</span><span class="s2">at a command prompt.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">):</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
        <span class="n">model</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">):</span>
            <span class="n">p0</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">((</span><span class="s2">&quot;You must either supply a p0 of length </span><span class="si">{}</span><span class="s2"> or supply a value for keyword </span><span class="si">{}</span><span class="s2"> for your model&quot;</span><span class="o">+</span>
                                        <span class="s2">&quot;function </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span><span class="n">k</span><span class="p">,</span><span class="n">model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be an instance of lmfit.Model or a cllable function!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prefix&quot;</span><span class="p">,</span>  <span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">model</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">prefix</span>

<span class="k">def</span> <span class="nf">_prep_lmfit_p0</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">xdata</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">kargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prepare the initial start vector for an lmfit.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        model (lmfit.Model instance): model to fit with</span>
<span class="sd">        ydata,xdata (array): y and x data ppoints for fitting</span>
<span class="sd">        p0 (iterable of float): Existing p0 vector if defined</span>
<span class="sd">        kargs (dict): Other keyword arguments for the lmfit method.</span>

<span class="sd">    Returns:</span>
<span class="sd">        p0,single_fit (iterable of floats, bool): The revised initial starting vector and whether this is a single fit operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># 2D p0 might be chi^2 mapping</span>
            <span class="k">if</span> <span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># Actually a single fit</span>
                <span class="n">p0</span><span class="o">=</span><span class="n">_lmfit_p0_dict</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">model</span><span class="p">)</span>
                <span class="n">single_fit</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Is chi^2 mapping</span>
                <span class="n">single_fit</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">_lmfit_p0_dict</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">model</span><span class="p">)</span>
            <span class="n">single_fit</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1">#Do we already have parameter hints ?</span>
        <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">single_fit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="n">check</span><span class="o">&amp;=</span><span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_hints</span> <span class="ow">and</span> <span class="s2">&quot;value&quot;</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">param_hints</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span><span class="p">:</span> <span class="c1"># Ok, param_hints didn&#39;t have all the parameter values setup.</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">guess</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">xdata</span><span class="p">)</span>
            <span class="n">p0</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">kargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kargs</span> <span class="k">else</span> <span class="n">p0</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">p0</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">p0</span><span class="p">,</span><span class="n">single_fit</span>

<span class="k">def</span> <span class="nf">_outlier</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal function for outlier detector.</span>

<span class="sd">    Calculates if the current row is an outlier from the surrounding data by looking</span>
<span class="sd">    at the number of standard deviations away from the average of the window it is.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">av</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span> <span class="n">column</span><span class="p">])</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span> <span class="n">column</span><span class="p">])</span>  <span class="c1">#standard deviation</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">-</span> <span class="n">av</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">metric</span> <span class="o">*</span> <span class="n">std</span>


<span class="k">def</span> <span class="nf">_threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal function that implements the threshold method - also used in peak-finder</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold (float): Threshold valuye in data to look for</span>
<span class="sd">        rising (bool): Find points where data is rising up past threshold</span>
<span class="sd">        falling (bool): Find points where data is falling below the threshold</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of fractional indices where the data has crossed the threshold assuming a</span>
<span class="sd">        straight line interpolation between two points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First we find all points where we cross zero in the correct direction</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
    <span class="n">sdat</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">rising</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">falling</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">falling</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rising</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">False</span>

    <span class="c1"># Now we refine the estimate of zero crossing with a cubic interpolation</span>
    <span class="c1"># and use Newton&#39;s root finding method to locate the zero in the interpolated data</span>

    <span class="n">intr</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">-</span><span class="n">threshold</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
    <span class="n">roots</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sdat</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ix</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="c1"># There&#39;s a root somewhere here !</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newton</span><span class="p">(</span><span class="n">intr</span><span class="p">,</span><span class="n">ix</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span><span class="ne">RuntimeError</span><span class="p">):</span> <span class="c1"># fell off the end here</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_twoD_fit</span><span class="p">(</span><span class="n">xy1</span><span class="p">,</span><span class="n">xy2</span><span class="p">,</span><span class="n">xmode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="n">ymode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="n">m0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculae an optimal transformation of points :math:`(x_1,y_1)\rightarrow(x_2,y_2)`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        xy1 ( (n,2) array of float): Set of points to be mapped from.</span>
<span class="sd">        xy2 ( (n,2) array of floats): Set of points to be mapped to.</span>

<span class="sd">    Keyword Arguments:</span>
<span class="sd">        xmode (&#39;affine&#39;, &#39;linear&#39;, &#39;scale&#39; &#39;offset&#39; or &#39;fixed&#39;): How to manipulate the x-data</span>
<span class="sd">        ymode (&#39;linear&#39;, &#39;scale&#39; &#39;offset&#39; or &#39;fixed&#39;): How to manipulate the y-data</span>
<span class="sd">        m0 (3x2 array): Initial and fixed values of the transformation. Defaults to using an identity transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        opt_trans,trans_err,mapping func</span>

<span class="sd">    The most general case is an affine transform which includes rotation, scale, translation and skew. This is represented as a 2 x 3 matrix</span>
<span class="sd">    of coordinates. The *xmode* and *ymode* parameters control the possible operations to align the data in x and y directions, in addition</span>
<span class="sd">    to which the *xmode* parameter can take the value &#39;affine&#39; which allows a full affine transformation. The returned values are the</span>
<span class="sd">    affine transformation matrix, the uncertainities in this and a function to map co-ordinates with the optimal affine transformation.</span>

<span class="sd">    Note:</span>
<span class="sd">        *m0* combines both giving an initial value and fixed values for the transformation. If *m0* is set, then it is used to provide initial</span>
<span class="sd">        balues of the free parameters. Which elelemnts of *m0* that are free parameters and which are fixed is determined by the *xmode*</span>
<span class="sd">        and *ymode* parameters. IF *xmode* and *ymode* are both fixed, however, no scaling is done at all.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">xy1</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">xy2</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">xy1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;co-ordinate arrays must be equal length with two columns, not </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xy1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">xy2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">xvarp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;affine&quot;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
           <span class="s2">&quot;linear&quot;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
           <span class="s2">&quot;scale&quot;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span>
           <span class="s2">&quot;offset&quot;</span><span class="p">:[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
           <span class="s2">&quot;fixed&quot;</span><span class="p">:[[]]}</span>
    <span class="n">yvarp</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">:[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
           <span class="s2">&quot;scale&quot;</span><span class="p">:[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
           <span class="s2">&quot;offset&quot;</span><span class="p">:[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]],</span>
           <span class="s2">&quot;fixed&quot;</span><span class="p">:[[]]}</span>

    <span class="k">if</span> <span class="n">xmode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xvarp</span> <span class="ow">or</span> <span class="n">ymode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yvarp</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;xmode and ymode must be one of &#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;,&#39;fixed&#39; not </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xmode</span><span class="p">,</span><span class="n">ymode</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">xmode</span><span class="o">==</span><span class="s2">&quot;affine&quot;</span><span class="p">:</span>
        <span class="n">ymode</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span>

    <span class="n">xunknowns</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">xvarp</span><span class="p">[</span><span class="n">xmode</span><span class="p">])</span>
    <span class="n">yunknowns</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">yvarp</span><span class="p">[</span><span class="n">ymode</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">xunknowns</span><span class="o">+</span><span class="n">yunknowns</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># shortcircuit for the trivial case</span>
        <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span>

    <span class="n">mapping</span><span class="o">=</span><span class="n">xvarp</span><span class="p">[</span><span class="n">xmode</span><span class="p">]</span><span class="o">+</span><span class="n">yvarp</span><span class="p">[</span><span class="n">ymode</span><span class="p">]</span>
    <span class="n">mapping</span><span class="o">=</span><span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mapping</span> <span class="k">if</span> <span class="n">m</span><span class="o">!=</span><span class="p">[]]</span> <span class="c1"># remove empty mappings</span>
    <span class="n">data</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xy1</span><span class="p">,</span><span class="n">xy2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">m0</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p0s</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;affine&quot;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&quot;linear&quot;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s2">&quot;scale&quot;</span><span class="p">:[</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;offset&quot;</span><span class="p">:[</span><span class="mi">0</span><span class="p">],</span><span class="s2">&quot;fixed&quot;</span><span class="p">:[]}</span>
        <span class="n">p0</span><span class="o">=</span><span class="n">p0s</span><span class="p">[</span><span class="n">xmode</span><span class="p">]</span><span class="o">+</span><span class="n">p0s</span><span class="p">[</span><span class="n">ymode</span><span class="p">]</span>
        <span class="n">default</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.00</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m0</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">m0</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span>
            <span class="n">default</span><span class="o">=</span><span class="n">m0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;m0 starting matrix should be a numpy array of size (2,3) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">))</span>

    <span class="n">result</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="o">*</span><span class="n">p</span><span class="p">):</span><span class="c1">#Construct the fitting function</span>
        <span class="sd">&quot;&quot;&quot;Fitting function to find the transfoprm.&quot;&quot;&quot;</span>
        <span class="n">xy1</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xy</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xy2</span><span class="o">=</span><span class="n">xy</span><span class="p">[</span><span class="mi">2</span><span class="p">:,:]</span>
        <span class="k">for</span> <span class="n">pi</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">default</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">pi</span>
        <span class="n">xyt</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">xy1</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xy2</span><span class="o">-</span><span class="n">xyt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>


    <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="o">=</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">result</span><span class="p">,</span><span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">perr</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>

    <span class="c1">#Initialise the return values</span>
    <span class="n">default</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.00</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">pi</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span><span class="n">mapping</span><span class="p">):</span>
        <span class="n">default</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">pi</span>
    <span class="n">default_err</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pi</span><span class="p">,(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perr</span><span class="p">,</span><span class="n">mapping</span><span class="p">):</span>
        <span class="n">default_err</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">pi</span>

    <span class="n">transform</span><span class="o">=</span><span class="k">lambda</span> <span class="n">xy</span><span class="p">:</span><span class="n">ApplyAffineTransform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">default</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span><span class="n">default_err</span><span class="p">,</span><span class="n">transform</span><span class="p">)</span>


<div class="viewcode-block" id="ApplyAffineTransform"><a class="viewcode-back" href="../../classes/Stoner.Analysis.ApplyAffineTransform.html#Stoner.Analysis.ApplyAffineTransform">[docs]</a><span class="k">def</span> <span class="nf">ApplyAffineTransform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span><span class="n">transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a given afffine transform to a set of xy data points.&quot;&quot;&quot;</span>
    <span class="n">xyt</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">row_stack</span><span class="p">((</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">))))</span>
    <span class="n">xyt</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span><span class="n">xyt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xyt</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="GetAffineTransform"><a class="viewcode-back" href="../../classes/Stoner.Analysis.GetAffineTransform.html#Stoner.Analysis.GetAffineTransform">[docs]</a><span class="k">def</span> <span class="nf">GetAffineTransform</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate an affine transofrm from 2 sets of three points.</span>

<span class="sd">    Args:</span>
<span class="sd">        p (3x2 array): Coordinates of points to transform from.</span>
<span class="sd">        pd (3x2 array): Cooridinates of points to transform to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        2x3 matrix representing the affine transform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">!=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span><span class="o">!=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must supply three points&quot;</span><span class="p">)</span>

    <span class="n">p</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">transform</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pd</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">transform</span><span class="o">.</span><span class="n">T</span></div>

<div class="viewcode-block" id="AnalysisMixin"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin">[docs]</a><span class="k">class</span> <span class="nc">AnalysisMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A mixin calss designed to work with :py:class:`Stoner.Core.DataFile` to provide additional analysis methods.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just call super.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done AnlaysisMixin init&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AnalysisMixin.SG_Filter"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.SG_Filter">[docs]</a>    <span class="k">def</span> <span class="nf">SG_Filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Savitsky-Golay filtering of data for smoothing and differentiating data.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (index): Column of Data to be filtered. if None, first y-column in setas is filtered.</span>
<span class="sd">            prints (int): Number of data points to use in the filtering window. Should be an odd number &gt; poly+1 (default 15)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            poly (int): Order of polynomial to fit to the data. Must be equal or greater than order (default 1)</span>
<span class="sd">            order (int): Order of differentiation to carry out. Default=0 meaning smooth the data only.</span>
<span class="sd">            result (None,True, or column_index): If not None, column index to insert new data, or True to append as last column</span>
<span class="sd">            header (string or None): Header for new column if result is not None. If header is Nne, a suitable column header is generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpoy array or self): If result is None, a numpy array representing the smoothed or differentiated data is returned.</span>
<span class="sd">            Otherwise, a copy of the modified AnalysisMixin object is returned.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If col is not specified or is None then the :py:attr:`DataFile.setas` column assignments are used</span>
<span class="sd">            to set an x and y column. If col is a tuple, then it is assumed to secify and x-column and y-column</span>
<span class="sd">            for differentiating data. This is now a pass through to :py:func:`scipy.signal.savgol_filter`</span>

<span class="sd">        See Also:</span>
<span class="sd">            User guide section :ref:`smoothing_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="k">import</span> <span class="n">ordinal</span>
        <span class="n">points</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#Ensure window length is odd</span>
            <span class="n">points</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">],</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ddata</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;interp&quot;</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ddata</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">ddata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;interp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> after </span><span class="si">{}</span><span class="s1"> order Savitsky-Golay Filter&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)],</span>
                                                                          <span class="n">ordinal</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span></div>

    <span class="k">def</span> <span class="nf">__get_math_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility routine to interpret col as either a column index or value or an array of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (various): If col can be interpreted as a column index then return the first matching column.</span>
<span class="sd">                If col is a 1D array of the same length as the data then just return the data. If col is a</span>
<span class="sd">                float then just return it as a float.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The matching data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">index_types</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">col</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Bad column index: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">_poly_outlier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alternative outlier detection function that fits a polynomial locally over the window.</span>

<span class="sd">        Args:</span>
<span class="sd">            row (1D array): Current row of data</span>
<span class="sd">            column int): Column index of y values to examine</span>
<span class="sd">            window (2D array): Local window of data</span>

<span class="sd">        Keyyword Arguments:</span>
<span class="sd">            metric (float): Some measure of how sensitive the dection should be</span>
<span class="sd">            xcol (column index): Column of data to use for X values. Defaults to current setas value</span>
<span class="sd">            order (int): Order of polynomial to fit. Must be &lt; length of window-1</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if current row is an outlier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order should be smaller than the window length.&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">column</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">)</span>


        <span class="n">x</span><span class="o">=</span><span class="n">window</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">window</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">window</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="kc">None</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span><span class="n">deg</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pval</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">metric</span> <span class="o">*</span> <span class="n">perr</span>

    <span class="k">def</span> <span class="nf">_get_curve_fit_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">,</span><span class="n">bounds</span><span class="p">,</span><span class="n">sigma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gather up the xdata and sigma columns for curve_fit.&quot;&quot;&quot;</span>
        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isNone</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">sigma</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">xcol</span><span class="p">):</span>
            <span class="n">xdat</span><span class="o">=</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">xcol</span><span class="p">:</span>
                <span class="n">xdat</span> <span class="o">=</span> <span class="n">xdat</span>  <span class="o">+</span> <span class="p">(</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">c</span><span class="p">)],)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">yc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ycol</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yc</span><span class="p">,</span><span class="n">index_types</span><span class="p">):</span>
                <span class="n">ydat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">yc</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yc</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">yc</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">yc</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">ydat</span><span class="o">=</span><span class="n">yc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Y-data for fitting not defined - should either be an index or a 1D numpy array of the same length as the dataset&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">ydata</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ydat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ydata</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">ydata</span><span class="p">,</span><span class="n">ydat</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">xdat</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">sigma</span>



    <span class="k">def</span> <span class="nf">__lmfit_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">scale_covar</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Carry out a single fit wioth lmfit.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (lmfit.Model): Configured model</span>
<span class="sd">            xcol (int,str): index for x data</span>
<span class="sd">            ydata (array): y data to fit</span>
<span class="sd">            scale_covat (bool): Whether sigmas are absolute or relative.</span>
<span class="sd">            sigma (array): Uncertainties of ydata.</span>
<span class="sd">            p0 (dict): Dictionary of parameters including independent data</span>
<span class="sd">            prefix (str): Prefix for labels in metadata</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            result (bool,str): Where the result goes</span>
<span class="sd">            header (str): Name of new data column if used</span>
<span class="sd">            replace (bool): whether to add new dataa</span>
<span class="sd">            output (str): What to return</span>

<span class="sd">        Returns:</span>
<span class="sd">            Results froma  fit or raises and exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_lmfit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;lmfit module not available.&quot;</span><span class="p">)</span>

        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">header</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">residuals</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;residuals&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">output</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span><span class="s2">&quot;row&quot;</span><span class="p">)</span>
        <span class="n">ycol</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">scale_covar</span><span class="o">=</span><span class="n">scale_covar</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">p0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="n">row</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_record_curve_fit_result</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">fit</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">header</span><span class="p">,</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="p">,</span><span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>

            <span class="n">retval</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fit&quot;</span><span class="p">:(</span><span class="n">row</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">fit</span><span class="o">.</span><span class="n">covar</span><span class="p">),</span><span class="s2">&quot;report&quot;</span><span class="p">:</span> <span class="n">fit</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span><span class="s2">&quot;data&quot;</span><span class="p">:</span><span class="bp">self</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to recognise output format:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">retval</span><span class="p">[</span><span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to complete fit. Error was:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">lmdif_message</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_record_curve_fit_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">fit</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">header</span><span class="p">,</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="p">,</span><span class="n">residuals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Annotate the DataFile object with the curve_fit result.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,(</span><span class="n">lmfit</span><span class="o">.</span><span class="n">Model</span><span class="p">)):</span>
            <span class="n">f_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">func</span>
        <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">lmfit</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
            <span class="n">f_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">func</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,(</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">Model</span><span class="p">)):</span>
            <span class="n">f_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f_name</span><span class="o">=</span><span class="n">prefix</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># pylint: disable=W1505</span>
        <span class="k">del</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span><span class="n">_curve_fit_result</span><span class="p">):</span> <span class="c1"># Come from curve_fit</span>
            <span class="n">popt</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">popt</span>
            <span class="n">perr</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">perr</span>
            <span class="n">nfev</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">nfev</span>
            <span class="n">chisq</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">chisq</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span><span class="n">lmfit</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">ModelResult</span><span class="p">):</span> <span class="c1"># Come form an lmfit operation</span>
            <span class="n">popt</span><span class="o">=</span><span class="p">[</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">perr</span><span class="o">=</span><span class="p">[</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">nfev</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">nfev</span>
            <span class="n">chisq</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">redchi</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">Output</span><span class="p">):</span>
            <span class="n">popt</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span>
            <span class="n">perr</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">sd_beta</span>
            <span class="n">delta</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span><span class="n">fit</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">nfree</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
            <span class="n">chisq</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">eps</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">nfree</span>
            <span class="n">nfev</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to understand </span><span class="si">{}</span><span class="s2"> as a fitting result&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fit</span><span class="p">)))</span>



        <span class="k">for</span> <span class="n">val</span><span class="p">,</span><span class="n">err</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span><span class="n">perr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> err&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span><span class="n">name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">err</span>
            <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1"> label&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span><span class="n">name</span><span class="p">)]</span><span class="o">=</span><span class="n">name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;Fitted with &#39;</span> <span class="o">+</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Store our current mask, calculate new column&#39;s mask and turn off mask</span>
        <span class="n">tmp_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">col_mask</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tmp_mask</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span><span class="c1">#Appending data to end of data</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tmp_mask</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">tmp_mask</span><span class="p">,</span><span class="n">col_mask</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Inserting data</span>
            <span class="n">tmp_mask</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">tmp_mask</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">result</span><span class="p">],</span><span class="n">col_mask</span><span class="p">,</span><span class="n">tmp_mask</span><span class="p">[:,</span><span class="n">result</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="n">islike_list</span><span class="p">(</span><span class="n">xcol</span><span class="p">):</span>
            <span class="n">new_col</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">[:,</span><span class="n">xcol</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_col</span><span class="o">=</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">new_col</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">residuals</span><span class="p">:</span>
            <span class="n">residual_vals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span><span class="o">-</span><span class="n">new_col</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">residuals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">residuals_idx</span><span class="o">=</span><span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">residuals_idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residuals_idx</span><span class="o">=</span><span class="n">residuals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">residual_vals</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">residuals_idx</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="o">+</span><span class="s2">&quot;:residuals&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:mean residual&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">residual_vals</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:std residual&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">residual_vals</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:chi^2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">chisq</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:chi^2 err&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">residual_vals</span><span class="p">))</span><span class="o">*</span><span class="n">chisq</span>
        <span class="k">if</span> <span class="n">nfev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:nfev&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span><span class="o">=</span><span class="n">nfev</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">tmp_mask</span>
        <span class="c1">#Make row object</span>
        <span class="n">row</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ch</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span><span class="n">perr</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
            <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">])</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> stderr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">)])</span>
        <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chisq</span><span class="p">)</span>
        <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">chi^2$&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">row</span><span class="o">=</span><span class="bp">cls</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">row</span><span class="o">.</span><span class="n">column_headers</span><span class="o">=</span><span class="n">ch</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="k">def</span> <span class="nf">__threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal function that implements the threshold method - also used in peak-finder</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (float): Threshold valuye in data to look for</span>
<span class="sd">            rising (bool): Find points where data is rising up past threshold</span>
<span class="sd">            falling (bool): Find points where data is falling below the threshold</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array of fractional indices where the data has crossed the threshold assuming a</span>
<span class="sd">            straight line interpolation between two points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we find all points where we cross zero in the correct direction</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
        <span class="n">sdat</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rising</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">False</span>

        <span class="n">current</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">current</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span>
        <span class="c1"># Now we refine the estimate of zero crossing with a cubic interpolation</span>
        <span class="c1"># and use Newton&#39;s root finding method to locate the zero in the interpolated data</span>

        <span class="n">intr</span><span class="o">=</span><span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">data</span><span class="o">-</span><span class="n">threshold</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="n">roots</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sdat</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ix</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">ix</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># There&#39;s a root somewhere here !</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newton</span><span class="p">(</span><span class="n">intr</span><span class="p">,</span><span class="n">ix</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># fell off the end here</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handles the local attributes as well as the inherited ones&quot;&quot;&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

<div class="viewcode-block" id="AnalysisMixin.add"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one column, number or array (b) to another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">+</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.apply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the given function to each row in the data set and adds to the data set.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): A function that takes a numpy 1D array representing each row of data</span>
<span class="sd">            col (index): The column in which to place the result of the function</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            replace (bool): Isnert a new data column (False) or replace the data column (True, default)</span>
<span class="sd">            header (string or None): The new column header (defaults to the name of the function func</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()[</span><span class="s2">&quot;ycol&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nc</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">col</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.bin"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.bin">[docs]</a>    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bin x-y data into new values of x with an error bar.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Index of column of data with X values</span>
<span class="sd">            ycol (index): Index of column of data with Y values</span>
<span class="sd">            bins (int, float or 1d array): Number of bins (if integer) or size of bins (if float), or bin edges (if array)</span>
<span class="sd">            mode (string): &quot;log&quot; or &quot;lin&quot; for logarithmic or linear binning</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            yerr (index): Column with y-error data if present.</span>
<span class="sd">            bin_start (float): Manually override the minimum bin value</span>
<span class="sd">            bin_stop (float): Manually override the maximum bin value</span>
<span class="sd">            clone (bool): Return a clone of the current AnalysisMixin with binned data (True)</span>
<span class="sd">                          or just the numbers (False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a clone of the current data set with the new binned data or</span>
<span class="sd">            tuple of (bin centres, bin values, bin errors, number points/bin),</span>
<span class="sd">            depending on the *clone* parameter.</span>

<span class="sd">        Note:</span>
<span class="sd">            Algorithm inspired by MatLab code wbin,    Copyright (c) 2012:</span>
<span class="sd">            Michael Lindholm Nielsen</span>


<span class="sd">        See Also:</span>
<span class="sd">            User Guide section :ref:`binning_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;yerr&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;yerr&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="p">):</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;yerr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kargs</span> <span class="ow">and</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;has_yerr&quot;</span><span class="p">]:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;yerr&quot;</span><span class="p">]</span>

        <span class="n">bin_left</span><span class="p">,</span> <span class="n">bin_right</span><span class="p">,</span> <span class="n">bin_centres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_bins</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>

        <span class="n">ycol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

        <span class="n">ybin</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">ebin</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">limits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bin_left</span><span class="p">,</span> <span class="n">bin_right</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ok</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
                <span class="n">shape</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                <span class="n">data</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">yerr</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                  <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">))</span><span class="o">/</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Empty bin at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="n">W</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ybin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">ebin</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">clone</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span><span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">xcol</span><span class="p">]]</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ybin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">head</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">ycol</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">ybin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span><span class="n">header</span><span class="o">=</span><span class="n">head</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">ebin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span><span class="n">header</span><span class="o">=</span><span class="s2">&quot;d</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">nbins</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span><span class="n">header</span><span class="o">=</span><span class="s2">&quot;#/bin </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
                <span class="n">s</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="p">)</span>
                <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_centres</span><span class="p">,</span> <span class="n">ybin</span><span class="p">,</span> <span class="n">ebin</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.clip"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clipper</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clips the data based on the column and the clipper value.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>
<span class="sd">            clipper (tuple or array): Either a tuple of (min,max) or a numpy.ndarray -</span>
<span class="sd">                in which case the max and min values in that array will be</span>
<span class="sd">                used as the clip limits</span>
<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="n">clipper</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">clipper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">clipper</span><span class="p">))</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">clipper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">clipper</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.curve_fit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.curve_fit">[docs]</a>    <span class="k">def</span> <span class="nf">curve_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;General curve fitting function passed through from scipy.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): The fitting function with the form def f(x,*p) where p is a list of fitting parameters</span>
<span class="sd">            xcol (index, Iterable): The index of the x-column data to fit. If list or other iterable sends a tuple of x columns to func for N-d fitting.</span>
<span class="sd">            ycol (index, list of indices or array): The index of the y-column data to fit. If an array, then should be 1D and</span>
<span class="sd">                the same length as the data. If ycol is a list of indices then the columns are iterated over in turn, fitting occuring</span>
<span class="sd">                for each one. In this case the return value is a list of what would be returned for a single column fit.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            p0 (list, tuple or array): A vector of initial parameter values to try</span>
<span class="sd">            sigma (index): The index of the column with the y-error bars</span>
<span class="sd">            bounds (callable): A callable object that evaluates true if a row is to be included. Should be of the form f(x,y)</span>
<span class="sd">            result (bool): Determines whether the fitted data should be added into the DataFile object. If result is True then</span>
<span class="sd">                the last column will be used. If result is a string or an integer then it is used as a column index.</span>
<span class="sd">                Default to None for not adding fitted data</span>
<span class="sd">            replace (bool): Inidcatesa whether the fitted data replaces existing data or is inserted as a new column (default False)</span>
<span class="sd">            header (string or None): If this is a string then it is used as the name of the fitted data. (default None)</span>
<span class="sd">            absolute_sigma (bool): If False, `sigma` denotes relative weights of the data points. The default True means that</span>
<span class="sd">                the sigma parameter is the reciprocal of the absoluate standard deviation.</span>
<span class="sd">            output (str, default &quot;fit&quot;): Specifiy what to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            popt, pcov (array, 2D array): Optimal values of the fitting parameters p, and the variance-co-variance matrix</span>
<span class="sd">            for the fitting parameters.</span>

<span class="sd">        The return value is determined by the *output* parameter. Options are:</span>
<span class="sd">            * &quot;fit&quot;    (tuple of popt,pcov)</span>
<span class="sd">            * &quot;row&quot;     just a one dimensional numpy array of the fit paraeters interleaved with their uncertainties</span>
<span class="sd">            * &quot;full&quot;    a tuple of (popt,pcov,dictionary of optional outputs, message, return code, row).</span>
<span class="sd">            * &quot;data&quot;   a copy of the :py:class:`Stoner.Core.DataFile` object with fit recorded in the metadata and optionally as a new column.</span>

<span class="sd">        Note:</span>
<span class="sd">            If the columns are not specified (or set to None) then the X and Y data are taken using the</span>
<span class="sd">            :py:attr:`Stoner.Core.DataFile.setas` attribute.</span>

<span class="sd">            The fitting function should have prototype y=f(x,p[0],p[1],p[2]...)</span>
<span class="sd">            The x-column and y-column can be anything that :py:meth:`Stoner.Core.DataFile.find_col` can use as an index</span>
<span class="sd">            but typucally either strings to be matched against column headings or integers.</span>
<span class="sd">            The initial parameter values and weightings default to None which corresponds to all parameters starting</span>
<span class="sd">            at 1 and all points equally weighted. The bounds function has format b(x, y-vec) and rewturns true if the</span>
<span class="sd">            point is to be used in the fit and false if not.</span>


<span class="sd">            The *absolute_sigma* keyword determines whether the returned covariance matrix `pcov` is based on *estimated* errors in</span>
<span class="sd">            the data, and is not affected by the overall magnitude of the values in `sigma`. Only the relative magnitudes of the</span>
<span class="sd">            *sigma* values matter.</span>
<span class="sd">            If True, `sigma` describes one standard deviation errors of the input data points. The estimated covariance in `pcov` is</span>
<span class="sd">            based on these values.</span>


<span class="sd">        See Also:</span>
<span class="sd">            :py:meth:`Stoner.Analysis.AnalysisMixin.lmfit`</span>
<span class="sd">            User guide section :ref:`curve_fit_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;residuals&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">prefix</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prefix&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1">#Support either scale_covar or absolute_sigma, the latter wins if both supplied</span>
        <span class="c1">#If neither are specified, then if sigma is not given, absolute sigma will be False.</span>

        <span class="n">scale_covar</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale_covar&quot;</span><span class="p">,</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;absolute_sigma&quot;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">scale_covar</span><span class="p">)</span>
        <span class="c1">#Support both asrow and output, the latter wins if both supplied</span>
        <span class="n">asrow</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;asrow&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span> <span class="k">if</span> <span class="n">asrow</span> <span class="k">else</span> <span class="s2">&quot;fit&quot;</span><span class="p">)</span>
        <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;full_output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">ycol</span><span class="o">=</span><span class="p">[</span><span class="n">ycol</span><span class="p">,]</span>

        <span class="n">xdat</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_curve_fit_data</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>


        <span class="n">retvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">i</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ydat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ydata</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">sigma</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">sigma</span> <span class="c1"># probably this will fail!</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="n">sigma</span>

            <span class="n">report</span><span class="o">=</span><span class="n">_curve_fit_result</span><span class="p">(</span><span class="o">*</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">xdat</span><span class="p">,</span> <span class="n">ydat</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="n">absolute_sigma</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">))</span>
            <span class="n">report</span><span class="o">.</span><span class="n">func</span><span class="o">=</span><span class="n">func</span>
            <span class="n">report</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span>
            <span class="n">report</span><span class="o">.</span><span class="n">residual_vals</span><span class="o">=</span><span class="n">ydata</span><span class="o">-</span><span class="n">report</span><span class="o">.</span><span class="n">fvec</span>
            <span class="n">report</span><span class="o">.</span><span class="n">chisq</span><span class="o">=</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">residual_vals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">report</span><span class="o">.</span><span class="n">nfree</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">popt</span><span class="p">)</span>
            <span class="n">report</span><span class="o">.</span><span class="n">chisq</span><span class="o">/=</span><span class="n">report</span><span class="o">.</span><span class="n">nfree</span>


            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_record_curve_fit_result</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">report</span><span class="p">,</span><span class="n">xcol</span><span class="p">,</span><span class="n">header</span><span class="p">,</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="p">,</span><span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">retvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">report</span><span class="p">,</span><span class="n">output</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Specified output: </span><span class="si">{}</span><span class="s2">, from curve_fit not recognised&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">retvals</span><span class="o">=</span><span class="n">retvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">retvals</span></div>

<div class="viewcode-block" id="AnalysisMixin.decompose"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.decompose">[docs]</a>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given (x,y) data, decomposes the y part into symmetric and antisymmetric contributions in x.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (index): Index of column with x data - defaults to first x column in self.setas</span>
<span class="sd">            ycol (index or list of indices): indices of y column(s) data</span>
<span class="sd">            sym (index): Index of column to place symmetric data in default, append to end of data</span>
<span class="sd">            asym (index): Index of column for asymmetric part of ata. Defaults to appending to end of data</span>
<span class="sd">            replace (bool): Overwrite data with output (true)</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/decompose.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: decompose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_startx&quot;</span> <span class="ow">in</span> <span class="n">kwords</span><span class="p">:</span>
                <span class="n">startx</span> <span class="o">=</span> <span class="n">kwords</span><span class="p">[</span><span class="s2">&quot;_startx&quot;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">kwords</span><span class="p">[</span><span class="s2">&quot;_startx&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="n">startx</span><span class="o">=</span><span class="n">startx</span><span class="p">)</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ycol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ycol</span> <span class="o">=</span> <span class="n">ycol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># FIXME should work with multiple output columns</span>
        <span class="n">pxdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xcol</span><span class="p">)</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pxdata</span><span class="p">,</span> <span class="n">pxdata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span>
        <span class="n">symd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ydata</span> <span class="o">+</span> <span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">asymd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ydata</span> <span class="o">-</span> <span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">&amp;=</span> <span class="n">symd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Symmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">symd</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Symmetric Data&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">&amp;=</span> <span class="n">asymd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Asymmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">asymd</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Symmetric Data&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">asym</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.diffsum"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.diffsum">[docs]</a>    <span class="k">def</span> <span class="nf">diffsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\frac{a-b}{a+b}` for the two columns *a* and *b*.</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span>
                                                                       <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                                                      <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span>
                                                                       <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">)/(</span><span class="si">{}</span><span class="s2">+</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.divide"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.divide">[docs]</a>    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divide one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span> <span class="o">/</span> <span class="n">adata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                                                      <span class="p">(</span><span class="n">e2data</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">adata</span> <span class="o">/</span> <span class="n">bdata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.extrapolate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.extrapolate">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_x</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overlap</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extrapolate data based on local fit to x,y data.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_x (float or array): New values of x data.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index, None): column containing x-data or None to use setas attribute</span>
<span class="sd">            ycol (column index(es) or None): column(s) containing the y-data or None to use setas attribute.</span>
<span class="sd">            yerr (column index(es) or None): y error data column or None to use setas attribute</span>
<span class="sd">            overlap (float or int): range of x-data used for the local fit for extrapolating. If int then overlap number of</span>
<span class="sd">                points is used, if float then that range x-axis space is used.</span>
<span class="sd">            kind (str or callable): Determines local fitting function. If string should be &quot;linear&quot;, &quot;quadratic&quot; or &quot;cubic&quot; if</span>
<span class="sd">                callable, then represents a function to be fitted to the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of extrapolated values.</span>

<span class="sd">        Note:</span>
<span class="sd">            If the new_x values lie outside the span of the x-data, then the nearest *overlap* portion of the data is used</span>
<span class="sd">            to estimate the values. If the new_x values are within the span of the x-data then the portion of the data</span>
<span class="sd">            centred about the point and overlap points long will be used to interpolate a value.</span>

<span class="sd">            If *kind* is callable, it should take x values in the first parameter and free fitting parameters as the other</span>
<span class="sd">            parameters (i.e. as with :py:meth:`AnalysisMixin.curve_fit`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">kinds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">c</span><span class="p">:</span><span class="n">m</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">c</span><span class="p">,</span>
               <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">:</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">c</span><span class="p">,</span>
               <span class="s2">&quot;cubic&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">d</span><span class="p">}</span>
        <span class="n">errs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">me</span><span class="p">,</span><span class="n">ce</span><span class="p">:</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">me</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ce</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">ae</span><span class="p">,</span><span class="n">be</span><span class="p">,</span><span class="n">ce</span><span class="p">:</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">ae</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">be</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ce</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
              <span class="s2">&quot;cubic&quot;</span><span class="p">:</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">ae</span><span class="p">,</span><span class="n">be</span><span class="p">,</span><span class="n">ce</span><span class="p">,</span><span class="n">de</span><span class="p">:</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">ae</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">be</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">ce</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">de</span><span class="o">**</span><span class="mi">2</span><span class="p">)}</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">kind</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="n">kindf</span><span class="o">=</span><span class="n">kinds</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to recognise extrpolation function &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="p">))</span>
        <span class="n">scalar_x</span><span class="o">=</span><span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalar_x</span><span class="p">:</span>
            <span class="n">new_x</span><span class="o">=</span><span class="p">[</span><span class="n">new_x</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">new_x</span><span class="o">=</span><span class="n">new_x</span><span class="o">.</span><span class="n">compressed</span>
        <span class="n">results</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_x</span><span class="p">),</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">work</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_x</span><span class="p">):</span>
            <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">i</span><span class="o">-</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">ll</span><span class="o">=</span><span class="mi">0</span>
                    <span class="n">hl</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span><span class="n">overlap</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">i</span><span class="o">+</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">hl</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">ll</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">hl</span><span class="o">-</span><span class="n">overlap</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ll</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">i</span><span class="o">-</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">hl</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">i</span><span class="o">+</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;_i__between&quot;</span><span class="p">:(</span><span class="n">ll</span><span class="p">,</span><span class="n">hl</span><span class="p">)}</span>
                <span class="n">mid_x</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ll</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="p">[</span><span class="n">hl</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">-</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">ll</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">hl</span><span class="o">=</span><span class="n">ll</span><span class="o">+</span><span class="n">overlap</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">+</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">hl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ll</span><span class="o">=</span><span class="n">hl</span><span class="o">-</span><span class="n">overlap</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ll</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">-</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">hl</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">+</span><span class="n">overlap</span><span class="o">/</span><span class="mi">2</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">__between&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]):(</span><span class="n">ll</span><span class="p">,</span><span class="n">hl</span><span class="p">)}</span>
                <span class="n">mid_x</span><span class="o">=</span><span class="p">(</span><span class="n">ll</span><span class="o">+</span><span class="n">hl</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">pointdata</span><span class="o">=</span><span class="n">work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">pointdata</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">=</span><span class="n">pointdata</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span><span class="o">-</span><span class="n">mid_x</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">pointdata</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">kindf</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">,</span><span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="n">ret</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iy</span><span class="p">,</span><span class="n">rt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span><span class="o">=</span><span class="n">rt</span>
                <span class="n">perr</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
                <span class="n">results</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">iy</span><span class="p">]</span><span class="o">=</span><span class="n">kindf</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mid_x</span><span class="p">,</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">iy</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">errs</span><span class="p">[</span><span class="n">kind</span><span class="p">](</span><span class="n">x</span><span class="o">-</span><span class="n">mid_x</span><span class="p">,</span><span class="o">*</span><span class="n">perr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalar_x</span><span class="p">:</span>
            <span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="AnalysisMixin.integrate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">result_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inegrate a column of data, optionally returning the cumulative integral.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): The X data column index (or header)</span>
<span class="sd">            ycol (index) The Y data column index (or header)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            result (index or None): Either a column index (or header) to overwrite with the cumulative data,</span>
<span class="sd">                or True to add a new column or None to not store the cumulative result.</span>
<span class="sd">            result_name (string): The new column header for the results column (if specified)</span>
<span class="sd">            bounds (callable): A function that evaluates for each row to determine if the data should be integrated over.</span>
<span class="sd">            kargs: Other keyword arguements are fed direct to the scipy.integrate.cumtrapz method</span>

<span class="sd">        Returns:</span>
<span class="sd">            The final integration result</span>

<span class="sd">        Note:</span>
<span class="sd">            This is a pass through to the scipy.integrate.cumtrapz routine which just uses trapezoidal integration. A better alternative would be</span>
<span class="sd">            to offer a variety of methods including simpson&#39;s rule and interpolation of data. If xcol or ycol are not specified then</span>
<span class="sd">            the current values from the :py:attr:`Stoner.Core.DataFile.setas` attribute are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="n">final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">yd</span> <span class="o">=</span> <span class="n">ydat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">resultdata</span> <span class="o">=</span> <span class="n">cumtrapz</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="n">resultdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">resultdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resultdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final</span></div>

<div class="viewcode-block" id="AnalysisMixin.interpolate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newX</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate a dataset to get a new set of values for a given set of x data.</span>

<span class="sd">        Args:</span>
<span class="sd">            ewX (1D array or None): Row indices or X column values to interpolate with. If None, then the</span>
<span class="sd">            :py:meth:`AnalysisMixin.interpolate` returns an interpolation function. Unlike the raw interpolation</span>
<span class="sd">            function from scipy, this interpolation function will work with MaskedArrays by compressing them</span>
<span class="sd">            first.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kind (string): Type of interpolation function to use - does a pass through from numpy. Default is linear.</span>
<span class="sd">            xcol (index or None): Column index or label that contains the data to use with newX to determine which rows to return. Defaults to None.</span>
<span class="sd">            replace (bool): If true, then the current AnalysisMixin&#39;s data is replaced with the  newly interpolated data and the current AnalysisMixin is</span>
<span class="sd">                returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2D numpy array: representing a section of the current object&#39;s data if replace is False(default) or the modofied AnalysisMixin if replace is true.</span>

<span class="sd">        Note:</span>
<span class="sd">            Returns complete rows of data corresponding to the indices given in newX. if xcol is None, then newX is interpreted as (fractional) row indices.</span>
<span class="sd">            Otherwise, the column specified in xcol is thresholded with the values given in newX and the resultant row indices used to return the data.</span>

<span class="sd">            If the positional argument, newX is None, then the return value is an interpolation function. This interpolation function takes one argument</span>
<span class="sd">            - if *xcol* was None, this argument is interpreted as array indices, but if *xcol* was specified, then this argument is interpreted as</span>
<span class="sd">            an array of xvalues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DataArray</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">newX</span><span class="o">=</span><span class="n">newX</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">newX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># We need to convert newX to row indices</span>
            <span class="n">xfunc</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># xfunc(x) returns partial index</span>
            <span class="n">newX</span> <span class="o">=</span> <span class="n">xfunc</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#Ok, we&#39;re going to return an interpolation function</span>
            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">newX</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Wrapper for interpolation function.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">newX</span><span class="o">=</span><span class="n">newX</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newX</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">newX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># We need to convert newX to row indices</span>
                    <span class="n">xfunc</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># xfunc(x) returns partial index</span>
                    <span class="n">newX</span> <span class="o">=</span> <span class="n">xfunc</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wrapper</span>

        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">DataArray</span><span class="p">(</span><span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">),</span><span class="n">isrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.lmfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.lmfit">[docs]</a>    <span class="k">def</span> <span class="nf">lmfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Wrapper around lmfit module fitting.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (lmfit.Model): An instance of an lmfit.Model that represents the model to be fitted to the data</span>
<span class="sd">            xcol (index or None): Columns to be used for the x  data for the fitting. If not givem defaults to the</span>
<span class="sd">            :py:attr:`Stoner.Core.DataFile.setas` x column</span>
<span class="sd">            ycol (index or None): Columns to be used for the  y data for the fitting. If not givem defaults to the</span>
<span class="sd">            :py:attr:`Stoner.Core.DataFile.setas` y column</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            p0 (list, tuple or array): A vector of initial parameter values to try.</span>
<span class="sd">            sigma (index): The index of the column with the y-error bars</span>
<span class="sd">            bounds (callable): A callable object that evaluates true if a row is to be included. Should be of the form f(x,y)</span>
<span class="sd">            result (bool): Determines whether the fitted data should be added into the DataFile object. If result is True then</span>
<span class="sd">                the last column will be used. If result is a string or an integer then it is used as a column index.</span>
<span class="sd">                Default to None for not adding fitted data</span>
<span class="sd">            replace (bool): Inidcatesa whether the fitted data replaces existing data or is inserted as a new column (default False)</span>
<span class="sd">            header (string or None): If this is a string then it is used as the name of the fitted data. (default None)</span>
<span class="sd">            scale_covar (bool) : whether to automatically scale covariance matrix (leastsq only)</span>
<span class="sd">            output (str, default &quot;fit&quot;): Specifiy what to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The lmfit module will refurn an instance of the :py:class:`lmfit.models.ModelFit` class that contains all</span>
<span class="sd">            relevant information about the fit.</span>

<span class="sd">        The return value is determined by the *output* parameter. Options are</span>
<span class="sd">            - &quot;ffit&quot;    just the :py:class:`lmfit.model.ModelFit` instance</span>
<span class="sd">            - &quot;row&quot;     just a one dimensional numpy array of the fit paraeters interleaved with their uncertainties</span>
<span class="sd">            - &quot;full&quot;    a tuple of the fit instance and the row.</span>
<span class="sd">            - &quot;data&quot;    a copy of the :py:class:`Stoner.Core.DataFile` object with the fit recorded in the emtadata and optinally as a column of data.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :py:meth:`AnalysisMixin.curve_fit`</span>
<span class="sd">            User guide section :ref:`fitting_with_limits`</span>

<span class="sd">        .. note::</span>

<span class="sd">           If *p0* is fed a 2D array, then it assumed that you want to calculate :math:`\chi^2` for different starting parameters</span>
<span class="sd">           with some variables fixed. In this mode, fitting is carried out repeatedly with each row representing one attempt with different</span>
<span class="sd">           values of the parameters. In this mode the return value is a 2D array whose rows correspond to the inputs to the rows of p0, the</span>
<span class="sd">           columns are the fitted values of the parameters with an additional column for :math:`\chi^2`.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/lmfit_simple.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: lmfit2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;residuals&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Support both absolute_sigma and scale_covar, but scale_covar wins here (c.f.curve_fit)</span>
        <span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;absolute_sigma&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">scale_covar</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale_covar&quot;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">absolute_sigma</span><span class="p">)</span>
        <span class="c1">#Support both asrow and output, the latter wins if both supplied</span>
        <span class="n">asrow</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;asrow&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span> <span class="k">if</span> <span class="n">asrow</span> <span class="k">else</span> <span class="s2">&quot;fit&quot;</span><span class="p">)</span>

        <span class="n">model</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="n">_prep_lmfit_model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">kargs</span><span class="p">)</span>

        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">xdata</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>

        <span class="n">p0</span><span class="p">,</span><span class="n">single_fit</span> <span class="o">=</span> <span class="n">_prep_lmfit_p0</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">xdata</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">kargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">index_types</span><span class="p">):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">sigma</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="c1">#ensure masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Sigma should have been a column index or list of values&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isNone</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">))</span>
            <span class="n">scale_covar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">ydata</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">ydata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">xdata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="c1">#lmfit doesn&#39;t seem to work well with masked data - here we just delete masked points</span>
        <span class="n">xvar</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">independent_vars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">Parameters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span><span class="n">pp</span> <span class="ow">in</span> <span class="n">p0</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">set_param_hint</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">,</span><span class="n">vary</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">vary</span><span class="p">,</span><span class="nb">min</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">min</span><span class="p">,</span><span class="nb">max</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">max</span><span class="p">,</span><span class="n">expr</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">p0</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># We&#39;re working off parameter hints, but still need to set the independent var</span>
            <span class="n">p0</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">single_fit</span><span class="p">:</span>
            <span class="n">p0</span><span class="p">[</span><span class="n">xvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">xdata</span>

            <span class="n">ret_val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__lmfit_one</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">scale_covar</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="n">result</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span><span class="n">residuals</span><span class="o">=</span><span class="n">residuals</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># chi^2 mode</span>
            <span class="n">pn</span><span class="o">=</span><span class="n">p0</span>
            <span class="n">ret_val</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pn</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">pn_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pn</span><span class="p">):</span> <span class="c1"># iterate over every row in the supplied p0 values</span>
                <span class="n">pn_i</span><span class="o">=</span><span class="n">_lmfit_p0_dict</span><span class="p">(</span><span class="n">pn_i</span><span class="p">,</span><span class="n">model</span><span class="p">)</span>
                <span class="n">pn_i</span><span class="p">[</span><span class="n">xvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">xdata</span>
                <span class="n">ret_val</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__lmfit_one</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">scale_covar</span><span class="p">,</span><span class="n">sigma</span><span class="p">,</span><span class="n">pn_i</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret_val</span></div>


<div class="viewcode-block" id="AnalysisMixin.make_bins"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.make_bins">[docs]</a>    <span class="k">def</span> <span class="nf">make_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lin&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility method to generate bin boundaries and centres along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Column of data with X values</span>
<span class="sd">            bins (1d_)array or int or float): Number of bins (int) or width of bins (if float)</span>
<span class="sd">            mode (string): &quot;lin&quot; for linear binning, &quot;log&quot; for logarithmic binning.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bin_start (float): Override minimum bin value</span>
<span class="sd">            bin_stop (float): Override the maximum bin value</span>

<span class="sd">        Returns:</span>
<span class="sd">            bin_start,bin_stop,bin_centres (1D arrays): The locations of the bin</span>
<span class="sd">            boundaries and centres for each bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lin&quot;</span><span class="p">,</span><span class="s2">&quot;log&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode should be either  &#39;lin&#39; or &#39;log&#39; not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;bin_start&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;bin_start&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;bin_stop&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;bin_stop&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># Given a number of bins</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="n">xminl</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
                <span class="n">xmaxl</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmaxl</span> <span class="o">-</span> <span class="n">xminl</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span><span class="p">,</span> <span class="n">xmaxl</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmaxl</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_stop</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>  <span class="c1"># Given a bin with as a flot</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="n">bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span><span class="p">))</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">bins</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bin width must be between 0 ans 1 for log binning&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The start of the binning must be a positive value in log mode.&quot;</span><span class="p">)</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="n">xmin</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">xp</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">:</span>
                    <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
                    <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bins</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bins</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># Yser provided manuals bins</span>
            <span class="n">bin_start</span><span class="o">=</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bin_stop</span><span class="o">=</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startwith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="p">(</span><span class="n">bin_start</span><span class="o">+</span><span class="n">bin_stop</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="n">bin_centres</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span><span class="o">+</span><span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bin_stop</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bins must be either an integer or a float, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">bins</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to bin into more bins than there is data.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bin_start</span><span class="p">,</span> <span class="n">bin_stop</span><span class="p">,</span> <span class="n">bin_centres</span></div>

<div class="viewcode-block" id="AnalysisMixin.max"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find maximum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,int): (maximum value,row index of max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.mean"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find mean value of a data column.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            sigma (column index or array): The uncertainity noted for each value in the mean</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The mean of the data.</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Fix the row index when the bounds function is used - see note of :py:meth:`AnalysisMixin.max`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">column</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">all_type</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">_</span><span class="p">[</span><span class="s2">&quot;has_yerr&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">elif</span> <span class="n">_</span><span class="o">.</span><span class="n">has_yerr</span><span class="p">:</span>
            <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">]</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">has_yerr</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
            <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">1E-8</span><span class="p">)</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">error</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">result</span><span class="o">=</span><span class="p">(</span><span class="n">ydata</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">,</span><span class="n">error</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.min"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find minimum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,int): (minimum value,row index of min value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.multiply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span> <span class="o">/</span> <span class="n">adata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                                                      <span class="p">(</span><span class="n">e2data</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">adata</span> <span class="o">*</span> <span class="n">bdata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">*</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">*</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.normalise"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.normalise">[docs]</a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalise data columns by dividing through by a base column value.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (index): One or more target columns to normalise can be a string, integer or list of strings or integers.</span>
<span class="sd">                If None then the default &#39;y&#39; column is used.</span>
<span class="sd">            base (index): The column to normalise to, can be an integer or string. If None then the target column is normalised</span>
<span class="sd">                to the range (-1,+1) or (0,1) depending on whether the input is bipolar or not.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            replace (bool): Set True(default) to overwrite  the target data columns</span>
<span class="sd">            header (string or None): The new column header - default is target name(norm)</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

        <span class="n">target</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="o">+</span> <span class="s2">&quot;(norm)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">istuple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_range</span><span class="o">=</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="p">[:,</span><span class="n">t</span><span class="p">]),</span><span class="n">_np_</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="p">[:,</span><span class="n">t</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">istuple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
                    <span class="n">o_range</span><span class="o">=</span><span class="n">base</span>
                <span class="k">elif</span> <span class="n">i_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">i_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#range (-1,1)</span>
                    <span class="n">o_range</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">o_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">col</span><span class="o">=</span><span class="p">(((</span><span class="bp">self</span><span class="p">[:,</span><span class="n">t</span><span class="p">]</span><span class="o">-</span><span class="n">i_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">i_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">i_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">*</span><span class="p">(</span><span class="n">o_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">o_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">o_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">setas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="n">setas</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.odr"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.odr">[docs]</a>    <span class="k">def</span> <span class="nf">odr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wrapper around scipy.odr orthogonal distance regression fitting.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (scipy.odr.Model, lmfit.models.Model or callable): Tje model that describes the data. See below for more details.</span>
<span class="sd">            xcol (index or None): Columns to be used for the x  data for the fitting. If not givem defaults to the</span>
<span class="sd">                :py:attr:`Stoner.Core.DataFile.setas` x column</span>
<span class="sd">            ycol (index or None): Columns to be used for the  y data for the fitting. If not givem defaults to the</span>
<span class="sd">                :py:attr:`Stoner.Core.DataFile.setas` y column</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            p0 (list, tuple or array): A vector of initial parameter values to try.</span>
<span class="sd">            sigma_x (index): The index of the column with the x-error bars</span>
<span class="sd">            sigma_y (index): The index of the column with the x-error bars</span>
<span class="sd">            bounds (callable): A callable object that evaluates true if a row is to be included. Should be of the form f(x,y)</span>
<span class="sd">            result (bool): Determines whether the fitted data should be added into the DataFile object. If result is True then</span>
<span class="sd">                the last column will be used. If result is a string or an integer then it is used as a column index.</span>
<span class="sd">                Default to None for not adding fitted data</span>
<span class="sd">            replace (bool): Inidcatesa whether the fitted data replaces existing data or is inserted as a new column (default False)</span>
<span class="sd">            header (string or None): If this is a string then it is used as the name of the fitted data. (default None)</span>
<span class="sd">            output (str, default &quot;fit&quot;): Specifiy what to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The return value is determined by the *output* parameter. Options are</span>
<span class="sd">                - &quot;fit&quot;    just the :py:class:`scipy.odr.Output` instance (default)</span>
<span class="sd">                - &quot;row&quot;     just a one dimensional numpy array of the fit paraeters interleaved with their uncertainties</span>
<span class="sd">                - &quot;full&quot;    a tuple of the fit instance and the row.</span>
<span class="sd">                - &quot;data&quot;    a copy of the :py:class:`Stoner.Core.DataFile` object with the fit recorded in the emtadata and optinally</span>
<span class="sd">                    as a column of data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The function tries to make use of whatever model you give it. Specifically, it accepts:</span>

<span class="sd">                -   A subclass or an instance of :py:class:`scipy.odr.Model` : this is the native model type for the underlying scipy</span>
<span class="sd">                    odr package.</span>
<span class="sd">                -   A subclass or instance of an lmfit.models.Model: the :py:mod:`Stoner.Fit` module has a number of useful prebuilt</span>
<span class="sd">                    lmfit models that can be used directly</span>
<span class="sd">                    by this function.</span>
<span class="sd">                -   A callable function which should have a signature f(x,parameter1,parameter2...) and *not* the scip.odr stadnard f(beta,x)</span>

<span class="sd">            This function ois designed to be as compatible as possible with :py:meth:`AnalysisMixin.curve_fit` and</span>
<span class="sd">                :py:meth:`AnalysisMixin.lmfit` to facilitate easy of switching between them.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/odr_simple.py</span>
<span class="sd">                 :include-source:</span>
<span class="sd">                 :outname: odrfit1</span>


<span class="sd">        See Also:</span>
<span class="sd">            :py:meth:`AnalysisMixin.curve_fit`</span>
<span class="sd">            :py:meth:`AnalysisMixin.lmfit`</span>
<span class="sd">            User guide section :ref:`fitting_with_limits`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="n">_np_</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">residuals</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;residuals&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1">#First of all check for a sigma keyword</span>
        <span class="n">sigma</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1">#Now check for sigma_y and sigma_x and have them default to sigma (which in turn defaults to None)</span>
        <span class="n">sigma_y</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sigma_y&quot;</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">sigma_x</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sigma_x&quot;</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
        <span class="c1"># Support both absolute_sigma and scale_covar, but scale_covar wins here (c.f.curve_fit)</span>
        <span class="n">absolute_sigma</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;absolute_sigma&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;scale_covar&quot;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">absolute_sigma</span><span class="p">)</span>
        <span class="c1">#Support both asrow and output, the latter wins if both supplied</span>
        <span class="n">asrow</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;asrow&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span> <span class="k">if</span> <span class="n">asrow</span> <span class="k">else</span> <span class="s2">&quot;fit&quot;</span><span class="p">)</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prefix&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
            <span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">()</span>
            <span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">isclass</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">Model</span><span class="p">)</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="n">model</span><span class="o">=</span><span class="n">_odr_Model</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be an instance of lmfit.Model or a cllable function!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prefix</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="c1">#Get the inital guess if possible</span>
        <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;p0&quot;</span><span class="p">,</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="s2">&quot;p0&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>

        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">xerr</span><span class="o">=</span><span class="n">sigma_x</span><span class="p">,</span><span class="n">yerr</span><span class="o">=</span><span class="n">sigma_y</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">xdata</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">has_xerr</span><span class="p">:</span>
            <span class="n">sx</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sx</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xerr</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">has_yerr</span><span class="p">:</span>
            <span class="n">sy</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ydata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sy</span><span class="o">=</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">absolute_sigma</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">Data</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">wd</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">sx</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">we</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">sy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">RealData</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span><span class="n">ydata</span><span class="p">,</span><span class="n">sx</span><span class="o">=</span><span class="n">sx</span><span class="p">,</span><span class="n">sy</span><span class="o">=</span><span class="n">sy</span><span class="p">)</span>

        <span class="n">fit</span><span class="o">=</span><span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">ODR</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">model</span><span class="p">,</span><span class="n">beta0</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fit_result</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">OdrError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="n">_sp_</span><span class="o">.</span><span class="n">odr</span><span class="o">.</span><span class="n">OdrStop</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_curve_fit_result</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">fit_result</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">header</span><span class="p">,</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="p">,</span><span class="n">residuals</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>


        <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Store our current mask, calculate new column&#39;s mask and turn off mask</span>

        <span class="n">param_names</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="s2">&quot;param_names&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_names</span><span class="p">):</span>
            <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">fit_result</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">fit_result</span><span class="o">.</span><span class="n">sd_beta</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">delta</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="n">fit_result</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span><span class="n">fit_result</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">nfree</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">fit_result</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">chisq</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fit_result</span><span class="o">.</span><span class="n">xplus</span><span class="p">))</span><span class="o">+</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eps</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fit_result</span><span class="o">.</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="n">nfree</span>
        <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chisq</span><span class="p">)</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fit&quot;</span><span class="p">:(</span><span class="n">row</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">fit_result</span><span class="o">.</span><span class="n">cov_beta</span><span class="p">),</span><span class="s2">&quot;report&quot;</span><span class="p">:</span> <span class="n">fit_result</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">fit_result</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span><span class="s2">&quot;data&quot;</span><span class="p">:</span><span class="bp">self</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to recognise output format:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retval</span><span class="p">[</span><span class="n">output</span><span class="p">]</span></div>

<div class="viewcode-block" id="AnalysisMixin.outlier_detection"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.outlier_detection">[docs]</a>    <span class="k">def</span> <span class="nf">outlier_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">certainty</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to detect outliers in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column(column index), specifing column for outlier detection. If not set,</span>
<span class="sd">                defaults to the current y set column.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            window(int): data window for anomoly detection</span>
<span class="sd">            certainty(float): eg 3 detects data 3 standard deviations from average</span>
<span class="sd">            action(str or callable): what to do with outlying points, options are</span>
<span class="sd">                * &#39;mask&#39; outlier points are masked (default)</span>
<span class="sd">                * &#39;mask row&#39; outlier rows are masked</span>
<span class="sd">                * &#39;delete&#39;  outlier rows are deleted</span>
<span class="sd">                * callable  the value of the action keyword is called with the outlier row</span>
<span class="sd">                * anything else defaults to do nothing.</span>

<span class="sd">            width(odd integer): Number of rows that an outliing spike could occupy. Defaults to 1.</span>
<span class="sd">            func (callable): A function that determines if the current row is an outlier.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        outlier_detection will add row numbers of detected outliers to the metadata</span>
<span class="sd">        of d, also will perform action depending on request eg &#39;mask&#39;, &#39;delete&#39;</span>
<span class="sd">        (any other action defaults to doing nothing).</span>

<span class="sd">        The detection looks at a window of the data, takes the average and looks</span>
<span class="sd">        to see if the current data point falls certainty * std deviations away from</span>
<span class="sd">        data average.</span>

<span class="sd">        The outlier detection function has the signatrure::</span>

<span class="sd">            def outlier(row,column,window,certainity,**kargs)</span>
<span class="sd">                #code</span>
<span class="sd">                return True # or False</span>

<span class="sd">        All extra keyword arguments are passed to the outlier detector.</span>

<span class="sd">        IF *action* is a callable function then it should take the form of::</span>

<span class="sd">            def action(i,column,row):</span>
<span class="sd">                pass</span>

<span class="sd">        where *i* is the number of the outlier row, *column* the same value as above</span>
<span class="sd">        and *row* is the data for the row.</span>

<span class="sd">        In all cases the indices of the outlier rows are added to the ;outlier&#39; metadata.</span>

<span class="sd">        Example</span>
<span class="sd">            .. plot:: samples/outlier.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: outlier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_outlier</span>

        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>  <span class="c1">#going to be easier if this is an integer later on</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_centre</span><span class="o">=</span><span class="n">width</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">column</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">certainty</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s1">&#39;outliers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>  <span class="c1">#add outlier indecies to metadata</span>
        <span class="n">index</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>  <span class="c1">#Always reverse the index in case we&#39;re deleting rows in sucession</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">or</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;mask row&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;mask&#39;</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;delete&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>  <span class="c1"># this will call the action function with each row in turn from back to start</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">action</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.peaks"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.peaks">[docs]</a>    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locates peaks and/or troughs in a column of data by using SG-differentiation.</span>

<span class="sd">        Args:</span>
<span class="sd">            ycol (index): is the column name or index of the data in which to search for peaks</span>
<span class="sd">            width (float): is the expected minium halalf-width of a peak in terms of the number of data points.</span>
<span class="sd">                This is used in the differnetiation code to find local maxima. Bigger equals less sensitive</span>
<span class="sd">                to experimental noise, smaller means better eable to see sharp peaks</span>
<span class="sd">            poly (int): This is the order of polynomial to use when differentiating the data to locate a peak. Must &gt;=2, higher numbers</span>
<span class="sd">                will find sharper peaks more accurately but at the risk of finding more false positives.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            significance (float): is used to decide whether a local maxmima is a significant peak. Essentially just the curvature</span>
<span class="sd">                of the data. Bigger means less sensistive, smaller means more likely to detect noise.</span>
<span class="sd">            xcol (index or None): name or index of data column that p[rovides the x-coordinate (default None)</span>
<span class="sd">            peaks (bool): select whether to measure peaks in data (default True)</span>
<span class="sd">            troughs (bool): select whether to measure troughs in data (default False)</span>
<span class="sd">            sort (bool): Sor the results by significance of peak</span>
<span class="sd">            modify (book): If true, then the returned object is a copy of self with only the peaks/troughs left in the data.</span>
<span class="sd">            full_data (bool): If True (default) then all columns of the data at which peaks in the *ycol* column are found. *modify* true implies</span>
<span class="sd">                      *full_data* is also true. If *full_data* is False, then only the x-column values of the peaks are returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If *modify* is true, then returns a the AnalysisMixin with the data set to just the peaks/troughs. If *modify* is false (default),</span>
<span class="sd">            then the return value depends on *ycol* and *xcol*. If *ycol* is not None and *xcol* is None, then returns conplete rows of</span>
<span class="sd">            data corresponding to the found peaks/troughs. If *xcol* is not None, or *ycol* is None and *xcol* is None, then</span>
<span class="sd">            returns a 1D array of the x positions of the peaks/troughs.</span>

<span class="sd">        See Also:</span>
<span class="sd">            User guide section :ref:`peak_finding`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">peaks</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">troughs</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;troughs&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">poly</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sort</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">modify</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;modify&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">full_data</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;full_data&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span><span class="n">ycol</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span>
        <span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span>
        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">poly</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;poly must be at least 2nd order in peaks for checking for significance of peak or trough&quot;</span>
        <span class="n">setas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 2nd differential requires more smoothing</span>

        <span class="c1">#We&#39;re going to ignore the start and end of the arrays</span>
        <span class="n">index_offset</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">d1</span><span class="o">=</span><span class="n">d1</span><span class="p">[</span><span class="n">index_offset</span><span class="p">:</span><span class="o">-</span><span class="n">index_offset</span><span class="p">]</span>
        <span class="n">d2</span><span class="o">=</span><span class="n">d2</span><span class="p">[</span><span class="n">index_offset</span><span class="p">:</span><span class="o">-</span><span class="n">index_offset</span><span class="p">]</span>

        <span class="c1">#Set the significance from the 2nd ifferential if not already set</span>
        <span class="n">significance</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;significance&quot;</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">))</span><span class="o">/</span><span class="mf">20.0</span><span class="p">)</span> <span class="c1"># Base an apriori significance on max d2y/dx2 / 20</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">significance</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="c1"># integer significance is inverse to floating</span>
            <span class="n">significance</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">))</span><span class="o">/</span><span class="n">significance</span> <span class="c1"># Base an apriori significance on max d2y/dx2 / 20</span>

        <span class="n">d2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)),</span> <span class="n">d2</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
        <span class="c1"># Ensure we have some X-data</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">xdata</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>


        <span class="n">possible_peaks</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_threshold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">troughs</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">peaks</span><span class="p">))</span>
        <span class="n">curvature</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2_interp</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">))</span>

        <span class="c1"># Filter just the significant peaks</span>
        <span class="n">possible_peaks</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">curvature</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">&gt;</span><span class="n">significance</span><span class="p">])</span>
        <span class="c1"># Sort in order of significance</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">possible_peaks</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2_interp</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">))))</span>

        <span class="n">xdat</span><span class="o">=</span><span class="n">xdata</span><span class="p">(</span><span class="n">possible_peaks</span><span class="o">+</span><span class="n">index_offset</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modify</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">elif</span> <span class="n">full_data</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">xdat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="n">setas</span>
        <span class="c1"># Return - but remembering to add back on the offset that we took off due to differentials not working at start and end</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.polyfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.polyfit">[docs]</a>    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pass through to numpy.polyfit.</span>

<span class="sd">            Args:</span>
<span class="sd">                xcol (index): Index to the column in the data with the X data in it</span>
<span class="sd">                ycol (index): Index to the column int he data with the Y data in it</span>
<span class="sd">                polynomial_order: Order of polynomial to fit (default 2)</span>
<span class="sd">                bounds (callable): A function that evaluates True if the current row should be included in the fit</span>
<span class="sd">                result (index or None): Add the fitted data to the current data object in a new column (default don&#39;t add)</span>
<span class="sd">                replace (bool): Overwrite or insert new data if result is not None (default False)</span>
<span class="sd">                header (string or None): Name of column_header of replacement data. Default is construct a string from the y column headser and polynomial order.</span>

<span class="sd">            Returns:</span>
<span class="sd">                numpy.poly: The best fit polynomial as a numpy.poly object.</span>

<span class="sd">            Note:</span>
<span class="sd">                If the x or y columns are not specified (or are None) the the setas attribute is used instead.</span>

<span class="sd">                This method is depricated and may be removed in a future version in favour of the more general curve_fit</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="k">import</span> <span class="n">ordinal</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="o">=</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
        <span class="n">p</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">),</span><span class="n">polynomial_order</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ycol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)],</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span> <span class="n">polynomial_order</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;Fitted </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> order polynomial&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span>
                                                                         <span class="n">ordinal</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-order polyfit coefficients&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ordinal</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">))]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="AnalysisMixin.scale"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale the x and y data in this DataFile to match the x and y data in another DataFile.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DataFile): The other isntance of a datafile to match to</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index): Column with x points in it, default to None to use setas attribute value</span>
<span class="sd">            ycol (column index): Column with ypoints in it, default to None to use setas attribute value</span>
<span class="sd">            xmode (&#39;affine&#39;, &#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;): How to manipulate the x-data to match up</span>
<span class="sd">            ymode (&#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;): How to manipulate the y-data to match up.</span>
<span class="sd">            bounds (callable): Used to identiyf the set of (x,y) points to be used for scaling. Defaults to the whole data set if not speicifed.</span>
<span class="sd">            otherbounds (callable): Used to detemrine the set of (x,y) points in the other data file. Defaults to bounds if not given.</span>
<span class="sd">            use_estimate (bool or 3x2 array): Specifies whether to estimate an initial transformation value or to use the provided one, or</span>
<span class="sd">                start with an identity transformation.</span>
<span class="sd">            replace (bool): Whether to map the x,y data to the new co-ordinates and return a copy of this AnalysisMixin (true) or to just return</span>
<span class="sd">                the results of the scaling.</span>
<span class="sd">            headers (2-element list or tuple of strings): new column headers to use if replace is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a copy of the AnalysisMixin modified so that the x and y columns match *other* if *replace* is True, or</span>
<span class="sd">            *opt_trans*,*trans_err*,*new_xy_data*. Where *opt_trans* is the optimum affine transformation, *trans_err* is a matrix</span>
<span class="sd">            giving the standard error in the transformation matrix components and  *new_xy_data* is an (n x 2) array of the transformed data.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/scale_curves.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: scale</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Sort out keyword srguments</span>
        <span class="c1">#</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">:</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">otherbounds</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;otherbounds&quot;</span><span class="p">,</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">headers</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;headers&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">xmode</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xmode&quot;</span><span class="p">,</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="n">ymode</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ymode&quot;</span><span class="p">,</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="n">use_estimate</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_estimate&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get our working data from this DataFile and remove masked rows</span>

        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>

        <span class="c1"># Get data from the other. If it is already an ndarray, check size and dimensions</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">):</span>
            <span class="n">working2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">otherbounds</span><span class="p">)</span>
            <span class="n">working2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">xdat2</span> <span class="o">=</span> <span class="n">working2</span><span class="p">[:,</span> <span class="n">other</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
            <span class="n">ydat2</span> <span class="o">=</span> <span class="n">working2</span><span class="p">[:,</span> <span class="n">other</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat2</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Data lengths don&#39;t match </span><span class="si">{}</span><span class="s2">!=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat2</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">other</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">1</span><span class="o">&lt;=</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">((</span><span class="s2">&quot;If other is a numpy array it must be the same length as the number of points to match &quot;</span><span class="o">+</span>
                                    <span class="s2">&quot;to and 1 or 2 columns. (other shape=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xdat2</span><span class="o">=</span><span class="n">xdat</span>
                <span class="n">ydat2</span><span class="o">=</span><span class="n">other</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdat2</span><span class="o">=</span><span class="n">other</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ydat2</span><span class="o">=</span><span class="n">other</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;other should be either a numpy array or subclass of DataFile, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>


        <span class="c1"># Need two nx2 arrays of points now</span>

        <span class="n">xy1</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xdat</span><span class="p">,</span><span class="n">ydat</span><span class="p">))</span>
        <span class="n">xy2</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xdat2</span><span class="p">,</span><span class="n">ydat2</span><span class="p">))</span>

        <span class="c1"># We&#39;re going to use three points to get an estimate for the affine transform to apply</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_estimate</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_estimate</span><span class="p">:</span>
            <span class="n">mid</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">try</span><span class="p">:</span> <span class="c1"># may go wrong if three points are co-linear</span>
                <span class="n">m0</span><span class="o">=</span><span class="n">GetAffineTransform</span><span class="p">(</span><span class="n">xy1</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:],</span><span class="n">xy2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],:])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="c1"># So use an idnetify transformation instead</span>
                <span class="n">m0</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_estimate</span><span class="p">,</span><span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_estimate</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="c1">#use_estimate is an initial value transformation</span>
            <span class="n">m0</span><span class="o">=</span><span class="n">use_estimate</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Don&#39;t try to be clever</span>
            <span class="n">m0</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]])</span>
        <span class="n">popt</span><span class="p">,</span><span class="n">perr</span><span class="p">,</span><span class="n">trans</span><span class="o">=</span><span class="n">_twoD_fit</span><span class="p">(</span><span class="n">xy1</span><span class="p">,</span><span class="n">xy2</span><span class="p">,</span><span class="n">xmode</span><span class="o">=</span><span class="n">xmode</span><span class="p">,</span><span class="n">ymode</span><span class="o">=</span><span class="n">ymode</span><span class="p">,</span><span class="n">m0</span><span class="o">=</span><span class="n">m0</span><span class="p">)</span>
        <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]]</span>
        <span class="n">new_data</span><span class="o">=</span><span class="n">trans</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span> <span class="c1"># In place scaling, replace and return self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;Transform&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;Transform Err&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">perr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">=</span><span class="n">new_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span><span class="o">=</span><span class="n">new_data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">headers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span><span class="o">=</span><span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span><span class="o">=</span><span class="n">headers</span><span class="p">[</span><span class="mi">1</span>
            <span class="p">]</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Return results but don&#39;t change self.</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">popt</span><span class="p">,</span><span class="n">perr</span><span class="p">,</span><span class="n">new_data</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.smooth"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Smooth data by convoluting with a window.</span>

<span class="sd">        Args:</span>
<span class="sd">            window (string or tuple): Defines the window type to use by passing to :py:func:`scipy.signal.get_window`.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol(column index or None): Data to use as x data if needed to define a window. If None, use :py:attr:`Stoner.Core.DataFile.setas`</span>
<span class="sd">            ycvol (column index or None): Data to be smoothed</span>
<span class="sd">            size (int or float): If int, then the number of points to use in the smoothing window. If float, then the size in x-data to be used.</span>
<span class="sd">            result (bool or column index): Whether to add the smoothed data to the dataset and if so where.</span>
<span class="sd">            replace (bool): Replace the exiting data or insert as a new column.</span>
<span class="sd">            header (string): New column header for the new data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (self or array): If result is False, then the return value will be a copy of the smoothed data, otherwise the return value</span>
<span class="sd">            is a copy of the AnalysisMixin object with the smoothed data added,</span>

<span class="sd">        Notes:</span>
<span class="sd">            If size is float, then it is necessary to map the X-data to a number of rows and to ensure that the data is evenly spaced in x.</span>
<span class="sd">            To do this, the number of rows in the window is found by dividing the span in x by the size and multiplying by the total</span>
<span class="sd">            lenfth. Then the data is interpolated to a new set of evenly space X over the same range, smoothed and then interpoalted back</span>
<span class="sd">            to the original x values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># overwirte existing y column data</span>
        <span class="n">header</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>


        <span class="c1">#Sort out window size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">interp_data</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">xl</span><span class="p">,</span><span class="n">xh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span>
            <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">size</span><span class="o">/</span><span class="p">(</span><span class="n">xh</span><span class="o">-</span><span class="n">xl</span><span class="p">))</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="n">nx</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span><span class="n">xh</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Smoothing window size&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">size</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">int_types</span><span class="p">):</span>
            <span class="n">data</span><span class="o">=</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">interp_data</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size should either be a float or integer, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)))</span>

        <span class="n">window</span><span class="o">=</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Handle multiple or single y columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="o">=</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>

        <span class="c1">#Do the convolution itself</span>
        <span class="k">for</span> <span class="n">yc</span> <span class="ow">in</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[:,</span><span class="n">yc</span><span class="p">]</span><span class="o">=</span><span class="n">convolve</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">yc</span><span class="p">],</span><span class="n">window</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span><span class="o">/</span><span class="n">size</span>


        <span class="c1"># Reinterpolate the smoothed data back if necessary</span>
        <span class="k">if</span> <span class="n">interp_data</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span>
            <span class="n">tmp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">data</span>
            <span class="n">data</span><span class="o">=</span><span class="n">tmp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#Fix return value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[:,</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">yc</span> <span class="ow">in</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">yc</span><span class="p">],</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.span"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of the maximum and minumum values within the given column and bounds by calling into :py:meth:`AnalysisMixin.max` and :py:meth:`AnalysisMixin.min`.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,float): A tuple of (min value, max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnalysisMixin.spline"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.spline">[docs]</a>    <span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a spline through x and y data and replace, add new data or return spline function.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index): Column with x data or if None, use setas attribute.</span>
<span class="sd">            ycol (column index): Column with y data or if None, use the setas attribute</span>
<span class="sd">            sigma (column index, or array of data): Column with weights, or if None use the 1/yerr column.</span>
<span class="sd">            replace (Boolean or column index or None): If True then the y-column data is repalced, if a column index then the</span>
<span class="sd">                new data is added after the specified index, if False then the new y-data is returned and if None, then</span>
<span class="sd">                spline object is returned.</span>
<span class="sd">            header (string): If *replace* is True or a column index then use this string as the new column header.</span>
<span class="sd">            order (int): The order of spline to use (1-5)</span>
<span class="sd">            smoothing (float or None): The smoothing factor to use when fitting the spline. A value of zero will create an</span>
<span class="sd">                interpolating spline.</span>
<span class="sd">            bbox (tuple of length 2): Bounding box for the spline - defaults to range of x values</span>
<span class="sd">            ext (int or str): How to extrapolate, default is &quot;extrapolate&quot;, but can also be &quot;raise&quot;,&quot;zeros&quot; or &quot;const&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Depending on the value of *replace*, returns a copy of the AnalysisMixin, a 1D numpy array of data or an</span>
<span class="sd">            scipy.interpolate.UniverateSpline object.</span>

<span class="sd">        This is really jsut a pass through to the scipy.interpolate.UnivariateSpline function. Also used in the extrapolate</span>
<span class="sd">        function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isNone</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isNone</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">):</span>
                <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">//</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">replace</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">header</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">k</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">s</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;smoothing&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">bbox</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bbox&quot;</span><span class="p">,[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ext</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ext&quot;</span><span class="p">,</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">//</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span>
        <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">//</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">spline</span><span class="o">=</span><span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">w</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span><span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
        <span class="n">new_y</span><span class="o">=</span><span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replace</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">new_y</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">=</span><span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">new_y</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replace</span><span class="p">,</span><span class="n">index_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">new_y</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span><span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">=</span><span class="bp">self</span>
        <span class="k">elif</span> <span class="n">replace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">spline</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;replace should be column index, boolean or None&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.stitch"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.stitch">[docs]</a>    <span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_overlap</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a scaling to this data set to make it stich to another dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DataFile): Another data set that is used as the base to stitch this one on to</span>
<span class="sd">            xcol,ycol (index or None): The x and y data columns. If left as None then the current setas attribute is used.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            overlap (tuple of (lower,higher) or None): The band of x values that are used in both data sets to match,</span>
<span class="sd">                if left as None, thenthe common overlap of the x data is used.</span>
<span class="sd">            min_overlap (float): If you know that overlap must be bigger than a certain amount, the bounds between the two</span>
<span class="sd">                data sets needs to be adjusted. In this case min_overlap shifts the boundary of the overlap on this DataFile.</span>
<span class="sd">            mode (str): Unless *func* is specified, controls which parameters are actually variable, defaults to all of them.</span>
<span class="sd">            func (callable): a stitching function that transforms :math:`(x,y)\rightarrow(x&#39;,y&#39;)`. Default is to use</span>
<span class="sd">                functions defined by *mode*</span>
<span class="sd">            p0 (iterable): if func is not None then p0 should be the starting values for the stitching function parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: A copy of the current :py:class:`AnalysisMixin` with the x and y data columns adjusted to stitch</span>

<span class="sd">        To stitch the data together, the x and y data in the current data file is transforms so that</span>
<span class="sd">        :math:`x&#39;=x+A` and :math:`y&#39;=By+C` where :math:`A,B,C` are constants and :math:`(x&#39;,y&#39;)` are close matches to the</span>
<span class="sd">        :math:`(x,y)` data in *other*. The algorithm assumes that the overlap region contains equal</span>
<span class="sd">        numbers of :math:`(x,y)` points *mode* controls whether A,B, and C are fixed or adjustable</span>

<span class="sd">            - &quot;All&quot; - all three parameters adjustable</span>
<span class="sd">            - &quot;Scale y, shift x&quot; - C is fixed at 0.0</span>
<span class="sd">            - &quot;Scale and shift y&quot; A is fixed at 0.0</span>
<span class="sd">            - &quot;Scale y&quot; - only B is adjustable</span>
<span class="sd">            - &quot;Shift y&quot; - Only c is adjsutable</span>
<span class="sd">            - &quot;Shift x&quot; - Only A is adjustable</span>
<span class="sd">            - &quot;Shift both&quot; - B is fixed at 1.0</span>

<span class="sd">        See Also:</span>
<span class="sd">            User Guide section :ref:`stitch_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),:]</span>
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min_overlap</span>
        <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),:]</span>
        <span class="n">self_second</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Calculate the overlap</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">overlap</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">overlap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="ow">and</span>
                                                                             <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">inrange</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="p">,</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">inrange</span><span class="p">]</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
            <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="o">-</span><span class="n">num_pts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_pts</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;scale y and shift x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">*</span> <span class="n">y</span><span class="p">)),</span>
                <span class="s2">&quot;scale and shift y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;scale y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>
                <span class="s2">&quot;shift y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;shift both&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C</span><span class="p">))</span>
            <span class="p">}</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;scale y,shift x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;scale and shift y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;scale y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;shift y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;shift both&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">A0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">C0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">B0</span> <span class="o">=</span> <span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">yp</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">C0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;mode keyword should be a string if func is not defined&quot;</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">,</span> <span class="s2">&quot;mode keyword should be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="n">mode</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="s2">&quot;Keyword func should be callable if given&quot;</span>
            <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span> <span class="o">=</span> <span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># pylint: disable=W1505</span>
            <span class="k">assert</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="s2">&quot;Keyword parameter p0 shoiuld be iterable if keyword func is given&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Keyword p0 should be the same length as the optional arguments to func&quot;</span>
        <span class="c1"># This is a bit of a hack, we turn (x,y) points into a 1D array of x and then y data</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">),</span> <span class="s2">&quot;The number of points in the overlap are different in the two data sets&quot;</span>

        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Wrapper function to fit for transform.&quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">set1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">set1</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>  <span class="c1"># Curve fit for optimal A,B,C</span>
        <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">],</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Coeffient Errors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">perr</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching overlap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Window&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_pts</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.subtract"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.subtract">[docs]</a>    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract one column, number or array (b) from another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1">#Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.threshold"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.threshold">[docs]</a>    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds partial indices where the data in column passes the threshold, rising or falling.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (float): Value to look for in column col</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            col (index): Column index to look for data in</span>
<span class="sd">            rising (bool):  look for case where the data is increasing in value (defaukt True)</span>
<span class="sd">            falling (bool): look for case where data is fallinh in value (default False)</span>
<span class="sd">            xcol (index, bool or None): rather than returning a fractional row index, return the</span>
<span class="sd">                interpolated value in column xcol. If xcol is False, then return a complete row</span>
<span class="sd">                all_vals (bool): return all crossing points of the threshold or just the first. (default False)</span>
<span class="sd">            transpose (bbool): Swap the x and y columns around - this is most useful when the column assignments</span>
<span class="sd">                have been done via the setas attribute</span>
<span class="sd">            all_vals (bool): Return all values that match the criteria, or just the first in the file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Either a sing;le fractional row index, or an in terpolated x value</span>

<span class="sd">        Note:</span>
<span class="sd">            If you don&#39;t sepcify a col value or set it to None, then the assigned columns via the</span>
<span class="sd">            :py:attr:`DataFile.setas` attribute will be used.</span>

<span class="sd">        Warning:</span>
<span class="sd">            There has been an API change. Versions prior to 0.1.9 placed the column before the threshold in the positional</span>
<span class="sd">            argument list. In order to support the use of assigned columns, this has been swapped to the present order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DataArray</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">col</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">rising</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rising&quot;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">falling</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;falling&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">all_vals</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;all_vals&quot;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1">#Recursively call if we&#39;ve got an iterable threshold</span>
        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">th</span><span class="p">,</span><span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span><span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span><span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">,</span><span class="n">all_vals</span><span class="o">=</span><span class="n">all_vals</span><span class="p">))</span>
            <span class="c1">#Now we have to clean up the  retujrn list into a DataArray</span>
            <span class="n">retval</span><span class="o">=</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">DataArray</span><span class="p">):</span> <span class="c1"># if xcol was False we got a complete row back</span>
                <span class="n">setas</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
                <span class="n">ch</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">column_headers</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="n">setas</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">column_headers</span><span class="o">=</span><span class="n">ch</span>
                <span class="n">retval</span><span class="o">.</span><span class="n">i</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">i</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#Either xcol was None so we got indices or we got a specified column back</span>
                <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Specific column</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">column_headers</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]]</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">i</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="s2">&quot;x&quot;</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">isrow</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">column_headers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span>
                    <span class="n">retval</span><span class="o">.</span><span class="n">isrow</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">return</span> <span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_vals</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">setas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">i</span><span class="o">=</span><span class="n">ret</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">retval</span>
        <span class="k">elif</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
            <span class="c1">#if retval.ndim&gt;0:   #not sure what this bit does but it&#39;s throwing errors for a simple threshold</span>
                <span class="c1">#retval.setas=self.setas.clone</span>
                <span class="c1">#retval.setas.shape=retval.shape</span>
                <span class="c1">#retval.i=ret</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">=</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_vals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">DataArray</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">isrow</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">return</span> <span class="n">ret</span></div></div>

<span class="k">def</span> <span class="nf">AnalyseFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Issue a warning and then create a class anyway.&quot;&quot;&quot;</span>
    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;AnalyseFile is deprecated in favour of Stoner.Data or the AnalysisMixin&quot;</span><span class="p">,</span><span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">Stoner.Core</span> <span class="k">as</span> <span class="nn">_SC_</span>

    <span class="k">class</span> <span class="nc">AnalyseFile</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span><span class="n">_SC_</span><span class="o">.</span><span class="n">DataFile</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;:py:class:`Stoner.Analysis.AnalyseFile` extends :py:class:`Stoner.Core.DataFile` with numpy and scipy passthrough functions.</span>

<span class="sd">        Note:</span>
<span class="sd">            There is no separate constructor for this class - it inherits from DataFile</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">AnalyseFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/StonerLogo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Stoner Package</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li>
      <li>
        <a href="../Stoner.html">Stoner</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2013-15, Gavin Burnell et al.Last updated on Jun 30, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.7.4
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>