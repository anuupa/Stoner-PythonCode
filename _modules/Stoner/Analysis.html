
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Stoner.Analysis &#8212; Stoner Pacakge API Documentation</title>
    <link rel="stylesheet" href="../../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../../index.html ">
        Stoner Pacakge API Documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Stoner Package</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li>
      <li>
        <a href="../Stoner.html">Stoner</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Stoner.Analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Stoner .Analysis provides a subclass of :class:`.Data` that has extra analysis routines builtin.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AnalysisMixin&quot;</span><span class="p">,</span> <span class="s2">&quot;GetAffineTransform&quot;</span><span class="p">,</span> <span class="s2">&quot;ApplyAffineTransform&quot;</span><span class="p">]</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np_</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">cumtrapz</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">get_window</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span><span class="p">,</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">curve_fit</span><span class="p">,</span> <span class="n">newton</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">savgol_filter</span>

<span class="kn">from</span> <span class="nn">.compat</span> <span class="k">import</span> <span class="n">python_v3</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">int_types</span><span class="p">,</span> <span class="n">index_types</span><span class="p">,</span> <span class="n">LooseVersion</span><span class="p">,</span> <span class="n">get_func_params</span>
<span class="kn">from</span> <span class="nn">.tools</span> <span class="k">import</span> <span class="n">isNone</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">all_type</span><span class="p">,</span> <span class="n">istuple</span>

<span class="k">try</span><span class="p">:</span>  <span class="c1"># Allow lmfit to be optional</span>
    <span class="kn">import</span> <span class="nn">lmfit</span>

    <span class="k">if</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="n">lmfit</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="s2">&quot;0.9.0&quot;</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">lmfit.model</span> <span class="k">import</span> <span class="n">Model</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">lmfit.model</span> <span class="k">import</span> <span class="n">Model</span>
    <span class="kn">from</span> <span class="nn">lmfit</span> <span class="k">import</span> <span class="n">Parameters</span>

    <span class="n">_lmfit</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Model</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">Parameters</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_lmfit</span> <span class="o">=</span> <span class="kc">False</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span> <span class="k">as</span> <span class="n">copy</span>

<span class="c1"># from matplotlib.pylab import * #Surely not?</span>
<span class="k">if</span> <span class="n">python_v3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getfullargspec</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">getargspec</span> <span class="k">as</span> <span class="n">getfullargspec</span>


<span class="c1"># ==========================================================================================================================================</span>
<span class="c1"># Module Private Functions</span>
<span class="c1"># ==========================================================================================================================================</span>


<span class="k">def</span> <span class="nf">_outlier</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal function for outlier detector.</span>

<span class="sd">    Calculates if the current row is an outlier from the surrounding data by looking</span>
<span class="sd">    at the number of standard deviations away from the average of the window it is.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">av</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">])</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">window</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">])</span>  <span class="c1"># standard deviation</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">ycol</span><span class="p">]</span> <span class="o">-</span> <span class="n">av</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">metric</span> <span class="o">*</span> <span class="n">std</span>


<span class="k">def</span> <span class="nf">_threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal function that implements the threshold method - also used in peak-finder</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold (float): Threshold valuye in data to look for</span>
<span class="sd">        rising (bool): Find points where data is rising up past threshold</span>
<span class="sd">        falling (bool): Find points where data is falling below the threshold</span>

<span class="sd">    Returns:</span>
<span class="sd">        A numpy array of fractional indices where the data has crossed the threshold assuming a</span>
<span class="sd">        straight line interpolation between two points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First we find all points where we cross zero in the correct direction</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
    <span class="n">sdat</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">rising</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">falling</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">falling</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rising</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">False</span>

    <span class="c1"># Now we refine the estimate of zero crossing with a cubic interpolation</span>
    <span class="c1"># and use Newton&#39;s root finding method to locate the zero in the interpolated data</span>

    <span class="n">intr</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sdat</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>  <span class="c1"># There&#39;s a root somewhere here !</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newton</span><span class="p">(</span><span class="n">intr</span><span class="p">,</span> <span class="n">ix</span><span class="p">))</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">):</span>  <span class="c1"># fell off the end here</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_twoD_fit</span><span class="p">(</span><span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="p">,</span> <span class="n">xmode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">ymode</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">m0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculae an optimal transformation of points :math:`(x_1,y_1)\rightarrow(x_2,y_2)`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        xy1 ( (n,2) array of float): Set of points to be mapped from.</span>
<span class="sd">        xy2 ( (n,2) array of floats): Set of points to be mapped to.</span>

<span class="sd">    Keyword Arguments:</span>
<span class="sd">        xmode (&#39;affine&#39;, &#39;linear&#39;, &#39;scale&#39; &#39;offset&#39; or &#39;fixed&#39;): How to manipulate the x-data</span>
<span class="sd">        ymode (&#39;linear&#39;, &#39;scale&#39; &#39;offset&#39; or &#39;fixed&#39;): How to manipulate the y-data</span>
<span class="sd">        m0 (3x2 array): Initial and fixed values of the transformation. Defaults to using an identity transformation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        opt_trans,trans_err,mapping func</span>

<span class="sd">    The most general case is an affine transform which includes rotation, scale, translation and skew. This is represented as a 2 x 3 matrix</span>
<span class="sd">    of coordinates. The *xmode* and *ymode* parameters control the possible operations to align the data in x and y directions, in addition</span>
<span class="sd">    to which the *xmode* parameter can take the value &#39;affine&#39; which allows a full affine transformation. The returned values are the</span>
<span class="sd">    affine transformation matrix, the uncertainities in this and a function to map co-ordinates with the optimal affine transformation.</span>

<span class="sd">    Note:</span>
<span class="sd">        *m0* combines both giving an initial value and fixed values for the transformation. If *m0* is set, then it is used to provide initial</span>
<span class="sd">        balues of the free parameters. Which elelemnts of *m0* that are free parameters and which are fixed is determined by the *xmode*</span>
<span class="sd">        and *ymode* parameters. IF *xmode* and *ymode* are both fixed, however, no scaling is done at all.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">xy1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">xy2</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">xy1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;co-ordinate arrays must be equal length with two columns, not </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xy1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">xy2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">xvarp</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
        <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="s2">&quot;fixed&quot;</span><span class="p">:</span> <span class="p">[[]],</span>
    <span class="p">}</span>
    <span class="n">yvarp</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span> <span class="p">[[]]}</span>

    <span class="k">if</span> <span class="n">xmode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xvarp</span> <span class="ow">or</span> <span class="n">ymode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yvarp</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;xmode and ymode must be one of &#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;,&#39;fixed&#39; not </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xmode</span><span class="p">,</span> <span class="n">ymode</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">xmode</span> <span class="o">==</span> <span class="s2">&quot;affine&quot;</span><span class="p">:</span>
        <span class="n">ymode</span> <span class="o">=</span> <span class="s2">&quot;fixed&quot;</span>

    <span class="n">xunknowns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvarp</span><span class="p">[</span><span class="n">xmode</span><span class="p">])</span>
    <span class="n">yunknowns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yvarp</span><span class="p">[</span><span class="n">ymode</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">xunknowns</span> <span class="o">+</span> <span class="n">yunknowns</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># shortcircuit for the trivial case</span>
        <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="n">xvarp</span><span class="p">[</span><span class="n">xmode</span><span class="p">]</span> <span class="o">+</span> <span class="n">yvarp</span><span class="p">[</span><span class="n">ymode</span><span class="p">]</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mapping</span> <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="p">[]]</span>  <span class="c1"># remove empty mappings</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">m0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">p0s</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;affine&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;offset&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">p0s</span><span class="p">[</span><span class="n">xmode</span><span class="p">]</span> <span class="o">+</span> <span class="n">p0s</span><span class="p">[</span><span class="n">ymode</span><span class="p">]</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.00</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m0</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m0</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
            <span class="n">default</span> <span class="o">=</span> <span class="n">m0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;m0 starting matrix should be a numpy array of size (2,3) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m0</span><span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>  <span class="c1"># Construct the fitting function</span>
        <span class="sd">&quot;&quot;&quot;Fitting function to find the transfoprm.&quot;&quot;&quot;</span>
        <span class="n">xy1</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xy</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xy2</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
            <span class="n">default</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span>
        <span class="n">xyt</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">xy1</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">xy2</span> <span class="o">-</span> <span class="n">xyt</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>
    <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>

    <span class="c1"># Initialise the return values</span>
    <span class="n">default</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.00</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="n">default</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span>
    <span class="n">default_err</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perr</span><span class="p">,</span> <span class="n">mapping</span><span class="p">):</span>
        <span class="n">default_err</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">xy</span><span class="p">:</span> <span class="n">ApplyAffineTransform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">default_err</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>


<div class="viewcode-block" id="ApplyAffineTransform"><a class="viewcode-back" href="../../classes/Stoner.Analysis.ApplyAffineTransform.html#Stoner.Analysis.ApplyAffineTransform">[docs]</a><span class="k">def</span> <span class="nf">ApplyAffineTransform</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a given afffine transform to a set of xy data points.&quot;&quot;&quot;</span>
    <span class="n">xyt</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">row_stack</span><span class="p">((</span><span class="n">xy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">))))</span>
    <span class="n">xyt</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">xyt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xyt</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="GetAffineTransform"><a class="viewcode-back" href="../../classes/Stoner.Analysis.GetAffineTransform.html#Stoner.Analysis.GetAffineTransform">[docs]</a><span class="k">def</span> <span class="nf">GetAffineTransform</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate an affine transofrm from 2 sets of three points.</span>

<span class="sd">    Args:</span>
<span class="sd">        p (3x2 array): Coordinates of points to transform from.</span>
<span class="sd">        pd (3x2 array): Cooridinates of points to transform to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        2x3 matrix representing the affine transform.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must supply three points&quot;</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transform</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">_poly_outlier</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternative outlier detection function that fits a polynomial locally over the window.</span>

<span class="sd">    Args:</span>
<span class="sd">        row (1D array): Current row of data</span>
<span class="sd">        column int): Column index of y values to examine</span>
<span class="sd">        window (2D array): Local window of data</span>

<span class="sd">    Keyyword Arguments:</span>
<span class="sd">        metric (float): Some measure of how sensitive the dection should be</span>
<span class="sd">        xcol (column index): Column of data to use for X values. Defaults to current setas value</span>
<span class="sd">        order (int): Order of polynomial to fit. Must be &lt; length of window-1</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if current row is an outlier</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order should be smaller than the window length. </span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">window</span><span class="p">[:,</span> <span class="n">xcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="n">xcol</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">window</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">yerr</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">window</span><span class="p">[:,</span> <span class="n">yerr</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pval</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pval</span> <span class="o">-</span> <span class="n">row</span><span class="p">[</span><span class="n">ycol</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">metric</span> <span class="o">*</span> <span class="n">perr</span>


<div class="viewcode-block" id="AnalysisMixin"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin">[docs]</a><span class="k">class</span> <span class="nc">AnalysisMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A mixin calss designed to work with :py:class:`Stoner.Core.DataFile` to provide additional analysis methods.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just call super.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done AnlaysisMixin init&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AnalysisMixin.SG_Filter"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.SG_Filter">[docs]</a>    <span class="k">def</span> <span class="nf">SG_Filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Savitsky-Golay filtering of data for smoothing and differentiating data.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (index): Column of Data to be filtered. if None, first y-column in setas is filtered.</span>
<span class="sd">            points (int): Number of data points to use in the filtering window. Should be an odd number &gt; poly+1 (default 15)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (coilumn index)@ If *order*&gt;1 then can be used to specify an x-column to differentiate with respect to.</span>
<span class="sd">            poly (int): Order of polynomial to fit to the data. Must be equal or greater than order (default 1)</span>
<span class="sd">            order (int): Order of differentiation to carry out. Default=0 meaning smooth the data only.</span>
<span class="sd">            pad (bool or float): Pad the start and end of the array with the mean value (True, default) or specired value (float) or leave as is.</span>
<span class="sd">            result (None,True, or column_index): If not None, column index to insert new data, or True to append as last column</span>
<span class="sd">            header (string or None): Header for new column if result is not None. If header is Nne, a suitable column header is generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpoy array or self): If result is None, a numpy array representing the smoothed or differentiated data is returned.</span>
<span class="sd">            Otherwise, a copy of the modified AnalysisMixin object is returned.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If col is not specified or is None then the :py:attr:`DataFile.setas` column assignments are used</span>
<span class="sd">            to set an x and y column. If col is a tuple, then it is assumed to secify and x-column and y-column</span>
<span class="sd">            for differentiating data. This is now a pass through to :py:func:`scipy.signal.savgol_filter`</span>

<span class="sd">            Padding can help stop wildly wrong artefacts in the data at the start and enf of the data, particularly when the differntial order is &gt;1.</span>

<span class="sd">        See Also:</span>
<span class="sd">            User guide section :ref:`smoothing_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="k">import</span> <span class="n">ordinal</span>

        <span class="n">points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Ensure window length is odd</span>
            <span class="n">points</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span> <span class="o">+</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">row_stack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="n">ddata</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;interp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pad</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">points</span> <span class="o">*</span> <span class="n">order</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">padv</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ddata</span><span class="p">[:,</span> <span class="n">offset</span><span class="p">:</span><span class="o">-</span><span class="n">offset</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ddata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">padv</span><span class="p">):</span>
                <span class="n">pad</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">*=</span> <span class="n">v</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">points</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">pad</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ddata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="p">))</span> <span class="o">*</span> <span class="n">pad</span>

        <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span> <span class="ow">and</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ddata</span><span class="p">[:,</span> <span class="p">:</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">pad</span>
            <span class="n">ddata</span><span class="p">[:,</span> <span class="o">-</span><span class="n">offset</span><span class="p">:]</span> <span class="o">=</span> <span class="n">pad</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ddata</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ddata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ddata</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">col</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> after </span><span class="si">{}</span><span class="s2"> order Savitsky-Golay Filter&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">column</span><span class="p">],</span> <span class="n">ordinal</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">head</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">header</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">header</span><span class="o">=</span><span class="n">head</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span></div>

    <span class="k">def</span> <span class="nf">__get_math_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility routine to interpret col as either a column index or value or an array of values.</span>

<span class="sd">        Args:</span>
<span class="sd">            col (various): If col can be interpreted as a column index then return the first matching column.</span>
<span class="sd">                If col is a 1D array of the same length as the data then just return the data. If col is a</span>
<span class="sd">                float then just return it as a float.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The matching data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">index_types</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">col</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Bad column index: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">__threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal function that implements the threshold method - also used in peak-finder</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (float): Threshold valuye in data to look for</span>
<span class="sd">            rising (bool): Find points where data is rising up past threshold</span>
<span class="sd">            falling (bool): Find points where data is falling below the threshold</span>

<span class="sd">        Returns:</span>
<span class="sd">            A numpy array of fractional indices where the data has crossed the threshold assuming a</span>
<span class="sd">            straight line interpolation between two points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we find all points where we cross zero in the correct direction</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
        <span class="n">sdat</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">previous</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rising</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">))</span> <span class="o">|</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">rising</span> <span class="ow">and</span> <span class="n">falling</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">False</span>

        <span class="n">current</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">current</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c1"># Now we refine the estimate of zero crossing with a cubic interpolation</span>
        <span class="c1"># and use Newton&#39;s root finding method to locate the zero in the interpolated data</span>

        <span class="n">intr</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sdat</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># There&#39;s a root somewhere here !</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newton</span><span class="p">(</span><span class="n">intr</span><span class="p">,</span> <span class="n">ix</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># fell off the end here</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handles the local attributes as well as the inherited ones&quot;&quot;&quot;</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">())</span>
        <span class="n">attr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

<div class="viewcode-block" id="AnalysisMixin.add"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add one column, number or array (b) to another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">+</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.apply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the given function to each row in the data set and adds to the data set.</span>

<span class="sd">        Args:</span>
<span class="sd">            func (callable): The function to apply to each row of the data.</span>
<span class="sd">            col (index): The column in which to place the result of the function</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            replace (bool): Either replace the existing column/complete data or create a new column or data file.</span>
<span class="sd">            header (string or None): The new column header(s) (defaults to the name of the function func</span>

<span class="sd">        Note:</span>
<span class="sd">            If any extra keyword arguments are supplied then these are passed to the function directly. If</span>
<span class="sd">            you need to pass any arguments that overlap with the keyword arguments to :py:math:`AnalysisMixin.apply`</span>
<span class="sd">            then these can be supplied in a dictionary argument *_extra*.</span>

<span class="sd">            The callable *func* should have a signature::</span>

<span class="sd">                def func(row,**kargs):</span>

<span class="sd">            and should return either a single float, in which case it will be used to repalce the specified column, or an</span>
<span class="sd">            array, in which case it is used to completely replace the row of data.</span>

<span class="sd">            If the function returns a complete row of data, then the *replace* parameter will cause the return value to be</span>
<span class="sd">            a new datafile, leaving the original unchanged. The *headers* parameter can give the complete column headers for</span>
<span class="sd">            the new data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">kargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_extra&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">()))</span>
        <span class="c1"># Check the dimension of the output</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">()),</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">(</span><span class="n">reset</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># Evaluate the data row by row</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">()):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="n">nc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="c1"># Work out how to handle the result</span>
        <span class="k">if</span> <span class="n">nc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">setas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">nc</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.bin"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.bin">[docs]</a>    <span class="k">def</span> <span class="nf">bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bin x-y data into new values of x with an error bar.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Index of column of data with X values</span>
<span class="sd">            ycol (index): Index of column of data with Y values</span>
<span class="sd">            bins (int, float or 1d array): Number of bins (if integer) or size of bins (if float), or bin edges (if array)</span>
<span class="sd">            mode (string): &quot;log&quot; or &quot;lin&quot; for logarithmic or linear binning</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            yerr (index): Column with y-error data if present.</span>
<span class="sd">            bin_start (float): Manually override the minimum bin value</span>
<span class="sd">            bin_stop (float): Manually override the maximum bin value</span>
<span class="sd">            clone (bool): Return a clone of the current AnalysisMixin with binned data (True)</span>
<span class="sd">                          or just the numbers (False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a clone of the current data set with the new binned data or</span>
<span class="sd">            tuple of (bin centres, bin values, bin errors, number points/bin),</span>
<span class="sd">            depending on the *clone* parameter.</span>

<span class="sd">        Note:</span>
<span class="sd">            Algorithm inspired by MatLab code wbin,    Copyright (c) 2012:</span>
<span class="sd">            Michael Lindholm Nielsen</span>


<span class="sd">        See Also:</span>
<span class="sd">            User Guide section :ref:`binning_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;yerr&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;yerr&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="p">):</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;yerr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kargs</span> <span class="ow">and</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;has_yerr&quot;</span><span class="p">]:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;yerr&quot;</span><span class="p">]</span>

        <span class="n">bin_left</span><span class="p">,</span> <span class="n">bin_right</span><span class="p">,</span> <span class="n">bin_centres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_bins</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>

        <span class="n">ycol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

        <span class="n">ybin</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">ebin</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_left</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">limits</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bin_left</span><span class="p">,</span> <span class="n">bin_right</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">y</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">yerr</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                        <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                        <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">))</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">ycol</span><span class="p">)))</span>
                <span class="n">W</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Empty bin at </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">limits</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="n">W</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">ybin</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">ebin</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">nbins</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">clone</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">xcol</span><span class="p">]]</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ybin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">head</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">ycol</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">ybin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">head</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">ebin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;d</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">nbins</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;#/bin </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">head</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">setas</span><span class="p">)</span>
                <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_centres</span><span class="p">,</span> <span class="n">ybin</span><span class="p">,</span> <span class="n">ebin</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.clip"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clipper</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clips the data based on the column and the clipper value.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>
<span class="sd">            clipper (tuple or array): Either a tuple of (min,max) or a numpy.ndarray -</span>
<span class="sd">                in which case the max and min values in that array will be</span>
<span class="sd">                used as the clip limits</span>
<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="n">clipper</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">clipper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">clipper</span><span class="p">))</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">clipper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">clipper</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.decompose"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.decompose">[docs]</a>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given (x,y) data, decomposes the y part into symmetric and antisymmetric contributions in x.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (index): Index of column with x data - defaults to first x column in self.setas</span>
<span class="sd">            ycol (index or list of indices): indices of y column(s) data</span>
<span class="sd">            sym (index): Index of column to place symmetric data in default, append to end of data</span>
<span class="sd">            asym (index): Index of column for asymmetric part of ata. Defaults to appending to end of data</span>
<span class="sd">            replace (bool): Overwrite data with output (true)</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/decompose.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: decompose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;_startx&quot;</span> <span class="ow">in</span> <span class="n">kwords</span><span class="p">:</span>
                <span class="n">startx</span> <span class="o">=</span> <span class="n">kwords</span><span class="p">[</span><span class="s2">&quot;_startx&quot;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">kwords</span><span class="p">[</span><span class="s2">&quot;_startx&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">startx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="n">startx</span><span class="o">=</span><span class="n">startx</span><span class="p">)</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ycol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ycol</span> <span class="o">=</span> <span class="n">ycol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># FIXME should work with multiple output columns</span>
        <span class="n">pxdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xcol</span><span class="p">)</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">pxdata</span><span class="p">,</span> <span class="n">pxdata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ycol</span><span class="p">]</span>
        <span class="n">symd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ydata</span> <span class="o">+</span> <span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">asymd</span> <span class="o">=</span> <span class="p">(</span><span class="n">ydata</span> <span class="o">-</span> <span class="n">ydata</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">&amp;=</span> <span class="n">symd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Symmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">symd</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Symmetric Data&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">asym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">&amp;=</span> <span class="n">asymd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Asymmetric Data&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">asymd</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Symmetric Data&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">asym</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.diffsum"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.diffsum">[docs]</a>    <span class="k">def</span> <span class="nf">diffsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\frac{a-b}{a+b}` for the two columns *a* and *b*.</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">)/(</span><span class="si">{}</span><span class="s2">+</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">adata</span> <span class="o">+</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.divide"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.divide">[docs]</a>    <span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Divide one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span> <span class="o">/</span> <span class="n">adata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">e2data</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">adata</span>
                <span class="o">/</span> <span class="n">bdata</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.extrapolate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.extrapolate">[docs]</a>    <span class="k">def</span> <span class="nf">extrapolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_x</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extrapolate data based on local fit to x,y data.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_x (float or array): New values of x data.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index, None): column containing x-data or None to use setas attribute</span>
<span class="sd">            ycol (column index(es) or None): column(s) containing the y-data or None to use setas attribute.</span>
<span class="sd">            yerr (column index(es) or None): y error data column or None to use setas attribute</span>
<span class="sd">            overlap (float or int): range of x-data used for the local fit for extrapolating. If int then overlap number of</span>
<span class="sd">                points is used, if float then that range x-axis space is used.</span>
<span class="sd">            kind (str or callable): Determines local fitting function. If string should be &quot;linear&quot;, &quot;quadratic&quot; or &quot;cubic&quot; if</span>
<span class="sd">                callable, then represents a function to be fitted to the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Array of extrapolated values.</span>

<span class="sd">        Note:</span>
<span class="sd">            If the new_x values lie outside the span of the x-data, then the nearest *overlap* portion of the data is used</span>
<span class="sd">            to estimate the values. If the new_x values are within the span of the x-data then the portion of the data</span>
<span class="sd">            centred about the point and overlap points long will be used to interpolate a value.</span>

<span class="sd">            If *kind* is callable, it should take x values in the first parameter and free fitting parameters as the other</span>
<span class="sd">            parameters (i.e. as with :py:meth:`AnalysisMixin.curve_fit`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">kinds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span>
            <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span>
            <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">me</span><span class="p">,</span> <span class="n">ce</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">me</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ce</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">ae</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ce</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ae</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">be</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">ce</span> <span class="o">**</span> <span class="mi">2</span><span class="p">),</span>
            <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">ae</span><span class="p">,</span> <span class="n">be</span><span class="p">,</span> <span class="n">ce</span><span class="p">,</span> <span class="n">de</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">ae</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">be</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">ce</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">de</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">),</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">kind</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="n">kindf</span> <span class="o">=</span> <span class="n">kinds</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to recognise extrpolation function &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="p">))</span>
        <span class="n">scalar_x</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">new_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalar_x</span><span class="p">:</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_x</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">new_x</span><span class="o">.</span><span class="n">compressed</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_x</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)))</span>
        <span class="n">work</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_x</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="o">-</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">overlap</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hl</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="o">-</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_i__between&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">hl</span><span class="p">)}</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">ll</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">hl</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="n">ll</span> <span class="o">+</span> <span class="n">overlap</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">-</span> <span class="n">overlap</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ll</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">-</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="n">hl</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlap</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">__between&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]):</span> <span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">hl</span><span class="p">)}</span>
                <span class="n">mid_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">ll</span> <span class="o">+</span> <span class="n">hl</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">pointdata</span> <span class="o">=</span> <span class="n">work</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">pointdata</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">pointdata</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span> <span class="o">-</span> <span class="n">mid_x</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">pointdata</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">kindf</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">,</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iy</span><span class="p">,</span> <span class="n">rt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">rt</span>
                <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
                <span class="n">results</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">kindf</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mid_x</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">iy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">errs</span><span class="p">[</span><span class="n">kind</span><span class="p">](</span><span class="n">x</span> <span class="o">-</span> <span class="n">mid_x</span><span class="p">,</span> <span class="o">*</span><span class="n">perr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scalar_x</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="AnalysisMixin.integrate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">result_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inegrate a column of data, optionally returning the cumulative integral.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): The X data column index (or header)</span>
<span class="sd">            ycol (index) The Y data column index (or header)</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            result (index or None): Either a column index (or header) to overwrite with the cumulative data,</span>
<span class="sd">                or True to add a new column or None to not store the cumulative result.</span>
<span class="sd">            result_name (string): The new column header for the results column (if specified)</span>
<span class="sd">            bounds (callable): A function that evaluates for each row to determine if the data should be integrated over.</span>
<span class="sd">            kargs: Other keyword arguements are fed direct to the scipy.integrate.cumtrapz method</span>

<span class="sd">        Returns:</span>
<span class="sd">            The final integration result</span>

<span class="sd">        Note:</span>
<span class="sd">            This is a pass through to the scipy.integrate.cumtrapz routine which just uses trapezoidal integration. A better alternative would be</span>
<span class="sd">            to offer a variety of methods including simpson&#39;s rule and interpolation of data. If xcol or ycol are not specified then</span>
<span class="sd">            the current values from the :py:attr:`Stoner.Core.DataFile.setas` attribute are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xcol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;xcol&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ycol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ycol</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="s2">&quot;ycol&quot;</span><span class="p">]</span>
        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)]</span>
        <span class="n">final</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ydat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">yd</span> <span class="o">=</span> <span class="n">ydat</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">resultdata</span> <span class="o">=</span> <span class="n">cumtrapz</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span> <span class="n">yd</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="n">resultdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">resultdata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">resultdata</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">result_name</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">final</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resultdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">final</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final</span></div>

<div class="viewcode-block" id="AnalysisMixin.interpolate"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newX</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolate a dataset to get a new set of values for a given set of x data.</span>

<span class="sd">        Args:</span>
<span class="sd">            ewX (1D array or None): Row indices or X column values to interpolate with. If None, then the</span>
<span class="sd">            :py:meth:`AnalysisMixin.interpolate` returns an interpolation function. Unlike the raw interpolation</span>
<span class="sd">            function from scipy, this interpolation function will work with MaskedArrays by compressing them</span>
<span class="sd">            first.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            kind (string): Type of interpolation function to use - does a pass through from numpy. Default is linear.</span>
<span class="sd">            xcol (index or None): Column index or label that contains the data to use with newX to determine which rows to return. Defaults to None.</span>
<span class="sd">            replace (bool): If true, then the current AnalysisMixin&#39;s data is replaced with the  newly interpolated data and the current AnalysisMixin is</span>
<span class="sd">                returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            2D numpy array: representing a section of the current object&#39;s data if replace is False(default) or the modofied AnalysisMixin if replace is true.</span>

<span class="sd">        Note:</span>
<span class="sd">            Returns complete rows of data corresponding to the indices given in newX. if xcol is None, then newX is interpreted as (fractional) row indices.</span>
<span class="sd">            Otherwise, the column specified in xcol is thresholded with the values given in newX and the resultant row indices used to return the data.</span>

<span class="sd">            If the positional argument, newX is None, then the return value is an interpolation function. This interpolation function takes one argument</span>
<span class="sd">            - if *xcol* was None, this argument is interpreted as array indices, but if *xcol* was specified, then this argument is interpreted as</span>
<span class="sd">            an array of xvalues.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DataArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">newX</span> <span class="o">=</span> <span class="n">newX</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">newX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># We need to convert newX to row indices</span>
            <span class="n">xfunc</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># xfunc(x) returns partial index</span>
            <span class="n">newX</span> <span class="o">=</span> <span class="n">xfunc</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newX</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Ok, we&#39;re going to return an interpolation function</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">newX</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Wrapper for interpolation function.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newX</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">newX</span> <span class="o">=</span> <span class="n">newX</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newX</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">newX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># We need to convert newX to row indices</span>
                    <span class="n">xfunc</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># xfunc(x) returns partial index</span>
                    <span class="n">newX</span> <span class="o">=</span> <span class="n">xfunc</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">wrapper</span>

        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">inter</span><span class="p">(</span><span class="n">newX</span><span class="p">),</span> <span class="n">isrow</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.make_bins"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.make_bins">[docs]</a>    <span class="k">def</span> <span class="nf">make_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lin&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility method to generate bin boundaries and centres along an axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            xcol (index): Column of data with X values</span>
<span class="sd">            bins (1d_)array or int or float): Number of bins (int) or width of bins (if float)</span>
<span class="sd">            mode (string): &quot;lin&quot; for linear binning, &quot;log&quot; for logarithmic binning.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bin_start (float): Override minimum bin value</span>
<span class="sd">            bin_stop (float): Override the maximum bin value</span>

<span class="sd">        Returns:</span>
<span class="sd">            bin_start,bin_stop,bin_centres (1D arrays): The locations of the bin</span>
<span class="sd">            boundaries and centres for each bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lin&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mode should be either  &#39;lin&#39; or &#39;log&#39; not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;bin_start&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;bin_start&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;bin_stop&quot;</span> <span class="ow">in</span> <span class="n">kargs</span><span class="p">:</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">kargs</span><span class="p">[</span><span class="s2">&quot;bin_stop&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># Given a number of bins</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="n">xminl</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
                <span class="n">xmaxl</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">xmaxl</span> <span class="o">-</span> <span class="n">xminl</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span><span class="p">,</span> <span class="n">xmaxl</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xminl</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmaxl</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_stop</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">bin_centres</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>  <span class="c1"># Given a bin with as a flot</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_width</span> <span class="o">=</span> <span class="n">bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span><span class="p">))</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">bins</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bin width must be between 0 ans 1 for log binning&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The start of the binning must be a positive value in log mode.&quot;</span><span class="p">)</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="n">xmin</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">centers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">xp</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">:</span>
                    <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
                    <span class="n">centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bins</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">bins</span><span class="p">)</span>
                <span class="n">splits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>
                <span class="n">bin_start</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bins</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Yser provided manuals bins</span>
            <span class="n">bin_start</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">bin_stop</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startwith</span><span class="p">(</span><span class="s2">&quot;lin&quot;</span><span class="p">):</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_start</span> <span class="o">+</span> <span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
                <span class="n">bin_centres</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">_np_</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">bin_stop</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode should be either lin(ear) or log(arthimitc) not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bins must be either an integer or a float, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">bins</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to bin into more bins than there is data.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bin_start</span><span class="p">,</span> <span class="n">bin_stop</span><span class="p">,</span> <span class="n">bin_centres</span></div>

<div class="viewcode-block" id="AnalysisMixin.max"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find maximum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,int): (maximum value,row index of max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.mean"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find mean value of a data column.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            sigma (column index or array): The uncertainity noted for each value in the mean</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: The mean of the data.</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            Fix the row index when the bounds function is used - see note of :py:meth:`AnalysisMixin.max`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="n">all_type</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">_</span><span class="p">[</span><span class="s2">&quot;has_yerr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">_</span><span class="o">.</span><span class="n">has_yerr</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_</span><span class="o">.</span><span class="n">has_yerr</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ydata</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span><span class="p">,</span> <span class="n">error</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.min"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find minimum value and index in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,int): (minimum value,row index of min value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_mask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_mask</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pop_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="AnalysisMixin.multiply"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.multiply">[docs]</a>    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Multiply one column (a) by  another column, number or array (b).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">e1data</span> <span class="o">/</span> <span class="n">adata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">e2data</span> <span class="o">/</span> <span class="n">bdata</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">adata</span>
                <span class="o">*</span> <span class="n">bdata</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">*</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">*</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.normalise"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.normalise">[docs]</a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Normalise data columns by dividing through by a base column value.</span>

<span class="sd">        Args:</span>
<span class="sd">            target (index): One or more target columns to normalise can be a string, integer or list of strings or integers.</span>
<span class="sd">                If None then the default &#39;y&#39; column is used.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            base (index): The column to normalise to, can be an integer or string. **Depricated** can also be a tuple (low,high) being the output range</span>
<span class="sd">            replace (bool): Set True(default) to overwrite  the target data columns</span>
<span class="sd">            header (string or None): The new column header - default is target name(norm)</span>
<span class="sd">            scale (None or tuple of float,float): Output range after normalising - low,high or None to map to -1,1</span>
<span class="sd">            limits (low,high): Take the input range from the *high* and *low* fraction of the input when sorted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        Notes:</span>

<span class="sd">            The *limits* parameter is used to set the input scale being normalised from - if the data has a few outliers then</span>
<span class="sd">            this setting can be used to clip the input range before normalising. The parameters in the limit are the values at</span>
<span class="sd">            the *low* and *high* fractions of the cumulative distribution function of the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="o">+</span> <span class="s2">&quot;(norm)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">istuple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">istuple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">scale</span> <span class="o">=</span> <span class="n">base</span>
                <span class="k">elif</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">istuple</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;limit parameter is either None, or limit or base is a tuple of two floats.&quot;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">_np_</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">limits</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
                    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">limits</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">low</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">high</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">t</span><span class="p">])</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
                <span class="n">scl</span><span class="p">,</span> <span class="n">sch</span> <span class="o">=</span> <span class="n">scale</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sch</span> <span class="o">-</span> <span class="n">scl</span><span class="p">)</span> <span class="o">+</span> <span class="n">scl</span>
                <span class="n">setas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="n">setas</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.outlier_detection"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.outlier_detection">[docs]</a>    <span class="k">def</span> <span class="nf">outlier_detection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">certainty</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to detect outliers in a column of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            column(column index), specifing column for outlier detection. If not set,</span>
<span class="sd">                defaults to the current y set column.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            window(int): data window for anomoly detection</span>
<span class="sd">            certainty(float): eg 3 detects data 3 standard deviations from average</span>
<span class="sd">            action(str or callable): what to do with outlying points, options are</span>
<span class="sd">                * &#39;mask&#39; outlier points are masked (default)</span>
<span class="sd">                * &#39;mask row&#39; outlier rows are masked</span>
<span class="sd">                * &#39;delete&#39;  outlier rows are deleted</span>
<span class="sd">                * callable  the value of the action keyword is called with the outlier row</span>
<span class="sd">                * anything else defaults to do nothing.</span>

<span class="sd">            width(odd integer): Number of rows that an outliing spike could occupy. Defaults to 1.</span>
<span class="sd">            func (callable): A function that determines if the current row is an outlier.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        outlier_detection will add row numbers of detected outliers to the metadata</span>
<span class="sd">        of d, also will perform action depending on request eg &#39;mask&#39;, &#39;delete&#39;</span>
<span class="sd">        (any other action defaults to doing nothing).</span>

<span class="sd">        The detection looks at a window of the data, takes the average and looks</span>
<span class="sd">        to see if the current data point falls certainty * std deviations away from</span>
<span class="sd">        data average.</span>

<span class="sd">        The outlier detection function has the signatrure::</span>

<span class="sd">            def outlier(row,column,window,certainity,**kargs)</span>
<span class="sd">                #code</span>
<span class="sd">                return True # or False</span>

<span class="sd">        All extra keyword arguments are passed to the outlier detector.</span>

<span class="sd">        IF *action* is a callable function then it should take the form of::</span>

<span class="sd">            def action(i,column,row):</span>
<span class="sd">                pass</span>

<span class="sd">        where *i* is the number of the outlier row, *column* the same value as above</span>
<span class="sd">        and *row* is the data for the row.</span>

<span class="sd">        In all cases the indices of the outlier rows are added to the ;outlier&#39; metadata.</span>

<span class="sd">        Example</span>
<span class="sd">            .. plot:: samples/outlier.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: outlier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_outlier</span>

        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">get_func_params</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_</span><span class="p">:</span>
                <span class="n">kargs</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">action</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="s2">&quot;mask row&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Do&#39;n know what to do with action=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">action</span><span class="p">))</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exclude_centre</span><span class="o">=</span><span class="n">width</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">certainty</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;outliers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>  <span class="c1"># add outlier indecies to metadata</span>
        <span class="n">index</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>  <span class="c1"># Always reverse the index in case we&#39;re deleting rows in sucession</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;mask&quot;</span> <span class="ow">or</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;mask row&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;mask&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s2">&quot;delete&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">del_rows</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>  <span class="c1"># this will call the action function with each row in turn from back to start</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="n">action</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.peaks"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.peaks">[docs]</a>    <span class="k">def</span> <span class="nf">peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Locates peaks and/or troughs in a column of data by using SG-differentiation.</span>

<span class="sd">        Args:</span>
<span class="sd">            ycol (index): is the column name or index of the data in which to search for peaks</span>
<span class="sd">            width (int or float): is the expected minium halalf-width of a peak in terms of the number of data points (int) or distance in x (float).</span>
<span class="sd">                This is used in the differnetiation code to find local maxima. Bigger equals less sensitive</span>
<span class="sd">                to experimental noise, smaller means better eable to see sharp peaks</span>
<span class="sd">            poly (int): This is the order of polynomial to use when differentiating the data to locate a peak. Must &gt;=2, higher numbers</span>
<span class="sd">                will find sharper peaks more accurately but at the risk of finding more false positives.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            significance (float): is used to decide whether a local maxmima is a significant peak. Essentially just the curvature</span>
<span class="sd">                of the data. Bigger means less sensistive, smaller means more likely to detect noise. Default is the maximum curvature/(2*width)</span>
<span class="sd">            xcol (index or None): name or index of data column that p[rovides the x-coordinate (default None)</span>
<span class="sd">            peaks (bool): select whether to measure peaks in data (default True)</span>
<span class="sd">            troughs (bool): select whether to measure troughs in data (default False)</span>
<span class="sd">            sort (bool): Sor the results by significance of peak</span>
<span class="sd">            modify (book): If true, then the returned object is a copy of self with only the peaks/troughs left in the data.</span>
<span class="sd">            full_data (bool): If True (default) then all columns of the data at which peaks in the *ycol* column are found. *modify* true implies</span>
<span class="sd">                      *full_data* is also true. If *full_data* is False, then only the x-column values of the peaks are returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If *modify* is true, then returns a the AnalysisMixin with the data set to just the peaks/troughs. If *modify* is false (default),</span>
<span class="sd">            then the return value depends on *ycol* and *xcol*. If *ycol* is not None and *xcol* is None, then returns conplete rows of</span>
<span class="sd">            data corresponding to the found peaks/troughs. If *xcol* is not None, or *ycol* is None and *xcol* is None, then</span>
<span class="sd">            returns a 1D array of the x positions of the peaks/troughs.</span>

<span class="sd">        See Also:</span>
<span class="sd">            User guide section :ref:`peak_finding`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="mi">20</span><span class="p">))</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;peaks&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">troughs</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;troughs&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">poly</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">poly</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;poly must be at least 2nd order in peaks for checking for significance of peak or trough&quot;</span>

        <span class="n">sort</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">modify</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;modify&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">full_data</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;full_data&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">ycol</span><span class="o">=</span><span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span> <span class="o">=</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span>
        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">ycol</span> <span class="o">=</span> <span class="n">ycol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>  <span class="c1"># Convert a floating point width unto an integer.</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">))</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">poly</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">setas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span><span class="n">ycol</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SG_Filter</span><span class="p">(</span>
            <span class="n">ycol</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">poly</span><span class="o">=</span><span class="n">poly</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># 2nd differential requires more smoothing</span>

        <span class="c1"># We&#39;re going to ignore the start and end of the arrays</span>
        <span class="n">index_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">[</span><span class="n">index_offset</span><span class="p">:</span><span class="o">-</span><span class="n">index_offset</span><span class="p">]</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">d2</span><span class="p">[</span><span class="n">index_offset</span><span class="p">:</span><span class="o">-</span><span class="n">index_offset</span><span class="p">]</span>

        <span class="c1"># Pad the ends of d2 with the mean value</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d2</span><span class="p">[</span><span class="n">index_offset</span><span class="p">:</span><span class="o">-</span><span class="n">index_offset</span><span class="p">])</span>
        <span class="n">d2</span><span class="p">[:</span><span class="n">index_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">pad</span>
        <span class="n">d2</span><span class="p">[</span><span class="o">-</span><span class="n">index_offset</span><span class="p">:]</span> <span class="o">=</span> <span class="n">pad</span>

        <span class="c1"># Set the significance from the 2nd ifferential if not already set</span>
        <span class="n">significance</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">&quot;significance&quot;</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># Base an apriori significance on max d2y/dx2 / 20</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">significance</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># integer significance is inverse to floating</span>
            <span class="n">significance</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">))</span> <span class="o">/</span> <span class="n">significance</span>  <span class="c1"># Base an apriori significance on max d2y/dx2 / 20</span>

        <span class="n">d2_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d2</span><span class="p">)),</span> <span class="n">d2</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure we have some X-data</span>
        <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">xcol</span><span class="p">)</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>

        <span class="n">possible_peaks</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_threshold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">troughs</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">peaks</span><span class="p">))</span>
        <span class="n">curvature</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2_interp</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">))</span>

        <span class="c1"># Filter just the significant peaks</span>
        <span class="n">possible_peaks</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">)</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">curvature</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">significance</span><span class="p">])</span>
        <span class="c1"># Sort in order of significance</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">possible_peaks</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2_interp</span><span class="p">(</span><span class="n">possible_peaks</span><span class="p">))))</span>

        <span class="n">xdat</span> <span class="o">=</span> <span class="n">xdata</span><span class="p">(</span><span class="n">possible_peaks</span> <span class="o">+</span> <span class="n">index_offset</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modify</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">full_data</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">xdat</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">xdat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="n">setas</span>
        <span class="c1"># Return - but remembering to add back on the offset that we took off due to differentials not working at start and end</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.polyfit"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.polyfit">[docs]</a>    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polynomial_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">result</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pass through to numpy.polyfit.</span>

<span class="sd">            Args:</span>
<span class="sd">                xcol (index): Index to the column in the data with the X data in it</span>
<span class="sd">                ycol (index): Index to the column int he data with the Y data in it</span>
<span class="sd">                polynomial_order: Order of polynomial to fit (default 2)</span>
<span class="sd">                bounds (callable): A function that evaluates True if the current row should be included in the fit</span>
<span class="sd">                result (index or None): Add the fitted data to the current data object in a new column (default don&#39;t add)</span>
<span class="sd">                replace (bool): Overwrite or insert new data if result is not None (default False)</span>
<span class="sd">                header (string or None): Name of column_header of replacement data. Default is construct a string from the y column headser and polynomial order.</span>

<span class="sd">            Returns:</span>
<span class="sd">                numpy.poly: The best fit polynomial as a numpy.poly object.</span>

<span class="sd">            Note:</span>
<span class="sd">                If the x or y columns are not specified (or are None) the the setas attribute is used instead.</span>

<span class="sd">                This method is depricated and may be removed in a future version in favour of the more general curve_fit</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">Stoner.Util</span> <span class="k">import</span> <span class="n">ordinal</span>

        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">_</span><span class="o">.</span><span class="n">ycol</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">),</span> <span class="n">polynomial_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ycol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span>
                <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)],</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span> <span class="n">polynomial_order</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;Fitted </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> order polynomial&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">ycol</span><span class="p">)],</span> <span class="n">ordinal</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span>
                    <span class="n">_np_</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-order polyfit coefficients&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ordinal</span><span class="p">(</span><span class="n">polynomial_order</span><span class="p">))]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

<div class="viewcode-block" id="AnalysisMixin.scale"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scale the x and y data in this DataFile to match the x and y data in another DataFile.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DataFile): The other isntance of a datafile to match to</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index): Column with x points in it, default to None to use setas attribute value</span>
<span class="sd">            ycol (column index): Column with ypoints in it, default to None to use setas attribute value</span>
<span class="sd">            xmode (&#39;affine&#39;, &#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;): How to manipulate the x-data to match up</span>
<span class="sd">            ymode (&#39;linear&#39;,&#39;scale&#39;,&#39;offset&#39;): How to manipulate the y-data to match up.</span>
<span class="sd">            bounds (callable): Used to identiyf the set of (x,y) points to be used for scaling. Defaults to the whole data set if not speicifed.</span>
<span class="sd">            otherbounds (callable): Used to detemrine the set of (x,y) points in the other data file. Defaults to bounds if not given.</span>
<span class="sd">            use_estimate (bool or 3x2 array): Specifies whether to estimate an initial transformation value or to use the provided one, or</span>
<span class="sd">                start with an identity transformation.</span>
<span class="sd">            replace (bool): Whether to map the x,y data to the new co-ordinates and return a copy of this AnalysisMixin (true) or to just return</span>
<span class="sd">                the results of the scaling.</span>
<span class="sd">            headers (2-element list or tuple of strings): new column headers to use if replace is True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Either a copy of the AnalysisMixin modified so that the x and y columns match *other* if *replace* is True, or</span>
<span class="sd">            *opt_trans*,*trans_err*,*new_xy_data*. Where *opt_trans* is the optimum affine transformation, *trans_err* is a matrix</span>
<span class="sd">            giving the standard error in the transformation matrix components and  *new_xy_data* is an (n x 2) array of the transformed data.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. plot:: samples/scale_curves.py</span>
<span class="sd">                :include-source:</span>
<span class="sd">                :outname: scale</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Sort out keyword srguments</span>
        <span class="c1">#</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">otherbounds</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;otherbounds&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;headers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">xmode</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xmode&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="n">ymode</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ymode&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">)</span>
        <span class="n">use_estimate</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_estimate&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get our working data from this DataFile and remove masked rows</span>

        <span class="n">working</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">working</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xdat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
        <span class="n">ydat</span> <span class="o">=</span> <span class="n">working</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>

        <span class="c1"># Get data from the other. If it is already an ndarray, check size and dimensions</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">):</span>
            <span class="n">working2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">otherbounds</span><span class="p">)</span>
            <span class="n">working2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">mask_rowcols</span><span class="p">(</span><span class="n">working2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">xdat2</span> <span class="o">=</span> <span class="n">working2</span><span class="p">[:,</span> <span class="n">other</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)]</span>
            <span class="n">ydat2</span> <span class="o">=</span> <span class="n">working2</span><span class="p">[:,</span> <span class="n">other</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat2</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Data lengths don&#39;t match </span><span class="si">{}</span><span class="s2">!=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat2</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;If other is a numpy array it must be the same length as the number of points to match &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;to and 1 or 2 columns. (other shape=</span><span class="si">{}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">xdat2</span> <span class="o">=</span> <span class="n">xdat</span>
                <span class="n">ydat2</span> <span class="o">=</span> <span class="n">other</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xdat2</span> <span class="o">=</span> <span class="n">other</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">ydat2</span> <span class="o">=</span> <span class="n">other</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;other should be either a numpy array or subclass of DataFile, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1"># Need two nx2 arrays of points now</span>

        <span class="n">xy1</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xdat</span><span class="p">,</span> <span class="n">ydat</span><span class="p">))</span>
        <span class="n">xy2</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xdat2</span><span class="p">,</span> <span class="n">ydat2</span><span class="p">))</span>

        <span class="c1"># We&#39;re going to use three points to get an estimate for the affine transform to apply</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_estimate</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_estimate</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># may go wrong if three points are co-linear</span>
                <span class="n">m0</span> <span class="o">=</span> <span class="n">GetAffineTransform</span><span class="p">(</span><span class="n">xy1</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:],</span> <span class="n">xy2</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:])</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># So use an idnetify transformation instead</span>
                <span class="n">m0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_estimate</span><span class="p">,</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">use_estimate</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">,</span>
        <span class="p">):</span>  <span class="c1"># use_estimate is an initial value transformation</span>
            <span class="n">m0</span> <span class="o">=</span> <span class="n">use_estimate</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Don&#39;t try to be clever</span>
            <span class="n">m0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">perr</span><span class="p">,</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">_twoD_fit</span><span class="p">(</span><span class="n">xy1</span><span class="p">,</span> <span class="n">xy2</span><span class="p">,</span> <span class="n">xmode</span><span class="o">=</span><span class="n">xmode</span><span class="p">,</span> <span class="n">ymode</span><span class="o">=</span><span class="n">ymode</span><span class="p">,</span> <span class="n">m0</span><span class="o">=</span><span class="n">m0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]]</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>  <span class="c1"># In place scaling, replace and return self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;Transform&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;Transform Err&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">headers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Return results but don&#39;t change self.</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">popt</span><span class="p">,</span> <span class="n">perr</span><span class="p">,</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AnalysisMixin.smooth"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;boxcar&quot;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Smooth data by convoluting with a window.</span>

<span class="sd">        Args:</span>
<span class="sd">            window (string or tuple): Defines the window type to use by passing to :py:func:`scipy.signal.get_window`.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol(column index or None): Data to use as x data if needed to define a window. If None, use :py:attr:`Stoner.Core.DataFile.setas`</span>
<span class="sd">            ycvol (column index or None): Data to be smoothed</span>
<span class="sd">            size (int or float): If int, then the number of points to use in the smoothing window. If float, then the size in x-data to be used.</span>
<span class="sd">            result (bool or column index): Whether to add the smoothed data to the dataset and if so where.</span>
<span class="sd">            replace (bool): Replace the exiting data or insert as a new column.</span>
<span class="sd">            header (string): New column header for the new data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (self or array): If result is False, then the return value will be a copy of the smoothed data, otherwise the return value</span>
<span class="sd">            is a copy of the AnalysisMixin object with the smoothed data added,</span>

<span class="sd">        Notes:</span>
<span class="sd">            If size is float, then it is necessary to map the X-data to a number of rows and to ensure that the data is evenly spaced in x.</span>
<span class="sd">            To do this, the number of rows in the window is found by dividing the span in x by the size and multiplying by the total</span>
<span class="sd">            lenfth. Then the data is interpolated to a new set of evenly space X over the same range, smoothed and then interpoalted back</span>
<span class="sd">            to the original x values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># overwirte existing y column data</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>

        <span class="c1"># Sort out window size</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">interp_data</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">xh</span> <span class="o">-</span> <span class="n">xl</span><span class="p">))</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">xh</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Smoothing window size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">int_types</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="n">interp_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size should either be a float or integer, not a </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)))</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="c1"># Handle multiple or single y columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">):</span>
            <span class="n">_</span><span class="o">.</span><span class="n">ycol</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>

        <span class="c1"># Do the convolution itself</span>
        <span class="k">for</span> <span class="n">yc</span> <span class="ow">in</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[:,</span> <span class="n">yc</span><span class="p">]</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">yc</span><span class="p">],</span> <span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>

        <span class="c1"># Reinterpolate the smoothed data back if necessary</span>
        <span class="k">if</span> <span class="n">interp_data</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Fix return value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">yc</span> <span class="ow">in</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">yc</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.span"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a tuple of the maximum and minumum values within the given column and bounds by calling into :py:meth:`AnalysisMixin.max` and :py:meth:`AnalysisMixin.min`.</span>

<span class="sd">        Args:</span>
<span class="sd">            column (index): Column to look for the maximum in</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            bounds (callable): A callable function that takes a single argument list of</span>
<span class="sd">                numbers representing one row, and returns True for all rows to search in.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float,float): A tuple of (min value, max value)</span>

<span class="sd">        Note:</span>
<span class="sd">            If column is not defined (or is None) the :py:attr:`DataFile.setas` column</span>
<span class="sd">            assignments are used.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="AnalysisMixin.spline"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.spline">[docs]</a>    <span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a spline through x and y data and replace, add new data or return spline function.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            xcol (column index): Column with x data or if None, use setas attribute.</span>
<span class="sd">            ycol (column index): Column with y data or if None, use the setas attribute</span>
<span class="sd">            sigma (column index, or array of data): Column with weights, or if None use the 1/yerr column.</span>
<span class="sd">            replace (Boolean or column index or None): If True then the y-column data is repalced, if a column index then the</span>
<span class="sd">                new data is added after the specified index, if False then the new y-data is returned and if None, then</span>
<span class="sd">                spline object is returned.</span>
<span class="sd">            header (string): If *replace* is True or a column index then use this string as the new column header.</span>
<span class="sd">            order (int): The order of spline to use (1-5)</span>
<span class="sd">            smoothing (float or None): The smoothing factor to use when fitting the spline. A value of zero will create an</span>
<span class="sd">                interpolating spline.</span>
<span class="sd">            bbox (tuple of length 2): Bounding box for the spline - defaults to range of x values</span>
<span class="sd">            ext (int or str): How to extrapolate, default is &quot;extrapolate&quot;, but can also be &quot;raise&quot;,&quot;zeros&quot; or &quot;const&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Depending on the value of *replace*, returns a copy of the AnalysisMixin, a 1D numpy array of data or an</span>
<span class="sd">            scipy.interpolate.UniverateSpline object.</span>

<span class="sd">        This is really jsut a pass through to the scipy.interpolate.UnivariateSpline function. Also used in the extrapolate</span>
<span class="sd">        function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">isNone</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isNone</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">):</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span> <span class="o">//</span> <span class="n">_</span><span class="o">.</span><span class="n">yerr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;replace&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># overwirte existing y column data</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;smoothing&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bbox&quot;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ext&quot;</span><span class="p">,</span> <span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">//</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">//</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">)</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">new_y</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spline</span></div>

<div class="viewcode-block" id="AnalysisMixin.stitch"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.stitch">[docs]</a>    <span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_overlap</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a scaling to this data set to make it stich to another dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (DataFile): Another data set that is used as the base to stitch this one on to</span>
<span class="sd">            xcol,ycol (index or None): The x and y data columns. If left as None then the current setas attribute is used.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            overlap (tuple of (lower,higher) or None): The band of x values that are used in both data sets to match,</span>
<span class="sd">                if left as None, thenthe common overlap of the x data is used.</span>
<span class="sd">            min_overlap (float): If you know that overlap must be bigger than a certain amount, the bounds between the two</span>
<span class="sd">                data sets needs to be adjusted. In this case min_overlap shifts the boundary of the overlap on this DataFile.</span>
<span class="sd">            mode (str): Unless *func* is specified, controls which parameters are actually variable, defaults to all of them.</span>
<span class="sd">            func (callable): a stitching function that transforms :math:`(x,y)\rightarrow(x&#39;,y&#39;)`. Default is to use</span>
<span class="sd">                functions defined by *mode*</span>
<span class="sd">            p0 (iterable): if func is not None then p0 should be the starting values for the stitching function parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: A copy of the current :py:class:`AnalysisMixin` with the x and y data columns adjusted to stitch</span>

<span class="sd">        To stitch the data together, the x and y data in the current data file is transforms so that</span>
<span class="sd">        :math:`x&#39;=x+A` and :math:`y&#39;=By+C` where :math:`A,B,C` are constants and :math:`(x&#39;,y&#39;)` are close matches to the</span>
<span class="sd">        :math:`(x,y)` data in *other*. The algorithm assumes that the overlap region contains equal</span>
<span class="sd">        numbers of :math:`(x,y)` points *mode* controls whether A,B, and C are fixed or adjustable</span>

<span class="sd">            - &quot;All&quot; - all three parameters adjustable</span>
<span class="sd">            - &quot;Scale y, shift x&quot; - C is fixed at 0.0</span>
<span class="sd">            - &quot;Scale and shift y&quot; A is fixed at 0.0</span>
<span class="sd">            - &quot;Scale y&quot; - only B is adjustable</span>
<span class="sd">            - &quot;Shift y&quot; - Only c is adjsutable</span>
<span class="sd">            - &quot;Shift x&quot; - Only A is adjustable</span>
<span class="sd">            - &quot;Shift both&quot; - B is fixed at 1.0</span>

<span class="sd">        See Also:</span>
<span class="sd">            User Guide section :ref:`stitch_guide`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_args</span><span class="p">(</span><span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">ycol</span><span class="o">=</span><span class="n">ycol</span><span class="p">,</span> <span class="n">scalar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),</span> <span class="p">:]</span>
        <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min_overlap</span>
        <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">column</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">])</span>
        <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),</span> <span class="p">:]</span>
        <span class="n">self_second</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Calculate the overlap</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">overlap</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">overlap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="n">inrange</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">lower</span><span class="p">,</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">inrange</span><span class="p">]</span>
        <span class="n">num_pts</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">self_second</span><span class="p">:</span>
            <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="o">-</span><span class="n">num_pts</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">otherpoints</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_pts</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="n">otherpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;scale y and shift x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">*</span> <span class="n">y</span><span class="p">)),</span>
                <span class="s2">&quot;scale and shift y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;scale y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">B</span><span class="p">)),</span>
                <span class="s2">&quot;shift y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
                <span class="s2">&quot;shift both&quot;</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C</span><span class="p">)),</span>
            <span class="p">}</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;scale y,shift x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;scale and shift y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;scale y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;shift y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="s2">&quot;shift both&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="n">A0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">C0</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">B0</span> <span class="o">=</span> <span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">yp</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">_np_</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">C0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">string_types</span><span class="p">),</span> <span class="s2">&quot;mode keyword should be a string if func is not defined&quot;</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">,</span> <span class="s2">&quot;mode keyword should be one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="n">mode</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="s2">&quot;Keyword func should be callable if given&quot;</span>
            <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span> <span class="o">=</span> <span class="n">getfullargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># pylint: disable=W1505</span>
            <span class="k">assert</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="s2">&quot;Keyword parameter p0 shoiuld be iterable if keyword func is given&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Keyword p0 should be the same length as the optional arguments to func&quot;</span>
        <span class="c1"># This is a bit of a hack, we turn (x,y) points into a 1D array of x and then y data</span>
        <span class="n">set1</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2</span><span class="p">),</span> <span class="s2">&quot;The number of points in the overlap are different in the two data sets&quot;</span>

        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">set1</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Wrapper function to fit for transform.&quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">set1</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">set1</span><span class="p">[</span><span class="n">m</span><span class="p">:]</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">set1</span><span class="p">,</span> <span class="n">set2</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">)</span>  <span class="c1"># Curve fit for optimal A,B,C</span>
        <span class="n">perr</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_np_</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">xcol</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">_</span><span class="o">.</span><span class="n">ycol</span><span class="p">],</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Coeffient Errors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">perr</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching overlap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;Stitching Window&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_pts</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.subtract"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.subtract">[docs]</a>    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract one column, number or array (b) from another column (a).</span>

<span class="sd">        Args:</span>
<span class="sd">            a (index): First column to work with</span>
<span class="sd">            b (index, float or 1D array):  Second column to work with.</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            header (string or None): new column header  (defaults to a-b</span>
<span class="sd">            replace (bool): Replace the a column with the new data</span>

<span class="sd">        Returns:</span>
<span class="sd">            self: The newly modified :py:class:`AnalysisMixin`.</span>

<span class="sd">        If a and b are tuples of length two, then the firstelement is assumed to be the value and</span>
<span class="sd">        the second element an uncertainty in the value. The uncertainties will then be propagated and an</span>
<span class="sd">        additional column with the uncertainites will be added to the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>  <span class="c1"># Error columns on</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span>
            <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">e1data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">e2data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">e2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">:</span> <span class="n">_np_</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e1data</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2data</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">err_calc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">adata</span><span class="p">,</span> <span class="n">aname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">bdata</span><span class="p">,</span> <span class="n">bname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_math_val</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">err_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">bname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">err_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_header</span> <span class="o">=</span> <span class="s2">&quot;Error in &quot;</span> <span class="o">+</span> <span class="n">header</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">err_data</span> <span class="o">=</span> <span class="n">err_calc</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">bdata</span><span class="p">,</span> <span class="n">e1data</span><span class="p">,</span> <span class="n">e2data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">((</span><span class="n">adata</span> <span class="o">-</span> <span class="n">bdata</span><span class="p">),</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">err_calc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_column</span><span class="p">(</span><span class="n">err_data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">err_header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="AnalysisMixin.threshold"><a class="viewcode-back" href="../../classes/Stoner.Analysis.AnalysisMixin.html#Stoner.Analysis.AnalysisMixin.threshold">[docs]</a>    <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds partial indices where the data in column passes the threshold, rising or falling.</span>

<span class="sd">        Args:</span>
<span class="sd">            threshold (float): Value to look for in column col</span>

<span class="sd">        Keyword Arguments:</span>
<span class="sd">            col (index): Column index to look for data in</span>
<span class="sd">            rising (bool):  look for case where the data is increasing in value (defaukt True)</span>
<span class="sd">            falling (bool): look for case where data is fallinh in value (default False)</span>
<span class="sd">            xcol (index, bool or None): rather than returning a fractional row index, return the</span>
<span class="sd">                interpolated value in column xcol. If xcol is False, then return a complete row</span>
<span class="sd">                all_vals (bool): return all crossing points of the threshold or just the first. (default False)</span>
<span class="sd">            transpose (bbool): Swap the x and y columns around - this is most useful when the column assignments</span>
<span class="sd">                have been done via the setas attribute</span>
<span class="sd">            all_vals (bool): Return all values that match the criteria, or just the first in the file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Either a sing;le fractional row index, or an in terpolated x value</span>

<span class="sd">        Note:</span>
<span class="sd">            If you don&#39;t sepcify a col value or set it to None, then the assigned columns via the</span>
<span class="sd">            :py:attr:`DataFile.setas` attribute will be used.</span>

<span class="sd">        Warning:</span>
<span class="sd">            There has been an API change. Versions prior to 0.1.9 placed the column before the threshold in the positional</span>
<span class="sd">            argument list. In order to support the use of assigned columns, this has been swapped to the present order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DataArray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;ycol&quot;</span><span class="p">)</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">_get_cols</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xcol</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;xcol&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">rising</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rising&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">falling</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;falling&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">all_vals</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;all_vals&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Recursively call if we&#39;ve got an iterable threshold</span>
        <span class="k">if</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">threshold</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">DataArray</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">th</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="n">xcol</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">,</span> <span class="n">all_vals</span><span class="o">=</span><span class="n">all_vals</span><span class="p">)</span>
            <span class="c1"># Now we have to clean up the  retujrn list into a DataArray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>  <span class="c1"># if xcol was False we got a complete row back</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span> <span class="o">=</span> <span class="n">ch</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Either xcol was None so we got indices or we got a specified column back</span>
                <span class="k">if</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Specific column</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">_np_</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">column_headers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">i</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ret</span><span class="p">]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">isrow</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">column_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">isrow</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_threshold</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">rising</span><span class="o">=</span><span class="n">rising</span><span class="p">,</span> <span class="n">falling</span><span class="o">=</span><span class="n">falling</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">all_vals</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">_np_</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xcol</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xcol</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">setas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">clone</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">setas</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">retval</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">retval</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">ret</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">retval</span>
        <span class="k">elif</span> <span class="n">xcol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">xcol</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_col</span><span class="p">(</span><span class="n">xcol</span><span class="p">)]</span>
            <span class="c1"># if retval.ndim&gt;0:   #not sure what this bit does but it&#39;s throwing errors for a simple threshold</span>
            <span class="c1"># retval.setas=self.setas.clone</span>
            <span class="c1"># retval.setas.shape=retval.shape</span>
            <span class="c1"># retval.i=ret</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">retval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_vals</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">ret</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">DataArray</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">isrow</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ret</span></div></div>


<span class="k">def</span> <span class="nf">AnalyseFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Issue a warning and then create a class anyway.&quot;&quot;&quot;</span>
    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;AnalyseFile is deprecated in favour of Stoner.Data or the AnalysisMixin&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">Stoner.Core</span> <span class="k">as</span> <span class="nn">_SC_</span>

    <span class="k">class</span> <span class="nc">AnalyseFile</span><span class="p">(</span><span class="n">AnalysisMixin</span><span class="p">,</span> <span class="n">_SC_</span><span class="o">.</span><span class="n">DataFile</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;:py:class:`Stoner.Analysis.AnalyseFile` extends :py:class:`Stoner.Core.DataFile` with numpy and scipy passthrough functions.</span>

<span class="sd">        Note:</span>
<span class="sd">            There is no separate constructor for this class - it inherits from DataFile</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">AnalyseFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/StonerLogo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">Stoner Package</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li>
      <li>
        <a href="../Stoner.html">Stoner</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2013-15, Gavin Burnell et al.Last updated on Apr 22, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      1.7.9
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>