<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Working with Lots of Files &mdash; Stoner Pacakge API Documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Stoner Pacakge API Documentation" href="../index.html" />
    <link rel="up" title="The Stoner Python Package User Guide" href="ugindex.html" />
    <link rel="next" title="Cookbook" href="cookbook.html" />
    <link rel="prev" title="Analysing Data Files" href="analysisfile.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cookbook.html" title="Cookbook"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="analysisfile.html" title="Analysing Data Files"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Stoner Package</a> &raquo;</li>
          <li><a href="ugindex.html" accesskey="U">The Stoner Python Package User Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="working-with-lots-of-files">
<h1>Working with Lots of Files<a class="headerlink" href="#working-with-lots-of-files" title="Permalink to this headline">¶</a></h1>
<p>A common case is that you have measured lots of data curves and now have a large stack of data
files sitting in a tree of folders on disc and now need to process all of them with some code.
The <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> class is designed to make it easier to process lots of files.</p>
<div class="section" id="building-a-virtual-folder-of-data-files">
<h2>Building a (virtual) Folder of Data Files<a class="headerlink" href="#building-a-virtual-folder-of-data-files" title="Permalink to this headline">¶</a></h2>
<p>The first thing you probably want to do is to get a list of data files in a directory
(possibly including its subdirectories) and probably matching some sort of filename pattern.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">Stoner.Folders</span> <span class="kn">import</span> <span class="n">DataFolder</span>
<span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.dat&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this very simple example, the <tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span> <span class="pre">class</span> <span class="pre">is</span> <span class="pre">imported</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">first</span> <span class="pre">line</span> <span class="pre">and</span>
<span class="pre">then</span> <span class="pre">a</span> <span class="pre">new</span> <span class="pre">instance</span> <span class="pre">*f*</span> <span class="pre">is</span> <span class="pre">created.</span> <span class="pre">The</span> <span class="pre">optional</span> <span class="pre">*pattern*</span> <span class="pre">keyword</span> <span class="pre">is</span> <span class="pre">used</span> <span class="pre">to</span> <span class="pre">only</span> <span class="pre">collect</span>
<span class="pre">the</span> <span class="pre">files</span> <span class="pre">with</span> <span class="pre">a</span> <span class="pre">.dat</span> <span class="pre">extension.</span> <span class="pre">In</span> <span class="pre">this</span> <span class="pre">example,</span> <span class="pre">it</span> <span class="pre">is</span> <span class="pre">assumed</span> <span class="pre">that</span> <span class="pre">the</span> <span class="pre">files</span> <span class="pre">are</span> <span class="pre">readable</span> <span class="pre">by</span>
<span class="pre">:py:class:`{DataFile</span></tt>, if they are in some other format then the <em>type</em> keyword can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">Stoner.FileFormats</span> <span class="kn">import</span> <span class="n">XRDFile</span>
<span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">XRDFile</span><span class="p">,</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.dql&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To specify a particular directory to look in, simply give the directory as the first
argument - otherwise the current duirectory will be used.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="s">&#39;/home/phygbu/Data&#39;</span><span class="p">,</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.tdi&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If you pass False into the constructor as the first argument then the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> will
display a dialog box to let you choose a directory. If you add a &#8216;multifile=True&#8217; keyword argument
then you can use the dialog box to select multiple individual files.</p>
<p>Any other keyword arguments that are not attributes of <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> are instead passed to the
constructor for the individual <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a> instances as they are loaded from disc. This,
for example, can allow one to set the default <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile.setas" title="Stoner.Core.DataFile.setas"><tt class="xref py py-attr docutils literal"><span class="pre">Stoner.Core.DataFile.setas</span></tt></a> attribute for each file.</p>
<p>By default the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> constructor will perform a recursive drectory listing of
the working folder. Each sub-directory is given a separate <em>group</em> within the structure.
This allows the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> to logically represent the on-disc layout of the files.</p>
</div>
<div class="section" id="manipulating-the-file-list-in-a-folder">
<h2>Manipulating the File List in a Folder<a class="headerlink" href="#manipulating-the-file-list-in-a-folder" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>If you don&#8217;t want the file listing to be recursive, this can be suppressed by using the <em>recursive</em></dt>
<dd><p class="first">keyword argument and the file listing can be suppressed altogether with the <em>nolist</em> keyword:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.dat&#39;</span><span class="p">,</span><span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">f2</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">nolist</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>If you don&#8217;t want to create groups for each sub-directory, then set the keyword parameter
<em>flatten</em> <strong>True</strong>, or call the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.flatten.html#Stoner.Folders.DataFolder.flatten" title="Stoner.Folders.DataFolder.flatten"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.flatten()</span></tt></a> method. You can also use the
<tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.prune()</span></tt> method to remove groups (including nested groups) that have
no data files in them.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
<p>If you need to combine multiple <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> objects or add <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a>
objects to an existing <a href="#id1"><span class="problematic" id="id2">:py:ckass:`DataFolder`</span></a> then the arithmetic addition operator can be used:</p>
<div class="highlight-python"><div class="highlight"><pre>f2=DataFolder(&#39;/data/test1&#39;)
f3=DataFolder(&#39;/data/test2&#39;)
f=f2+f3

 f+=DataFile(&#39;/data/test3/special.txt&#39;)
</pre></div>
</div>
</div>
<div class="section" id="getting-a-list-of-files">
<h2>Getting a List of Files<a class="headerlink" href="#getting-a-list-of-files" title="Permalink to this headline">¶</a></h2>
<p>The resulting list of files can be accessed via the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.files" title="Stoner.Folders.DataFolder.files"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.files</span></tt></a> attribute
and sub groups with the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.group</span></tt></a> attribute (see <em class="xref std std-ref">groups</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">files</span>
<span class="n">f</span><span class="o">.</span><span class="n">groups</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In some circumstances entries in the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.files" title="Stoner.Folders.DataFolder.files"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.files</span></tt></a> attribute can be
<a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a> objects rather than strings. If you want to ensure
that you get a list of strings representing the filenames, use <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.ls" title="Stoner.Folders.DataFolder.ls"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.ls</span></tt></a> instead.</p>
</div>
</div>
<div class="section" id="controlling-the-gathering-of-the-list-of-files">
<h2>Controlling the Gathering of the List of Files<a class="headerlink" href="#controlling-the-gathering-of-the-list-of-files" title="Permalink to this headline">¶</a></h2>
<p>The current root directory and pattern are stored in the <em>directory</em> and <em>pattern</em> keywords and the
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.getlist.html#Stoner.Folders.DataFolder.getlist" title="Stoner.Folders.DataFolder.getlist"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.getlist()</span></tt></a> method can be used to force a new listing of files.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">dirctory</span><span class="o">=</span><span class="s">&#39;/home/phygbu/Data&#39;</span>
<span class="n">f</span><span class="o">.</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.txt&#39;</span>
<span class="n">f</span><span class="o">.</span><span class="n">getlist</span><span class="p">()</span>
</pre></div>
</div>
<p>Sometimes a more complex filename matching mechanism than simple &#8216;&#8217;globbing&#8217;&#8217; is useful.
The <em>pattern</em> keyword can also be a compiled regular expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>
<span class="n">p</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;i10-\d*.dat&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="n">p2</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;i10-(?P&lt;run&gt;\d*)&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;run&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The second case illustrates a useful feature of regular expressions - they can be used to capture
parts of the matched pattern &#8211; and in the python version, one can name the capturing groups.
In both cases above the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> has the same file members (basically these
would be runs produced by the i10 beamline at Diamond), but in the second case the run
number (which comes after &#8216;&#8217;i10-&#8216;&#8217; would be captured and presented as the &#8216;&#8217;run&#8217;&#8217; parameter in
the metadata when the file was read.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that the files are not modified - the extra metadata is only added as the file is read by the <tt class="xref py py-class docutils literal"><span class="pre">DataFlder</span></tt>.</p>
</div>
<p>The loading process will also add the metadata key &#8216;&#8217;Loaded From&#8217;&#8217; to the file which will give you a
note of the filename used to read the data. If the attribute <tt class="xref py py-attr docutils literal"><span class="pre">DataFoilder.read_means</span></tt> is set to <strong>True</strong>
then additional metadata is set for each file that contains the mean value of each column of data.</p>
</div>
<div class="section" id="doing-something-with-each-file">
<h2>Doing Something With Each File<a class="headerlink" href="#doing-something-with-each-file" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>A <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> is an object that you can iterate over, lading the <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a></dt>
<dd>type object for each of the files in turn. This probides an easy way to run through a set of files,</dd>
</dl>
<p>performing the same operation on each:</p>
<div class="highlight-python"><div class="highlight"><pre>folder=DataFolder(pattern=&#39;*.tdi&#39;)
for f in folder:
            f=AnalyseFile(f)
    f.normalise(&#39;mac116&#39;,&#39;mac119&#39;)
    f.save()
</pre></div>
</div>
<p>or even more compacts:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="s">&#39;mac116&#39;</span><span class="p">,</span><span class="s">&#39;macc119&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">DataFolder</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s">&#39;*.tdi&#39;</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="n">AnalyseFile</span><span class="p">)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> is also indexable and has a length:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">=</span><span class="n">DataFolder</span><span class="p">()</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">f</span><span class="p">[</span><span class="s">&#39;filename&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>For the second case of indexing, the cose will search the list of file names for a matching file
and return that (roughly equivalent to doing <tt class="docutils literal"><span class="pre">f.files.index(&quot;filename&quot;)]</span></tt>)</p>
<p>If you want to know the filename of all the files in the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> then there is a
handy attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">ls</span>
<span class="n">f</span><span class="o">.</span><span class="n">basenames</span>
</pre></div>
</div>
<p>The difference between these two is that <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.basenames" title="Stoner.Folders.DataFolder.basenames"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.basenames</span></tt></a> will return only the file part
of the filename whilst <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.ls" title="Stoner.Folders.DataFolder.ls"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.ls</span></tt></a> returns the complete path from the root directory.</p>
<hr class="docutils" />
<p>The order of the files in a <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> is arbitrary. If it is important to process
them in a given order then the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.sort.html#Stoner.Folders.DataFolder.sort" title="Stoner.Folders.DataFolder.sort"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.sort()</span></tt></a> method can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">f</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;tmperature&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="s">&#39;Temperature&#39;</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>The first variant simply sorts the files by filename. The second and third variants both
look at the &#8216;&#8217;temperature&#8217;&#8217; metadata in each file and use that as the sort key. In the
third variant, the <em>revers</em> keyword is used to reverse the order of the sort. In the final
variant, each file is loaded in turn and the supplied function is called and evaluated to find a
sort key.</p>
<p>The <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.filter.html#Stoner.Folders.DataFolder.filter" title="Stoner.Folders.DataFolder.filter"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.filter()</span></tt></a> method can be used to prune the list of files to be used by the
<tt class="xref py py-class docutils literal"><span class="pre">DataFoler</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s">&#39;[ab]*.dat&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">f</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;i10-\d*\.dat&#39;</span><span class="p">))</span>
<span class="n">f</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;Temperature&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">150</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s">&#39;Temperature&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">150</span><span class="p">,</span><span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The first form performs the filter on the filenames (using the standard python fnmatch module).
One can also use a regular expression as illustrated int he second example &#8211; although unlike using
the <em>pattern</em> keyword in <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.getlist.html#Stoner.Folders.DataFolder.getlist" title="Stoner.Folders.DataFolder.getlist"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.getlist()</span></tt></a>, there is no option to capture metadata
(although one could then subsequently set the pattern to achieve this). The third variant calls the
supplied function, passing the current file as a <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a> object in each time.
If the function evaluates to be <strong>True</strong> then the file is kept. The <em>invert</em> keyword is used to invert
the sense of the filter (a particularly silly example here, since the greater than sign could simply
be replaced with a less than or equals sign !).</p>
<p>One of the more common tasks is to group a long list of data files into separate groups
according to some logical test &#8211;  for example gathering files with magnetic field sweeps in a positive
direction together and those with magnetic field in a negative direction together. The
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.group()</span></tt></a> method provides a powerful way to do this. Suppose we have a series of
data curves taken at a variety of temperatures and with three different magnetic fields:</p>
<div class="highlight-python"><div class="highlight"><pre>f.group{&#39;temperature&#39;}
f.group(lambda x:&quot;positive&quot; if x[&#39;B-Field&#39;]&gt;0 else &quot;negative&quot;)
f.group([&#39;temperature&#39;,lambda x:&quot;positive&quot; if x[&#39;B-Field&#39;]&gt;0 else &quot;negative&quot;])
f.groups
</pre></div>
</div>
<p>The <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.group()</span></tt></a> method splits the files in the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> into several
groups each of which share a common value of the arguement supplied to the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.group()</span></tt></a>
method. A group is itself another instance of the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> class. Each
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> object maintains a dictionary called <tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.groups</span></tt> whose keys
are the distinct values of the argument of the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.group()</span></tt></a> methods and whose values are
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> objects. So, if our <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> <em>f</em> contained files measured at
4.2, 77 and 300K and at fields of 1T and -1T then the first variant would create 3 groups: 4.2, 77 and
300 each one of which would be a <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> object congaing the files measured at those
temperatures. The second variant would produce 2 groups &#8211; &#8216;&#8217;positive&#8217;&#8217; containing the files measured with
magnetic field of 1T and &#8216;&#8217;negative&#8217;&#8217; containing the files measured at -1T. The third variant then goes
one stage further and would produce 3 groups, each of which in turn had 2 groups. The groups are accessed
via the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.group.html#Stoner.Folders.DataFolder.group" title="Stoner.Folders.DataFolder.group"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.group</span></tt></a> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="mf">4.2</span><span class="p">]</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="s">&quot;positive&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">files</span>
</pre></div>
</div>
<p>would return a list of the files measured at 4.2K and 1T.</p>
<p>If you try indexing a <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> with a string and there is no file with as its filename
and there is a group with a key of the same string then <a href="#id3"><span class="problematic" id="id4">:py:clkass:`DataFolder`</span></a> will return the
corresponding group. This allows a more compact navigation through an extended group structure.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">group</span><span class="p">([</span><span class="s">&#39;project&#39;</span><span class="p">,</span><span class="s">&#39;sample&#39;</span><span class="p">,</span><span class="s">&#39;device&#39;</span><span class="p">])</span>
<span class="n">f</span><span class="p">[</span><span class="s">&#39;ASF&#39;</span><span class="p">][</span><span class="s">&#39;ASF038&#39;</span><span class="p">][</span><span class="s">&#39;A&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>If you just ant to create a new empty group in your <tt class="xref py py-class docutils literal"><span class="pre">DataFoler</span></tt>, you can use
the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.add_group.html#Stoner.Folders.DataFolder.add_group" title="Stoner.Folders.DataFolder.add_group"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.add_group()</span></tt></a> method.:</p>
<div class="highlight-python"><div class="highlight"><pre>`f.add_group(&quot;key_value&quot;)
</pre></div>
</div>
<p>which will create the new group with a key of &#8216;&#8217;key_value&#8217;&#8216;.</p>
<div class="section" id="reducing-data">
<h3>Reducing Data<a class="headerlink" href="#reducing-data" title="Permalink to this headline">¶</a></h3>
<p>An important driver for the development of the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> class has been to aid
data reduction tasks. The simplest form of data reduction would be to gather one or more
columns from each of a folder of files and return it as a single large table or matrix. This task is
easily accomplished by the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.gather.html#Stoner.Folders.DataFolder.gather" title="Stoner.Folders.DataFolder.gather"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.gather()</span></tt></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="s">&quot;X Data&quot;</span><span class="p">,</span><span class="s">&quot;Y Data&quot;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="s">&quot;X Data&quot;</span><span class="p">,[</span><span class="s">&quot;Ydata 1&quot;</span><span class="p">,</span><span class="s">&quot;Y Data 2&quot;</span><span class="p">])</span>
<span class="n">f</span><span class="o">.</span><span class="n">gather</span><span class="p">()</span>
</pre></div>
</div>
<p>In the first two forms you specify the x column and one or more y columns. In the third form, the
x and y columns are determined by the values from the <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile.setas" title="Stoner.Core.DataFile.setas"><tt class="xref py py-attr docutils literal"><span class="pre">Stoner.Core.DataFile.setas</span></tt></a> attribute.
(you can set the value of this attribute for all files in the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> by setting the
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder.setas" title="Stoner.Folders.DataFolder.setas"><tt class="xref py py-attr docutils literal"><span class="pre">DataFolder.setas</span></tt></a> attribute.)</p>
<p>A similar operation to <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.gather.html#Stoner.Folders.DataFolder.gather" title="Stoner.Folders.DataFolder.gather"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.gather()</span></tt></a> is to build a new set of data where each row corresponds
to a set of metadata values from each file in the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a>. This can be achieved with the
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.extract.html#Stoner.Folders.DataFolder.extract" title="Stoner.Folders.DataFolder.extract"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.extract()</span></tt></a> method.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">extract</span><span class="p">([</span><span class="s">&quot;Temperature&quot;</span><span class="p">,</span><span class="s">&quot;Angle&quot;</span><span class="p">,</span><span class="s">&quot;Other_metadata&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>The argument to the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.extract.html#Stoner.Folders.DataFolder.extract" title="Stoner.Folders.DataFolder.extract"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.extract()</span></tt></a> method is a list of metadata values to be extracted from each file. The
metadata should be convertable to an array type so that it can be included in the final result matrix. Any metadata that doesn&#8217;t
appear to be so convertible in the first file in the ;py:class:<cite>DataFolder</cite> is ignored. The column headings of the final results
table are the names of the metadata that were used in the extraction.</p>
<p>One task you might want to do would be to work through all the groups in a <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a>
and run some function either with each file in the group or on the whole group. This is further
complicated if you want to iterate over all the sub-groups within a group. The
<a class="reference internal" href="../classes/Stoner.Folders.DataFolder.walk_groups.html#Stoner.Folders.DataFolder.walk_groups" title="Stoner.Folders.DataFolder.walk_groups"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.walk_groups()</span></tt></a> method is useful here.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">walk_groups</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">group</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">replace_terminal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">walker_args</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;arg1&quot;</span><span class="p">:</span><span class="s">&quot;value1&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>This will iterate over the complete hierarchy of groups and sub groups in the folder and
execute the function <em>func</em> once for each group. If the <em>group</em> parameter is <strong>False</strong>
then it will execute <em>func</em> once for each file. The function <em>fun</em> should be defined something like:</p>
<div class="highlight-python"><div class="highlight"><pre>def func(group,list_of-group_keys,arg1,arg2...)
</pre></div>
</div>
<p>The first parameter should expect and instance of <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a> if
<em>group</em> is <strong>False</strong> or an instance of <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.html#Stoner.Folders.DataFolder" title="Stoner.Folders.DataFolder"><tt class="xref py py-class docutils literal"><span class="pre">DataFolder</span></tt></a> if <em>group</em> is <strong>True</strong>.
The second parameter will be given a list of of strings representing the group key values from
the topmost group to the lowest (terminal) group.</p>
<p>The <em>replace_terminal</em> parameter applies when <em>group</em> is <strong>True</strong> and the function returns a
<tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core,DataFile</span></tt> object. This indicates that the group on which the function was
called should be removed from the list fo groups and the returned <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a>
object should be added to the list of files in the folder. This operation is useful when one is
processing a group of files to combined them into a single dataset. Combining a multi-level grouping
operation and successive calls to <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.walk_groups.html#Stoner.Folders.DataFolder.walk_groups" title="Stoner.Folders.DataFolder.walk_groups"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.walk_groups()</span></tt></a> can rapidly reduce a large set of
data files representing a multi-dimensional data set into a single file with minimal coding.</p>
<p>In some cases you will want to work with sets of files coming from different groups in order.
For example, if above we had a sequence of 10 data files for each field and temperature and we wanted
to process the positive and negative field curves together for a given temperature in turn.
In this case the <a class="reference internal" href="../classes/Stoner.Folders.DataFolder.zip_groups.html#Stoner.Folders.DataFolder.zip_groups" title="Stoner.Folders.DataFolder.zip_groups"><tt class="xref py py-meth docutils literal"><span class="pre">DataFolder.zip_groups()</span></tt></a> method can be useful.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="mf">4.2</span><span class="p">]</span><span class="o">.</span><span class="n">zip_groups</span><span class="p">([</span><span class="s">&#39;positive&#39;</span><span class="p">,</span><span class="s">&#39;negative&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This would return a list of tuples of <a class="reference internal" href="../classes/Stoner.Core.DataFile.html#Stoner.Core.DataFile" title="Stoner.Core.DataFile"><tt class="xref py py-class docutils literal"><span class="pre">Stoner.Core.DataFile</span></tt></a> objects where the tuples
would be the first positive and first negative field files, then the second of each, then third of
each and so. This presupposes that the files started of sorted by some suitable parameter
(eg a gate voltage).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/StonerLogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Working with Lots of Files</a><ul>
<li><a class="reference internal" href="#building-a-virtual-folder-of-data-files">Building a (virtual) Folder of Data Files</a></li>
<li><a class="reference internal" href="#manipulating-the-file-list-in-a-folder">Manipulating the File List in a Folder</a></li>
<li><a class="reference internal" href="#getting-a-list-of-files">Getting a List of Files</a></li>
<li><a class="reference internal" href="#controlling-the-gathering-of-the-list-of-files">Controlling the Gathering of the List of Files</a></li>
<li><a class="reference internal" href="#doing-something-with-each-file">Doing Something With Each File</a><ul>
<li><a class="reference internal" href="#reducing-data">Reducing Data</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="analysisfile.html"
                        title="previous chapter">Analysing Data Files</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cookbook.html"
                        title="next chapter">Cookbook</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/UserGuide/datafolder.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cookbook.html" title="Cookbook"
             >next</a> |</li>
        <li class="right" >
          <a href="analysisfile.html" title="Analysing Data Files"
             >previous</a> |</li>
        <li><a href="../index.html">Stoner Package</a> &raquo;</li>
          <li><a href="ugindex.html" >The Stoner Python Package User Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Gavin Burnell et al.
      Last updated on Mar 14, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>