*********
Cookbook
*********

This section gives some short examples to give an idea of things that can be
done with the Stoner python module in just a few lines.

The Utils module
================

.. currentmodule:: Stoner.Utils

The **Stoner** package comes with an extra :py:mod:`Stoner.Utils` module that includes some handy utility 
functions. 

Splitting Data into rising and falling values
---------------------------------------------

So far the module just contains one function that will take a single :py:class:`Stoner.Core.DataFile`
 object and split it into a series of :py:class:`Stoner.Core.DataFile` objects where one column is either 
rising or falling. This is designed to help deal with analysis problems involving hysteretic data.::

    from Stoner.Utils import split_up_down
    folder=split_up_down(data,column)

*folder*is a :py:class:`Stoner.Folders.DataFolder` instance with two groups, one for rising values of the column
 and one for falling values of the column. The :py:func:`split\_up_down` will take an optional third parameter 
which is an existing :py:class:`Stoner.Core.DataFolder` instance to which the new groups (if they 
don't already exist) and files will be added.  

Other Recipies
==============

Extract X-Y(Z) from X-Y-Z data
------------------------------

In a number of measurement systems the data is returned as 3 parameters X, Y and
Z and one wishes to extract X-Y as a function of constant Z. For example, *I-V*
sweeps as a function of gate voltage *V:sub:G*. Assuming we have a data file with
columns *Current*, *Voltage*,*Gate*::

   d=DataFile('data.txt')
   t=d
   for gate in d.unique('Gate'):
       t.data=d.search('Gate',gate)
       t.save('Data Gate='+str(gate)+'.txt')

The first line opens the data file containing the *I-V(V_G)* data. The second
creates a temporary copy of the :py:class:`Stoner.Core.DataFile` object - ensuring that we get a copy of
all metadata and column headers. The **for** loop iterates over all unique
values of the data in the gate column and then inside the for loop, searches for
the corresponding *I-V* data, sets it as the data of the temporary DataFile and
then saves it.

Mapping X-Y-Z data to Z(X,Y) data
----------------------------------

In a similar fashion to the previous section, where data has been recorded with
fixed values of *X* and *Y* eg *I* measured for fixed *V* and *V_*, it can be
useful to map the data to a matrix.::

   d=DataFile('Data,.txt')
   t=d
   for gate in d.unique('Gate'):
      t=t+d.search('Gate',gate)[:,d.find_col('Current')]
   t.column_headers=['Bias='+str(x) for x in d.unique('Voltage')]
   t.add_column(d.unique('Gate'),'Gate Voltage',0)

The start of the script follows the previous section, however this time in the
for loop the addition operator is used to add a single row to the temporary
:py:class:`Stoner.Core.DataFile` *t*. In this case we are using the utility method
:py:meth:`Stoner.Core.DataFile.find_col` to find the index of the column with the current
data. After the **for** loop we set the column headers in *t* and then insert
an additional column at the start with the gate voltage values.

The matrix generated by this code is suitable for feeding directly into 
:py:meth:`Stoner.Plot.PlotFile.plot_matrix`, however, the same plot could be generated 
directly from the :py:meth:`Stoner.Plot.PlotFile.plot_xyz` method too.

Sampling a A 3D Surface function
--------------------------------

Suppose you have a function Z(x,y) that is defined over a range -X0..+X0 and 
-Y0..y0 and want to quickly get a view of the surface. This problem can be easily done
by creating a random distribution of (x,y) points, evaluating the function and then
using the :py:class:`PlotFile` methods to generate the surface.::

    from Stoner.Plot import PlotFile
    from numpy import uniform

    samples=5000

    surf=PlotFile()
    surf&=uniform(-X0,X0,samples)
    surf&=uniform(-Y0,Y0,samples)
    surf.setas="xy"
    surf&=Z(surf.x,surf.y)
    surf.setas="xyz"
    surf.plot() # or surf.plot(cstride=1,rstride=1,linewidth=0) for finer detail.

Correcting a Hysteresis Loop
----------------------------

In our research we measure a lot of magnetic-hysteresis loops. In these measurements the
hysteresis loop is often superimposed on a (diamagnetic) signal from the sample stick. Furthermore,
the loop can be offset vertically as well. Here we will demonstrate how to use the various Stoner classes
to correct a loop. The data for this example can be found in the sample-data folder in the source code
repository. The basic principle is to fit a straight line to the outermost 20% of the positive and negative
field ranges of the loops. Avergaing the co-efficients of the fit gives the diamagnetic component and
the verticla offset. These can then be used to subtract the fit to find the residual loop.::

    from Stoner.Plot import PlotFile
    from Stoner.Analysis import AnalyseFile
    from Stoner.FileFormats import QDSquidVSMFile
    from Stoner.Fit import Linear

    class Data(QDSquidVSMFile,PlotFile,AnalyseFile): # Create a suitable mixin of DataFile types
        pass

    d=Data("QD-SQUID-VSM.dat")
    d.setas="3.xy" # The setas can be used in DataFile to set preferred X and Y columns
    #Fit straight lines to the extremes of the loop to get diamagnetic component
    pneg,pcov=d.curve_fit(Linear,bounds=lambda y,r:r<0.8*d.min(3)[0])
    ppos,pcov=d.curve_fit(Linear,bounds=lambda y,r:r>0.8*d.max(3)[0])
    popt=(pneg+ppos)/2 # Average of two fits gives diamgnetic slope and vertical offset

    # Use average fit to remove diamagnetism and offset
    d.add_column(d.y-Linear(d.x,*popt),"Corrected Moment",4)

    # Get co-oercive fields and remancnce
    Hc=d.threshold(0,rising=True,falling=True,all_vals=True)
    Br=d.threshold(0,col=3,xcol=4,rising=True,falling=True,all_vals=True)

    #Plot the data
    d.plot()
    #Legend will be badly placed for a loop
    leged(loc=4) #Assuming you have pylab imported into the current namespace

Quickly Sectioning a 3D dataset
-------------------------------

We often model the magnetic state in our experiments using a variety of micromagnetic 
modelling codes, such OOMMF or MuMax. When modelling a 3D system, it is often useful to
be able to examine a cross-section of the simulation. The Stoner package provides tools
to quickly examine the output data::

    from Stoner.FileFormats import OVFFile # reads OOMMF vector field files
    import Stoner.Plot
    p=SP.PlotFile('my_simulation.ovf')
    p.setas="xyzuvw"
    p=p.section(z=10.5) # Take a slice inthe xy plane where z is 10.5 nm
    p.plot() # A 3D plot with cones
    p.setas="xy.uvw"
    p.plot() # a 2D colour wheel plot with triangular glyphs showing vector direction.
